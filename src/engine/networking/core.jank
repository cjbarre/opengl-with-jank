(ns engine.networking.core
  (:require [engine.macros :refer [clet]]))

;; enet implementation is in libs/{platform}/enet/lib/libenet.{dylib,so}
;; On Linux, libenet.so is built from the bundled single-header include/enet.h
(cpp/raw
 "#include \"enet.h\"
  #include <cstring>
  #include <string>")

;; C helper functions for ENet - only keeping what requires struct init, NULL pointers, or complex logic
(cpp/raw
 "// Client needs NULL pointer as first arg (NULL -> pointer cast not supported)
  inline ENetHost* create_client_host() {
    return enet_host_create(NULL, 1, 2, 0, 0);
  }

  // Server needs struct init with memset + field assignment
  inline ENetHost* create_server_host(uint16_t port, size_t max_clients) {
    ENetAddress addr;
    memset(&addr, 0, sizeof(addr));
    addr.host = in6addr_any;
    addr.port = port;
    return enet_host_create(&addr, max_clients, 2, 0, 0);
  }

  // Connect needs struct field assignment
  inline ENetPeer* connect_to_host(ENetHost* host, const char* hostname, uint16_t port) {
    ENetAddress addr;
    enet_address_set_host(&addr, hostname);
    addr.port = port;
    return enet_host_connect(host, &addr, 2, 0);
  }

  // Packet send needs ternary + conditional
  inline int send_packet(ENetPeer* peer, const char* data, size_t len, int channel, bool reliable) {
    uint32_t flags = reliable ? ENET_PACKET_FLAG_RELIABLE : 0;
    ENetPacket* packet = enet_packet_create(data, len, flags);
    if (!packet) return -1;
    return enet_peer_send(peer, channel, packet);
  }

  // Broadcast needs ternary + conditional
  inline void broadcast_packet(ENetHost* host, const char* data, size_t len, int channel, bool reliable) {
    uint32_t flags = reliable ? ENET_PACKET_FLAG_RELIABLE : 0;
    ENetPacket* packet = enet_packet_create(data, len, flags);
    if (packet) {
      enet_host_broadcast(host, channel, packet);
    }
  }

  // Data copy needs malloc + memcpy + null terminate
  inline char* get_event_data_copy(ENetEvent* event) {
    if (event->packet && event->packet->data && event->packet->dataLength > 0) {
      size_t len = event->packet->dataLength;
      char* copy = (char*)malloc(len + 1);
      if (copy) {
        memcpy(copy, event->packet->data, len);
        copy[len] = '\\0';
      }
      return copy;
    }
    return nullptr;
  }

  // Peer ID needs pointer arithmetic
  inline uint32_t get_peer_id(ENetPeer* peer) {
    if (peer && peer->host) {
      return (uint32_t)(peer - peer->host->peers);
    }
    return 0;
  }

  // Destroy event packet (field access returns reference, can't use in when)
  inline void destroy_event_packet(ENetEvent* event) {
    if (event->packet) {
      enet_packet_destroy(event->packet);
    }
  }

  // Free data copy (char* to void* cast not supported)
  inline void free_data_copy(char* data) {
    if (data) {
      free(data);
    }
  }")

;; Lifecycle

(defn init!
  "Initialize ENet. Must be called before any other networking functions."
  []
  (cpp/== (cpp/enet_initialize) (cpp/int 0)))

(defn shutdown!
  "Shutdown ENet. Call when done with networking."
  []
  (cpp/enet_deinitialize)
  nil)

;; Host management

(defn create-server
  "Create a server host listening on the given port.
   Returns a boxed ENetHost* or nil on failure."
  [{:keys [port max-clients] :or {max-clients 32} :as args}]
  (let [host (cpp/create_server_host (cpp/int port) (cpp/int max-clients))]
    (when-not (cpp/! host)
      (cpp/box host))))

(defn create-client
  "Create a client host (not bound to any port).
   Returns a boxed ENetHost* or nil on failure."
  []
  (clet [host (cpp/create_client_host)
         :when (cpp/! host)
         :error nil]
    (cpp/box host)))

(defn destroy-host
  "Destroy a host and free its resources."
  [host]
  (cpp/enet_host_destroy (cpp/unbox (cpp/type "ENetHost*") host))
  nil)

;; Connection management

(defn connect
  "Connect a client host to a server.
   Returns a boxed ENetPeer* or nil on failure."
  [host {:keys [address port] :as args}]
  (clet [host* (cpp/unbox (cpp/type "ENetHost*") host)
         peer (cpp/connect_to_host host* address (cpp/int port))
         :when (cpp/! peer)
         :error nil]
    (cpp/box peer)))

(defn disconnect
  "Gracefully disconnect a peer."
  [peer]
  (cpp/enet_peer_disconnect (cpp/unbox (cpp/type "ENetPeer*") peer) 0)
  nil)

(defn disconnect-now
  "Immediately disconnect a peer without waiting for acknowledgment."
  [peer]
  (cpp/enet_peer_disconnect_now (cpp/unbox (cpp/type "ENetPeer*") peer) 0)
  nil)

;; Messaging

(defn send-reliable
  "Send data reliably to a peer (will be retransmitted if lost).
   data should be a string. Returns 0 on success, negative on failure."
  [peer data]
  (let [peer* (cpp/unbox (cpp/type "ENetPeer*") peer)
        len (count data)]
    (cpp/send_packet peer* data (cpp/int len) 0 true)))

(defn send-unreliable
  "Send data unreliably to a peer (may be lost, but lower latency).
   data should be a string. Returns 0 on success, negative on failure."
  [peer data]
  (let [peer* (cpp/unbox (cpp/type "ENetPeer*") peer)
        len (count data)]
    (cpp/send_packet peer* data (cpp/int len) 1 false)))

(defn broadcast-reliable
  "Broadcast data reliably to all connected peers."
  [host data]
  (let [host* (cpp/unbox (cpp/type "ENetHost*") host)
        len (count data)]
    (cpp/broadcast_packet host* data (cpp/int len) 0 true)
    nil))

(defn broadcast-unreliable
  "Broadcast data unreliably to all connected peers."
  [host data]
  (let [host* (cpp/unbox (cpp/type "ENetHost*") host)
        len (count data)]
    (cpp/broadcast_packet host* data (cpp/int len) 1 false)
    nil))

;; Event polling

(defn poll-events
  "Poll for network events with the given timeout in milliseconds.
   Returns a vector of event maps. Each event has:
   - :type - :connect, :disconnect, :receive, or :none
   - :peer - boxed ENetPeer* (for connect/disconnect/receive)
   - :peer-id - numeric peer ID
   - :data - string data (for receive events only)"
  [host timeout-ms]
  (let [host* (cpp/unbox (cpp/type "ENetHost*") host)
        event (cpp/new (cpp/type "ENetEvent"))]
    (loop [events []
           first-poll true]
      ;; First iteration uses timeout-ms, subsequent use 0
      (let [timeout (if first-poll (cpp/int timeout-ms) (cpp/int 0))
            result (cpp/enet_host_service host* event timeout)]
        (if (> result 0)
          (let [event-type (cpp/.-type event)
                peer-ptr (cpp/.-peer event)
                peer-id (cpp/get_peer_id peer-ptr)
                evt (cond
                      ;; ENET_EVENT_TYPE_CONNECT = 1
                      (= event-type 1)
                      {:type :connect
                       :peer (cpp/box peer-ptr)
                       :peer-id peer-id}

                      ;; ENET_EVENT_TYPE_DISCONNECT = 2
                      (= event-type 2)
                      {:type :disconnect
                       :peer (cpp/box peer-ptr)
                       :peer-id peer-id}

                      ;; ENET_EVENT_TYPE_RECEIVE = 3
                      (= event-type 3)
                      (let [data-copy (cpp/get_event_data_copy event)
                            _ (cpp/destroy_event_packet event)
                            data-str (when data-copy (str data-copy))
                            _ (cpp/free_data_copy data-copy)]
                        {:type :receive
                         :peer (cpp/box peer-ptr)
                         :peer-id peer-id
                         :data data-str})

                      :else
                      {:type :none})]
            ;; Continue polling with 0 timeout to drain
            (recur (conj events evt) false))
          ;; No more events
          events)))))

(defn flush-host
  "Flush any pending outgoing packets."
  [host]
  (cpp/enet_host_flush (cpp/unbox (cpp/type "ENetHost*") host))
  nil)

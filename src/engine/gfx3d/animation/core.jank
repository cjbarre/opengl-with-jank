(ns engine.gfx3d.animation.core
  (:require [engine.macros :refer [clet]]))

;; Include ozz-animation headers and define C++ helper structures
(cpp/raw "#include \"animation_types.h\"

  // Factory function to avoid copy construction issues
  inline AnimationContext* create_animation_context() {
    return new AnimationContext();
  }")
(cpp/raw
 "#include <iostream>
  #include \"ozz/animation/runtime/animation.h\"
  #include \"ozz/animation/runtime/skeleton.h\"
  #include \"ozz/animation/runtime/sampling_job.h\"
  #include \"ozz/animation/runtime/local_to_model_job.h\"
  #include \"ozz/base/io/archive.h\"
  #include \"ozz/base/io/stream.h\"
  #include \"ozz/base/maths/soa_transform.h\"
  #include \"ozz/base/maths/simd_math.h\"
  #include \"ozz/base/maths/math_archive.h\"
  #include \"ozz/base/maths/simd_math_archive.h\"
  #include \"ozz/base/containers/vector.h\"
  #include \"ozz/base/containers/vector_archive.h\"
  #include \"ozz_mesh.h\"

  #include <fstream>
  #include <cstring>

  // Mesh archive implementation (from ozz samples framework)
  namespace ozz {
  namespace io {

  inline void Extern<sample::Mesh::Part>::Save(OArchive& _archive,
                                        const sample::Mesh::Part* _parts,
                                        size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const sample::Mesh::Part& part = _parts[i];
      _archive << part.positions;
      _archive << part.normals;
      _archive << part.tangents;
      _archive << part.uvs;
      _archive << part.colors;
      _archive << part.joint_indices;
      _archive << part.joint_weights;
    }
  }

  inline void Extern<sample::Mesh::Part>::Load(IArchive& _archive,
                                        sample::Mesh::Part* _parts, size_t _count,
                                        uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      sample::Mesh::Part& part = _parts[i];
      _archive >> part.positions;
      _archive >> part.normals;
      _archive >> part.tangents;
      _archive >> part.uvs;
      _archive >> part.colors;
      _archive >> part.joint_indices;
      _archive >> part.joint_weights;
    }
  }

  inline void Extern<sample::Mesh>::Save(OArchive& _archive, const sample::Mesh* _meshes,
                                  size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const sample::Mesh& mesh = _meshes[i];
      _archive << mesh.parts;
      _archive << mesh.triangle_indices;
      _archive << mesh.joint_remaps;
      _archive << mesh.inverse_bind_poses;
    }
  }

  inline void Extern<sample::Mesh>::Load(IArchive& _archive, sample::Mesh* _meshes,
                                  size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      sample::Mesh& mesh = _meshes[i];
      _archive >> mesh.parts;
      _archive >> mesh.triangle_indices;
      _archive >> mesh.joint_remaps;
      _archive >> mesh.inverse_bind_poses;
    }
  }
  }  // namespace io
  }  // namespace ozz

  // AnimationContext is defined in animation_types.h

  // Load skeleton from .ozz file
  inline ozz::animation::Skeleton* load_skeleton_ozz(const char* path) {
    ozz::io::File file(path, \"rb\");
    if (!file.opened()) {
      return nullptr;
    }
    ozz::io::IArchive archive(&file);
    if (!archive.TestTag<ozz::animation::Skeleton>()) {
      return nullptr;
    }
    ozz::animation::Skeleton* skeleton = new ozz::animation::Skeleton();
    archive >> *skeleton;
    return skeleton;
  }

  // Load animation from .ozz file
  inline ozz::animation::Animation* load_animation_ozz(const char* path) {
    ozz::io::File file(path, \"rb\");
    if (!file.opened()) {
      return nullptr;
    }
    ozz::io::IArchive archive(&file);
    if (!archive.TestTag<ozz::animation::Animation>()) {
      return nullptr;
    }
    ozz::animation::Animation* animation = new ozz::animation::Animation();
    archive >> *animation;
    return animation;
  }

  // Sample animation at a given time ratio (0.0 to 1.0)
  inline bool sample_animation_ozz(AnimationContext* ctx, ozz::animation::Animation* anim, float time_ratio) {
    if (!ctx || !anim || !ctx->skeleton) {
      return false;
    }

    // Sample animation
    ozz::animation::SamplingJob sampling_job;
    sampling_job.animation = anim;
    sampling_job.context = &ctx->context;
    sampling_job.ratio = time_ratio;
    sampling_job.output = ozz::make_span(ctx->locals);
    if (!sampling_job.Run()) {
      return false;
    }

    // Convert to model space
    ozz::animation::LocalToModelJob ltm_job;
    ltm_job.skeleton = ctx->skeleton;
    ltm_job.input = ozz::make_span(ctx->locals);
    ltm_job.output = ozz::make_span(ctx->models);
    if (!ltm_job.Run()) {
      return false;
    }

    return true;
  }

  // Get number of model matrices
  inline int get_num_joints(AnimationContext* ctx) {
    return ctx ? static_cast<int>(ctx->models.size()) : 0;
  }

  // Get model matrix at index - returns pointer to 16 floats
  inline const float* get_model_matrix(AnimationContext* ctx, int index) {
    if (!ctx || index < 0 || index >= static_cast<int>(ctx->models.size())) {
      return nullptr;
    }
    return reinterpret_cast<const float*>(&ctx->models[index]);
  }

  // Get animation duration in seconds
  inline float get_animation_duration(ozz::animation::Animation* anim) {
    return anim ? anim->duration() : 0.0f;
  }

  // Get number of tracks (should match skeleton joints)
  inline int get_animation_num_tracks(ozz::animation::Animation* anim) {
    return anim ? anim->num_tracks() : 0;
  }

  // Get skeleton joint count
  inline int get_skeleton_num_joints(ozz::animation::Skeleton* skel) {
    return skel ? skel->num_joints() : 0;
  }

  inline int get_skeleton_num_soa_joints(ozz::animation::Skeleton* skel) {
    return skel ? skel->num_soa_joints() : 0;
  }

  // Set skeleton in context
  inline void set_context_skeleton(AnimationContext* ctx, ozz::animation::Skeleton* skel) {
    if (ctx) {
      ctx->skeleton = skel;
    }
  }

  // Add animation to context
  inline void add_context_animation(AnimationContext* ctx, ozz::animation::Animation* anim) {
    if (ctx && anim) {
      ctx->animations.push_back(anim);
    }
  }

  // Get animation from context
  inline ozz::animation::Animation* get_context_animation(AnimationContext* ctx, size_t index) {
    if (ctx && index < ctx->animations.size()) {
      return ctx->animations[index];
    }
    return nullptr;
  }

  // ============ MESH LOADING ============

  // Load meshes from .ozz file
  inline ozz::vector<ozz::sample::Mesh>* load_meshes_ozz(const char* path) {
    ozz::io::File file(path, \"rb\");
    if (!file.opened()) {
      return nullptr;
    }
    ozz::io::IArchive archive(&file);

    ozz::vector<ozz::sample::Mesh>* meshes = new ozz::vector<ozz::sample::Mesh>();
    while (archive.TestTag<ozz::sample::Mesh>()) {
      meshes->resize(meshes->size() + 1);
      archive >> meshes->back();
    }

    if (meshes->empty()) {
      delete meshes;
      return nullptr;
    }
    return meshes;
  }

  // Get mesh count
  inline int get_mesh_count(ozz::vector<ozz::sample::Mesh>* meshes) {
    return meshes ? static_cast<int>(meshes->size()) : 0;
  }

  // Get mesh vertex count for a specific mesh
  inline int get_mesh_vertex_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return (*meshes)[mesh_index].vertex_count();
  }

  // Get mesh triangle index count
  inline int get_mesh_index_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return (*meshes)[mesh_index].triangle_index_count();
  }

  // Get number of joint remaps (for skinning matrix count)
  inline int get_mesh_joint_remap_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return static_cast<int>((*meshes)[mesh_index].joint_remaps.size());
  }

  // Get highest joint index used by mesh
  inline int get_mesh_highest_joint(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return (*meshes)[mesh_index].highest_joint_index();
  }

  // Check if mesh is skinned
  inline bool is_mesh_skinned(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return false;
    }
    return (*meshes)[mesh_index].skinned();
  }

  // Get pointer to triangle indices
  inline const uint16_t* get_mesh_indices(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    return (*meshes)[mesh_index].triangle_indices.data();
  }

  // Get joint remaps for skinning matrix ordering
  inline const uint16_t* get_mesh_joint_remaps(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    return (*meshes)[mesh_index].joint_remaps.data();
  }

  // Get inverse bind poses for skinning
  inline const float* get_mesh_inverse_bind_poses(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    return reinterpret_cast<const float*>((*meshes)[mesh_index].inverse_bind_poses.data());
  }

  // Get mesh part count
  inline int get_mesh_part_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return static_cast<int>((*meshes)[mesh_index].parts.size());
  }

  // Get part vertex count
  inline int get_part_vertex_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return 0;
    }
    return mesh.parts[part_index].vertex_count();
  }

  // Get part positions pointer
  inline const float* get_part_positions(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].positions.data();
  }

  // Get part normals pointer
  inline const float* get_part_normals(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].normals.data();
  }

  // Get part UVs pointer
  inline const float* get_part_uvs(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].uvs.data();
  }

  // Get part joint indices pointer
  inline const uint16_t* get_part_joint_indices(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].joint_indices.data();
  }

  // Get part joint weights pointer
  inline const float* get_part_joint_weights(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].joint_weights.data();
  }

  // Get influences count (number of joints per vertex)
  inline int get_part_influences_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return 0;
    }
    return mesh.parts[part_index].influences_count();
  }

  // Compute skinning matrices from model matrices and mesh
  inline void compute_skinning_matrices(
    AnimationContext* ctx,
    ozz::vector<ozz::sample::Mesh>* meshes,
    int mesh_index,
    float* out_matrices  // Should have space for joint_remaps.size() * 16 floats
  ) {
    if (!ctx || !meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return;
    }
    const auto& mesh = (*meshes)[mesh_index];
    for (size_t i = 0; i < mesh.joint_remaps.size(); ++i) {
      ozz::math::Float4x4 skinning_matrix =
          ctx->models[mesh.joint_remaps[i]] * mesh.inverse_bind_poses[i];
      memcpy(out_matrices + i * 16, &skinning_matrix, sizeof(float) * 16);
    }
  }

  // compute_and_upload_skinning_matrices is defined in animation_types.h

  // ============ SKELETON DEBUG VISUALIZATION ============

  // Get joint parent indices from skeleton
  inline const int16_t* get_skeleton_joint_parents(ozz::animation::Skeleton* skel) {
    if (!skel) return nullptr;
    return skel->joint_parents().data();
  }

  // Get joint name by index
  inline const char* get_skeleton_joint_name(ozz::animation::Skeleton* skel, int index) {
    if (!skel || index < 0 || index >= skel->num_joints()) return nullptr;
    return skel->joint_names()[index];
  }

  // Get joint position from model matrix (translation column)
  inline void get_joint_position(AnimationContext* ctx, int index, float* out_xyz) {
    if (!ctx || index < 0 || index >= static_cast<int>(ctx->models.size())) {
      out_xyz[0] = out_xyz[1] = out_xyz[2] = 0.0f;
      return;
    }
    // ozz Float4x4 is column-major, translation is in column 3 (indices 12,13,14)
    const float* m = reinterpret_cast<const float*>(&ctx->models[index]);
    out_xyz[0] = m[12];
    out_xyz[1] = m[13];
    out_xyz[2] = m[14];
  }

  // Build skeleton line vertices for debug rendering
  // Returns number of lines (pairs of vertices) written
  // Each line is 2 vertices * 3 floats = 6 floats
  inline int build_skeleton_lines(AnimationContext* ctx, float* out_vertices, int max_lines) {
    if (!ctx || !ctx->skeleton) return 0;

    int num_joints = ctx->skeleton->num_joints();
    auto parents = ctx->skeleton->joint_parents();
    int line_count = 0;

    for (int i = 0; i < num_joints && line_count < max_lines; ++i) {
      int parent = parents[i];
      if (parent < 0) continue;  // Root has no parent
      if (parent == 0) continue;  // Skip bones connected to root (model_root) - avoids vertical line to origin

      float child_pos[3], parent_pos[3];
      get_joint_position(ctx, i, child_pos);
      get_joint_position(ctx, parent, parent_pos);

      // Write line segment (2 vertices)
      int offset = line_count * 6;
      out_vertices[offset + 0] = parent_pos[0];
      out_vertices[offset + 1] = parent_pos[1];
      out_vertices[offset + 2] = parent_pos[2];
      out_vertices[offset + 3] = child_pos[0];
      out_vertices[offset + 4] = child_pos[1];
      out_vertices[offset + 5] = child_pos[2];
      ++line_count;
    }
    return line_count;
  }

  // Build skeleton lines from REST POSE (bind pose) - no animation
  inline int build_skeleton_lines_rest_pose(AnimationContext* ctx, float* out_vertices, int max_lines) {
    if (!ctx || !ctx->skeleton) return 0;

    ozz::animation::Skeleton* skel = ctx->skeleton;
    int num_joints = skel->num_joints();
    int num_soa = skel->num_soa_joints();
    auto parents = skel->joint_parents();

    // Compute rest pose world positions
    std::vector<ozz::math::SoaTransform> rest_locals(num_soa);
    std::vector<ozz::math::Float4x4> rest_models(num_joints);

    for (int i = 0; i < num_soa; ++i) {
      rest_locals[i] = skel->joint_rest_poses()[i];
    }

    ozz::animation::LocalToModelJob ltm_job;
    ltm_job.skeleton = skel;
    ltm_job.input = ozz::make_span(rest_locals);
    ltm_job.output = ozz::make_span(rest_models);
    if (!ltm_job.Run()) return 0;

    // Build line segments
    int line_count = 0;
    for (int i = 0; i < num_joints && line_count < max_lines; ++i) {
      int parent = parents[i];
      if (parent < 0) continue;

      const ozz::math::Float4x4& child_m = rest_models[i];
      const ozz::math::Float4x4& parent_m = rest_models[parent];

      float cx = ozz::math::GetX(child_m.cols[3]);
      float cy = ozz::math::GetY(child_m.cols[3]);
      float cz = ozz::math::GetZ(child_m.cols[3]);
      float px = ozz::math::GetX(parent_m.cols[3]);
      float py = ozz::math::GetY(parent_m.cols[3]);
      float pz = ozz::math::GetZ(parent_m.cols[3]);

      int offset = line_count * 6;
      out_vertices[offset + 0] = px;
      out_vertices[offset + 1] = py;
      out_vertices[offset + 2] = pz;
      out_vertices[offset + 3] = cx;
      out_vertices[offset + 4] = cy;
      out_vertices[offset + 5] = cz;
      ++line_count;
    }
    return line_count;
  }

  // Build joint point vertices for debug rendering
  // Returns number of points written (3 floats each)
  inline int build_joint_points(AnimationContext* ctx, float* out_vertices, int max_points) {
    if (!ctx) return 0;
    int num_joints = static_cast<int>(ctx->models.size());
    int count = (num_joints < max_points) ? num_joints : max_points;

    for (int i = 0; i < count; ++i) {
      get_joint_position(ctx, i, out_vertices + i * 3);
    }
    return count;
  }

  // Get skeleton from context (for helper functions)
  inline ozz::animation::Skeleton* get_context_skeleton(AnimationContext* ctx) {
    return ctx ? ctx->skeleton : nullptr;
  }

  // Get skeleton joint count from context
  inline int get_context_num_joints(AnimationContext* ctx) {
    return ctx && ctx->skeleton ? ctx->skeleton->num_joints() : 0;
  }

  // Get joint name by index from context
  inline const char* get_context_joint_name(AnimationContext* ctx, int index) {
    static const char* empty = \"(none)\";
    if (!ctx || !ctx->skeleton) return empty;
    if (index < 0 || index >= ctx->skeleton->num_joints()) return empty;
    return ctx->skeleton->joint_names()[index];
  }

  // Debug: print first N joint positions
  inline void debug_print_joint_positions(AnimationContext* ctx, int count) {
    if (!ctx || !ctx->skeleton) {
      printf(\"DEBUG: No skeleton\\n\");
      return;
    }
    int n = std::min(count, static_cast<int>(ctx->models.size()));
    printf(\"DEBUG: First %d joint positions:\\n\", n);
    for (int i = 0; i < n; ++i) {
      float pos[3];
      get_joint_position(ctx, i, pos);
      const char* name = ctx->skeleton->joint_names()[i];
      printf(\"  [%d] '%s': (%.4f, %.4f, %.4f)\\n\", i, name, pos[0], pos[1], pos[2]);
    }
  }

  // Debug: print REST POSE (bind pose) positions - independent of animation
  inline void debug_print_rest_pose_positions(AnimationContext* ctx, int count) {
    if (!ctx || !ctx->skeleton) {
      printf(\"DEBUG REST POSE: No skeleton\\n\");
      return;
    }

    ozz::animation::Skeleton* skel = ctx->skeleton;
    int num_joints = skel->num_joints();
    int num_soa = skel->num_soa_joints();

    // Create temp buffers for rest pose computation
    std::vector<ozz::math::SoaTransform> rest_locals(num_soa);
    std::vector<ozz::math::Float4x4> rest_models(num_joints);

    // Copy rest poses
    for (int i = 0; i < num_soa; ++i) {
      rest_locals[i] = skel->joint_rest_poses()[i];
    }

    // Run LocalToModel to get world positions
    ozz::animation::LocalToModelJob ltm_job;
    ltm_job.skeleton = skel;
    ltm_job.input = ozz::make_span(rest_locals);
    ltm_job.output = ozz::make_span(rest_models);
    if (!ltm_job.Run()) {
      printf(\"DEBUG REST POSE: LocalToModelJob failed\\n\");
      return;
    }

    int n = std::min(count, num_joints);
    printf(\"DEBUG REST POSE: First %d joint positions (bind pose):\\n\", n);
    for (int i = 0; i < n; ++i) {
      const ozz::math::Float4x4& m = rest_models[i];
      float x = ozz::math::GetX(m.cols[3]);
      float y = ozz::math::GetY(m.cols[3]);
      float z = ozz::math::GetZ(m.cols[3]);
      const char* name = skel->joint_names()[i];
      printf(\"  [%d] '%s': (%.4f, %.4f, %.4f)\\n\", i, name, x, y, z);
    }
  }
  ")

;; Create a new animation context
(defn create-context
  "Creates an animation context for runtime animation"
  []
  (let [ctx (cpp/create_animation_context)]
    (cpp/box ctx)))

;; Load skeleton from file
(defn load-skeleton
  "Loads a skeleton from an .ozz file"
  [{:keys [path context]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        skeleton (cpp/load_skeleton_ozz path)]
    (when (cpp/! skeleton)
      (throw (ex-info "Failed to load skeleton" {:path path})))
    ;; Use helper function since cpp/= on member access doesn't work
    (do (cpp/set_context_skeleton ctx skeleton) nil)
    (let [num-joints (cpp/get_skeleton_num_joints skeleton)
          num-soa-joints (cpp/get_skeleton_num_soa_joints skeleton)
          _ (do (cpp/.init ctx num-soa-joints num-joints) nil)]
      {:num-joints num-joints
       :num-soa-joints num-soa-joints})))

;; Load animation from file
(defn load-animation
  "Loads an animation from an .ozz file, returns animation handle"
  [{:keys [path context]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        animation (cpp/load_animation_ozz path)]
    (when (cpp/! animation)
      (throw (ex-info "Failed to load animation" {:path path})))
    ;; Use helper function to add animation to context
    (do (cpp/add_context_animation ctx animation) nil)
    (let [animations (cpp/& (cpp/.-animations ctx))]
      {:index (cpp/- (cpp/.size animations) (cpp/size_t 1))
       :duration (cpp/get_animation_duration animation)
       :num-tracks (cpp/get_animation_num_tracks animation)})))

;; Sample animation at time
(defn sample
  "Samples animation at given time ratio (0.0-1.0), updates model matrices in context"
  [{:keys [context animation-index time-ratio]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        ;; Use helper function to get animation from context
        animation (cpp/get_context_animation ctx (cpp/size_t animation-index))]
    (cpp/sample_animation_ozz ctx animation (cpp/float time-ratio))))

;; Get model matrices for rendering
(defn get-model-matrices
  "Gets all model space matrices from context as a flat float array pointer"
  [{:keys [context]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        num-joints (cpp/get_num_joints ctx)]
    {:num-joints num-joints
     :matrices-ptr (when (cpp/> num-joints (cpp/int 0))
                     (cpp/box (cpp/get_model_matrix ctx (cpp/int 0))))}))

;; ============ MESH FUNCTIONS ============

;; Load meshes from file
(defn load-meshes
  "Loads meshes from an .ozz mesh file"
  [{:keys [path]}]
  (let [meshes (cpp/load_meshes_ozz path)]
    (when (cpp/! meshes)
      (throw (ex-info "Failed to load meshes" {:path path})))
    {:meshes (cpp/box meshes)
     :count (cpp/get_mesh_count meshes)}))

;; Get mesh info
(defn get-mesh-info
  "Gets information about a specific mesh"
  [{:keys [meshes mesh-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        idx (cpp/int mesh-index)]
    {:vertex-count (cpp/get_mesh_vertex_count meshes-ptr idx)
     :index-count (cpp/get_mesh_index_count meshes-ptr idx)
     :part-count (cpp/get_mesh_part_count meshes-ptr idx)
     :joint-remap-count (cpp/get_mesh_joint_remap_count meshes-ptr idx)
     :highest-joint (cpp/get_mesh_highest_joint meshes-ptr idx)
     :skinned? (cpp/is_mesh_skinned meshes-ptr idx)}))

;; Get mesh part info
(defn get-part-info
  "Gets information about a specific mesh part"
  [{:keys [meshes mesh-index part-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        mi (cpp/int mesh-index)
        pi (cpp/int part-index)]
    {:vertex-count (cpp/get_part_vertex_count meshes-ptr mi pi)
     :influences-count (cpp/get_part_influences_count meshes-ptr mi pi)}))

;; Get mesh indices pointer
(defn get-mesh-indices
  "Gets pointer to mesh triangle indices (uint16_t)"
  [{:keys [meshes mesh-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)]
    (cpp/box (cpp/get_mesh_indices meshes-ptr (cpp/int mesh-index)))))

;; Get part vertex data pointers
(defn get-part-vertex-data
  "Gets pointers to all vertex attribute data for a mesh part"
  [{:keys [meshes mesh-index part-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        mi (cpp/int mesh-index)
        pi (cpp/int part-index)]
    {:positions (cpp/box (cpp/get_part_positions meshes-ptr mi pi))
     :normals (cpp/box (cpp/get_part_normals meshes-ptr mi pi))
     :uvs (cpp/box (cpp/get_part_uvs meshes-ptr mi pi))
     :joint-indices (cpp/box (cpp/get_part_joint_indices meshes-ptr mi pi))
     :joint-weights (cpp/box (cpp/get_part_joint_weights meshes-ptr mi pi))}))

;; Compute skinning matrices
(defn compute-skinning-matrices
  "Computes skinning matrices from animation context and mesh.
   Returns pointer to matrix array (joint_remap_count * 16 floats)"
  [{:keys [context meshes mesh-index]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        joint-count (cpp/get_mesh_joint_remap_count meshes-ptr (cpp/int mesh-index))
        ;; Allocate buffer on heap so it survives function return
        buffer (cpp/new (cpp/type "std::vector<float>"))
        _ (do (cpp/.resize buffer (cpp/* joint-count (cpp/int 16))) nil)
        _ (do (cpp/compute_skinning_matrices ctx meshes-ptr (cpp/int mesh-index) (cpp/.data buffer)) nil)]
    {:joint-count joint-count
     :matrices (cpp/box buffer)}))

;; ============ SKELETON DEBUG VISUALIZATION ============

(defn get-skeleton-info
  "Gets skeleton information from context.
   Returns: {:num-joints n :joint-names [...]}"
  [{:keys [context]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        num-joints-cpp (cpp/get_context_num_joints ctx)
        num-joints (int num-joints-cpp)]
    (when (> num-joints 0)
      (let [names (loop [i 0 acc []]
                    (if (>= i num-joints)
                      acc
                      (recur (inc i)
                             (conj acc (str (cpp/get_context_joint_name ctx (cpp/int i)))))))]
        {:num-joints num-joints
         :joint-names names}))))

(defn build-skeleton-lines
  "Builds line vertices for skeleton debug visualization.
   Call after sampling animation. Returns {:line-count n :vertices float-buffer}"
  [{:keys [context max-lines]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        max-l (or max-lines 128)
        ;; Allocate buffer: 2 vertices per line * 3 floats per vertex = 6 floats per line
        buffer (cpp/new (cpp/type "std::vector<float>"))
        _ (do (cpp/.resize buffer (cpp/* (cpp/int max-l) (cpp/int 6))) nil)
        line-count (cpp/build_skeleton_lines ctx (cpp/.data buffer) (cpp/int max-l))]
    {:line-count line-count
     :vertices (cpp/box buffer)}))

(defn build-skeleton-lines-rest-pose
  "Builds line vertices for skeleton REST POSE (bind pose) visualization.
   No animation applied - shows the bind pose skeleton.
   Args: {:context ctx :max-lines 128}
   Returns: {:line-count n :vertices float-buffer}"
  [{:keys [context max-lines]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        max-l (or max-lines 128)
        buffer (cpp/new (cpp/type "std::vector<float>"))
        _ (do (cpp/.resize buffer (cpp/* (cpp/int max-l) (cpp/int 6))) nil)
        line-count (cpp/build_skeleton_lines_rest_pose ctx (cpp/.data buffer) (cpp/int max-l))]
    {:line-count line-count
     :vertices (cpp/box buffer)}))

(defn build-joint-points
  "Builds point vertices for joint debug visualization.
   Call after sampling animation. Returns {:point-count n :vertices float-buffer}"
  [{:keys [context max-points]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        max-p (or max-points 128)
        ;; Allocate buffer: 3 floats per point
        buffer (cpp/new (cpp/type "std::vector<float>"))
        _ (do (cpp/.resize buffer (cpp/* (cpp/int max-p) (cpp/int 3))) nil)
        point-count (cpp/build_joint_points ctx (cpp/.data buffer) (cpp/int max-p))]
    {:point-count point-count
     :vertices (cpp/box buffer)}))

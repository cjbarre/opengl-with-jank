(ns engine.gltf.core
  (:refer-clojure :exclude [load])
  (:require [engine.shaders.interface :as shaders]
            [engine.textures.interface :as textures]
            [engine.math.interface :as math]
            [engine.macros :refer [clet]]))

(cpp/raw
 "#define CGLTF_IMPLEMENTATION
  #include \"cgltf.h\"")

(defmulti parse-attribute (fn [attribute] (cpp/.-type (cpp/unbox cpp/cgltf_attribute* attribute))))

(defmethod parse-attribute cpp/cgltf_attribute_type_position
  [attribute]
  (let [attribute (cpp/unbox cpp/cgltf_attribute* attribute)
        accessor (cpp/* (cpp/.-data attribute))
        count (cpp/.-count accessor)
        accessor-box (cpp/box (cpp/& accessor))]
    {:positions
     (mapv (fn [i]
             (clet [accessor (cpp/unbox cpp/cgltf_accessor* accessor-box)
                    size (cpp/cgltf_num_components (cpp/.-type accessor))
                    v ((cpp/type "std::array<float, 3>"))
                    result (cpp/cgltf_accessor_read_float accessor (cpp/cgltf_size i) (cpp/.data v) size)
                    :when (cpp/! result)
                    :error (throw (ex-info "Could not parse position attribute" {}))]
                   [(cpp/aget v (cpp/int 0)) (cpp/aget v (cpp/int 1)) (cpp/aget v (cpp/int 2))]))
           (range count))}))

(defmethod parse-attribute cpp/cgltf_attribute_type_normal
  [attribute]
  (let [attribute (cpp/unbox cpp/cgltf_attribute* attribute)
        accessor (cpp/* (cpp/.-data attribute))
        count (cpp/.-count accessor)
        size (cpp/cgltf_num_components (cpp/.-type accessor))
        accessor-box (cpp/box (cpp/& accessor))]
    {:normals
     (mapv (fn [i]
             (clet [accessor (cpp/unbox cpp/cgltf_accessor* accessor-box)
                    v ((cpp/type "std::array<float, 3>"))
                    result (cpp/cgltf_accessor_read_float accessor (cpp/cgltf_size i) (cpp/.data v) size)
                    :when (cpp/! result)
                    :error (throw (ex-info "Could not parse normal attribute" {}))]
                   [(cpp/aget v (cpp/int 0)) (cpp/aget v (cpp/int 1)) (cpp/aget v (cpp/int 2))]))
           (range count))}))

(defmethod parse-attribute cpp/cgltf_attribute_type_texcoord
  [attribute]
  (let [attribute (cpp/unbox cpp/cgltf_attribute* attribute)
        accessor (cpp/* (cpp/.-data attribute))
        count (cpp/.-count accessor)
        size (cpp/cgltf_num_components (cpp/.-type accessor))
        accessor-box (cpp/box (cpp/& accessor))]
    {:uvs
     (mapv (fn [i]
             (clet [accessor (cpp/unbox cpp/cgltf_accessor* accessor-box)
                    v ((cpp/type "std::array<float, 2>"))
                    result (cpp/cgltf_accessor_read_float accessor (cpp/cgltf_size i) (cpp/.data v) size)
                    :when (cpp/! result)
                    :error (throw (ex-info "Could not parse uv attribute" {}))]
                   [(cpp/aget v (cpp/int 0)) (cpp/aget v (cpp/int 1))]))
           (range count))}))

(defmethod parse-attribute :default
  [attribute]
  (let [attribute (cpp/unbox cpp/cgltf_attribute* attribute)]
    {(cpp/.-type attribute) :not-implemented}))

(defn parse-indices
  [primitive]
  (let [primitive (cpp/unbox cpp/cgltf_primitive* primitive)
        accessor (cpp/* (cpp/.-indices primitive))
        count (cpp/.-count accessor)
        accessor-box (cpp/box (cpp/& accessor))]
    {:indices
     (mapv (fn [i]
             (clet [accessor (cpp/unbox cpp/cgltf_accessor* accessor-box)]
                   (cpp/cgltf_accessor_read_index accessor (cpp/cgltf_size i))))
           (range count))}))

(cpp/raw
 "bool cgltf_primitive_has_material(cgltf_primitive* prim) {
      return (prim->material != nullptr);
 }")

(defn parse-material
  [primitive]
  (let [primitive (cpp/unbox cpp/cgltf_primitive* primitive)]
    (when (cpp/cgltf_primitive_has_material primitive)
      (let [material (cpp/* (cpp/.-material primitive))]
        {:material (cond-> {}
                     (not= 0 (cpp/.-has_pbr_metallic_roughness material))
                     (assoc :pbr-metallic-roughness
                            (let [pbrmr (cpp/.-pbr_metallic_roughness material)
                                  bct (cpp/.-base_color_texture pbrmr)
                                  texture (cpp/* (cpp/.-texture bct))
                                  image (cpp/* (cpp/.-image texture))
                                  sampler (cpp/* (cpp/.-sampler texture))]
                              {:base-color-factor [1.0 1.0 1.0 1.0]
                               :base-color-texture
                               {:texcoord (cpp/.-texcoord bct)
                                :scale (cpp/.-scale bct)
                                :texture {:image
                                          {:name (str (cpp/.-name image))
                                           :uri (str (cpp/.-uri image))
                                           :mime-type (str (cpp/.-mime_type image))}
                                          :sampler {:mag-filter (cpp/.-mag_filter sampler)
                                                    :min-filter (cpp/.-min_filter sampler)
                                                    :wrap-s (cpp/.-wrap_s sampler)
                                                    :wrap-t (cpp/.-wrap_t sampler)}}}})))}))))

(defn parse-mesh [mesh]
  (let [mesh (cpp/unbox cpp/cgltf_mesh* mesh)
        primitives-box (cpp/box (cpp/.-primitives mesh))]
    {:name (str (cpp/.-name mesh))
     :primitives
     (vec
      (for [j (range (cpp/.-primitives_count mesh))
            :let [primitives     (cpp/unbox cpp/cgltf_primitive* primitives-box)
                  primitive      (cpp/aget primitives (cpp/int j))
                  attributes-box (cpp/box (cpp/.-attributes primitive))]]
        (let [attribute-data (reduce
                              (fn [acc k]
                                (let [attributes (cpp/unbox cpp/cgltf_attribute* attributes-box)
                                      attribute  (cpp/box (cpp/& (cpp/aget attributes (cpp/int k))))]
                                  (if-let [result (parse-attribute attribute)]
                                    (merge acc result)
                                    acc)))
                              {}
                              (range (cpp/.-attributes_count primitive)))
              indices-data (parse-indices (cpp/box (cpp/& primitive)))
              material-data (parse-material (cpp/box (cpp/& primitive)))]
          (merge attribute-data indices-data material-data))))}))

(cpp/raw
 "cgltf_float* get_node_translation (cgltf_node* node) {
  return node->translation;
  }")

(cpp/raw
 "cgltf_float* get_node_scale (cgltf_node* node) {
  return node->scale;
  }")

(defn parse-node
  [node]
  (clet [node (cpp/unbox cpp/cgltf_node* node)
         :when (cpp/> (cpp/.-children_count node) (cpp/int 0))
         :error (throw (ex-info "Parsing node children not implemented" {}))
         mesh (cpp/box (cpp/.-mesh node))]
        (cond-> {:name (str (cpp/.-name node))
                 :mesh (parse-mesh mesh)}
          (cpp/!= cpp/false (cpp/.-has_translation node))
          (assoc :translation
                 (let [translation (cpp/get_node_translation node)]
                   [(cpp/aget translation (cpp/int 0))
                    (cpp/aget translation (cpp/int 1))
                    (cpp/aget translation (cpp/int 2))]))

          (cpp/!= cpp/false (cpp/.-has_scale node))
          (assoc :scale
                 (let [scale (cpp/get_node_scale node)]
                   [(cpp/aget scale (cpp/int 0))
                    (cpp/aget scale (cpp/int 1))
                    (cpp/aget scale (cpp/int 2))]))

          (cpp/!= cpp/false (cpp/.-has_rotation node))
          (assoc :rotation (throw (ex-info "Node rotation not implemeted" {})))

          (cpp/!= cpp/false (cpp/.-has_matrix node))
          (assoc :matrix (throw (ex-info "Node matrix not implemeted" {}))))))

(defn parse-scene
  [scene]
  (let [scene (cpp/unbox cpp/cgltf_scene* scene)
        nodes (cpp/box (cpp/.-nodes scene))]
    {:name (str (cpp/.-name scene))
     :nodes (vec
             (for [node-i (range (cpp/.-nodes_count scene))
                   :let [nodes (cpp/unbox cpp/cgltf_node** nodes)
                         node (cpp/box (cpp/aget nodes (cpp/int node-i)))]]
               (parse-node node)))}))

(defn parse
  [{:keys [path] :as args}]
  (clet [options (cpp/cgltf_options)
         data (cpp/cgltf_data* cpp/nullptr)
         result (cpp/cgltf_parse_file (cpp/& options) path (cpp/& data))
         :when (cpp/!= result cpp/cgltf_result_success)
         :error (throw (ex-info "Could not parse GLTF file" (assoc args :error result)))
         result (cpp/cgltf_load_buffers (cpp/& options) data path)
         :when (cpp/!= result cpp/cgltf_result_success)
         :error (throw (ex-info "Cloud not load GLTF buffers" (assoc args :error result)))
         scenes (cpp/box (cpp/.-scenes data))]
        {:scenes
         (vec
          (for [scene-i (range (cpp/.-scenes_count data))
                :let [scenes (cpp/unbox cpp/cgltf_scene* scenes)
                      scene (cpp/box (cpp/& (cpp/aget scenes (cpp/int scene-i))))]]
            (parse-scene scene)))}))


(cpp/raw
 "struct Vertex {
    float pos[3];
    float norm[3];
    float uv[2];

    Vertex(float px, float py, float pz,
           float nx, float ny, float nz,
           float u, float v) {
        pos[0]=px; pos[1]=py; pos[2]=pz;
        norm[0]=nx; norm[1]=ny; norm[2]=nz;
        uv[0]=u; uv[1]=v;
    }

    Vertex() { // default ctor for array allocation
        pos[0]=pos[1]=pos[2]=0.0f;
        norm[0]=norm[1]=norm[2]=0.0f;
        uv[0]=uv[1]=0.0f;
    }
  };

  size_t int_size = sizeof(int);

  size_t vertex_size = sizeof(Vertex);")

(def GL_ARRAY_BUFFER (cpp/value "GL_ARRAY_BUFFER"))
(def GL_ELEMENT_ARRAY_BUFFER (cpp/value "GL_ELEMENT_ARRAY_BUFFER"))
(def GL_STATIC_DRAW (cpp/value "GL_STATIC_DRAW"))
(def GL_FLOAT (cpp/value "GL_FLOAT"))
(def GL_FALSE (cpp/value "GL_FALSE"))
(def GL_TRIANGLES (cpp/value "GL_TRIANGLES"))

(defn load
  [{:keys [model base-path]
    :or {base-path ""}}]
  (let [primitive-instances
        (for [scene (:scenes model)
              node (:nodes scene)
              :let [mesh (:mesh node)
                    [scale-x scale-y scale-z] (:scale node)
                    [translate-x translate-y translate-z] (:translation node)]
              {:keys [positions normals uvs material] :as primitive} (:primitives mesh)]
          (let [vertices ((cpp/type "std::vector<Vertex>"))
                vertices-box (cpp/box (cpp/& vertices))
                _ (doseq [i (range (count positions))]
                    (let [vertices* (cpp/unbox
                                     (cpp/type "std::vector<Vertex>*")
                                     vertices-box)
                          [px py pz] (get positions i)
                          [nx ny nz] (get normals i)
                          [u v] (get uvs i)]
                      (cpp/.push_back
                       vertices*
                       (cpp/Vertex
                        (cpp/float px)
                        (cpp/float py)
                        (cpp/float pz)
                        (cpp/float nx)
                        (cpp/float ny)
                        (cpp/float nz)
                        (cpp/float u)
                        (cpp/float v)))))

                indices ((cpp/type "std::vector<int>"))
                indices-box (cpp/box (cpp/& indices))
                _ (doseq [i (range (count (:indices primitive)))]
                    (let [indices* (cpp/unbox (cpp/type "std::vector<int>*") indices-box)
                          index (get (:indices primitive) i)]
                      (cpp/.push_back indices* (cpp/int index))))
                indices-size (cpp/.size indices)
                vao (shaders/create-vertex-array-object)
                _ (shaders/bind-vertex-array-object
                   {:vertex-array-object-id vao})

                ;;
                ;; VBO
                ;;
                vbo ((cpp/type "unsigned int"))
                _ (cpp/glGenBuffers (cpp/int 1) (cpp/& vbo))
                _ (cpp/glBindBuffer GL_ARRAY_BUFFER vbo)
                _ (cpp/glBufferData GL_ARRAY_BUFFER
                                    (cpp/* (cpp/.size vertices) cpp/vertex_size)
                                    (cpp/cast (cpp/type "void*")
                                              (cpp/.data vertices))
                                    GL_STATIC_DRAW)

                ;;
                ;; EBO
                ;;
                ebo ((cpp/type "unsigned int"))
                _ (cpp/glGenBuffers (cpp/int 1) (cpp/& ebo))
                _ (cpp/glBindBuffer GL_ELEMENT_ARRAY_BUFFER ebo)
                _ (cpp/glBufferData GL_ELEMENT_ARRAY_BUFFER
                                    (cpp/* indices-size cpp/int_size)
                                    (cpp/cast (cpp/type "void*")
                                              (cpp/.data indices))
                                    GL_STATIC_DRAW)

                ;;
                ;; Vertex Attributes
                ;;
                _ (cpp/glVertexAttribPointer 0
                                             3
                                             GL_FLOAT
                                             GL_FALSE
                                             cpp/vertex_size
                                             (cpp/voidify_int 0))
                _ (cpp/glEnableVertexAttribArray 0)

                _ (cpp/glVertexAttribPointer 1
                                             3
                                             GL_FLOAT
                                             GL_FALSE
                                             cpp/vertex_size
                                             (cpp/voidify_int (cpp/* (cpp/int 3) cpp/float_size)))
                _ (cpp/glEnableVertexAttribArray 1)

                _ (cpp/glVertexAttribPointer 2
                                             2
                                             GL_FLOAT
                                             GL_FALSE
                                             cpp/vertex_size
                                             (cpp/voidify_int (cpp/* (cpp/int 6) cpp/float_size)))
                _ (cpp/glEnableVertexAttribArray 2)
                texture (-> material
                            :pbr-metallic-roughness
                            :base-color-texture
                            :texture)
                [r g b a] (-> material
                              :pbr-metallic-roughness
                              :base-color-factor)
                texture-id (when texture
                             (textures/load-texture
                              (merge {:path (str base-path (-> texture :image :uri))}
                                     (:sampler texture))))]

            {:draw
             (fn draw-primitive [{model-m-loc :model/local-matrix-uniform
                                  :keys [shader] :as _context}]
               (let [local-model-m (-> (cpp/identity_matrix)
                                       (cpp/glm.scale (math/gimmie :vec3 [(or scale-x 1.0) (or scale-y 1.0) (or scale-z 1.0)]))
                                       (cpp/glm.translate (math/gimmie :vec3 [(or translate-x 0.0) (or translate-y 0.0) (or translate-z 0.0)])))
                     _ (shaders/bind-vertex-array-object
                        {:vertex-array-object-id vao})
                     _ (when texture-id
                         (cpp/glActiveTexture (cpp/value "GL_TEXTURE0"))
                         (cpp/glBindTexture (cpp/value "GL_TEXTURE_2D") texture-id)
                         (cpp/glUniform1i (cpp/glGetUniformLocation shader "uHasBaseColorTex") 1)
                         (cpp/glUniform4f (cpp/glGetUniformLocation shader "uBaseColorFactor") r g b a))
                     _ (cpp/glUniformMatrix4fv (cpp/glGetUniformLocation shader model-m-loc) 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr local-model-m))
                     _ (cpp/glDrawElements
                        GL_TRIANGLES
                        (count (:indices primitive))
                        (cpp/value "GL_UNSIGNED_INT")
                        (cpp/voidify_int (cpp/int 0)))
                     _ (when texture-id
                         (cpp/glActiveTexture (cpp/value "GL_TEXTURE0"))
                         (cpp/glBindTexture (cpp/value "GL_TEXTURE_2D") 0))]))}))]

    {:draw
     (fn draw-model [context]
       (doseq [pi primitive-instances]
         ((:draw pi) context)))}))

(ns engine.3d.animation.core
  (:require [engine.macros :refer [clet]]))

;; Include ozz-animation headers and define C++ helper structures
(cpp/raw
 "#ifdef __APPLE__
  #include <OpenGL/gl3.h>
  #else
  #include <GL/glew.h>
  #endif
  #include <iostream>
  #include \"ozz/animation/runtime/animation.h\"
  #include \"ozz/animation/runtime/skeleton.h\"
  #include \"ozz/animation/runtime/sampling_job.h\"
  #include \"ozz/animation/runtime/local_to_model_job.h\"
  #include \"ozz/base/io/archive.h\"
  #include \"ozz/base/io/stream.h\"
  #include \"ozz/base/maths/soa_transform.h\"
  #include \"ozz/base/maths/simd_math.h\"
  #include \"ozz/base/maths/math_archive.h\"
  #include \"ozz/base/maths/simd_math_archive.h\"
  #include \"ozz/base/containers/vector.h\"
  #include \"ozz/base/containers/vector_archive.h\"
  #include \"ozz_mesh.h\"

  #include <fstream>
  #include <cstring>

  // Mesh archive implementation (from ozz samples framework)
  namespace ozz {
  namespace io {

  void Extern<sample::Mesh::Part>::Save(OArchive& _archive,
                                        const sample::Mesh::Part* _parts,
                                        size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const sample::Mesh::Part& part = _parts[i];
      _archive << part.positions;
      _archive << part.normals;
      _archive << part.tangents;
      _archive << part.uvs;
      _archive << part.colors;
      _archive << part.joint_indices;
      _archive << part.joint_weights;
    }
  }

  void Extern<sample::Mesh::Part>::Load(IArchive& _archive,
                                        sample::Mesh::Part* _parts, size_t _count,
                                        uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      sample::Mesh::Part& part = _parts[i];
      _archive >> part.positions;
      _archive >> part.normals;
      _archive >> part.tangents;
      _archive >> part.uvs;
      _archive >> part.colors;
      _archive >> part.joint_indices;
      _archive >> part.joint_weights;
    }
  }

  void Extern<sample::Mesh>::Save(OArchive& _archive, const sample::Mesh* _meshes,
                                  size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const sample::Mesh& mesh = _meshes[i];
      _archive << mesh.parts;
      _archive << mesh.triangle_indices;
      _archive << mesh.joint_remaps;
      _archive << mesh.inverse_bind_poses;
    }
  }

  void Extern<sample::Mesh>::Load(IArchive& _archive, sample::Mesh* _meshes,
                                  size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      sample::Mesh& mesh = _meshes[i];
      _archive >> mesh.parts;
      _archive >> mesh.triangle_indices;
      _archive >> mesh.joint_remaps;
      _archive >> mesh.inverse_bind_poses;
    }
  }
  }  // namespace io
  }  // namespace ozz

  // Animation context holds all runtime buffers needed for animation
  struct AnimationContext {
    ozz::animation::Skeleton* skeleton;
    ozz::vector<ozz::animation::Animation*> animations;

    // Runtime buffers
    ozz::vector<ozz::math::SoaTransform> locals;  // Local space transforms
    ozz::vector<ozz::math::Float4x4> models;       // Model space matrices
    ozz::animation::SamplingJob::Context context;  // Sampling context

    AnimationContext() : skeleton(nullptr) {}

    ~AnimationContext() {
      delete skeleton;
      for (auto* anim : animations) {
        delete anim;
      }
    }

    bool init(int num_soa_joints, int num_joints) {
      locals.resize(num_soa_joints);
      models.resize(num_joints);
      context.Resize(num_joints);
      return true;
    }
  };

  // Load skeleton from .ozz file
  ozz::animation::Skeleton* load_skeleton_ozz(const char* path) {
    ozz::io::File file(path, \"rb\");
    if (!file.opened()) {
      return nullptr;
    }
    ozz::io::IArchive archive(&file);
    if (!archive.TestTag<ozz::animation::Skeleton>()) {
      return nullptr;
    }
    ozz::animation::Skeleton* skeleton = new ozz::animation::Skeleton();
    archive >> *skeleton;
    return skeleton;
  }

  // Load animation from .ozz file
  ozz::animation::Animation* load_animation_ozz(const char* path) {
    ozz::io::File file(path, \"rb\");
    if (!file.opened()) {
      return nullptr;
    }
    ozz::io::IArchive archive(&file);
    if (!archive.TestTag<ozz::animation::Animation>()) {
      return nullptr;
    }
    ozz::animation::Animation* animation = new ozz::animation::Animation();
    archive >> *animation;
    return animation;
  }

  // Sample animation at a given time ratio (0.0 to 1.0)
  bool sample_animation_ozz(AnimationContext* ctx, ozz::animation::Animation* anim, float time_ratio) {
    if (!ctx || !anim || !ctx->skeleton) {
      return false;
    }

    // Sample animation
    ozz::animation::SamplingJob sampling_job;
    sampling_job.animation = anim;
    sampling_job.context = &ctx->context;
    sampling_job.ratio = time_ratio;
    sampling_job.output = ozz::make_span(ctx->locals);
    if (!sampling_job.Run()) {
      return false;
    }

    // Convert to model space
    ozz::animation::LocalToModelJob ltm_job;
    ltm_job.skeleton = ctx->skeleton;
    ltm_job.input = ozz::make_span(ctx->locals);
    ltm_job.output = ozz::make_span(ctx->models);
    if (!ltm_job.Run()) {
      return false;
    }

    return true;
  }

  // Get number of model matrices
  int get_num_joints(AnimationContext* ctx) {
    return ctx ? static_cast<int>(ctx->models.size()) : 0;
  }

  // Get model matrix at index - returns pointer to 16 floats
  const float* get_model_matrix(AnimationContext* ctx, int index) {
    if (!ctx || index < 0 || index >= static_cast<int>(ctx->models.size())) {
      return nullptr;
    }
    return reinterpret_cast<const float*>(&ctx->models[index]);
  }

  // Get animation duration in seconds
  float get_animation_duration(ozz::animation::Animation* anim) {
    return anim ? anim->duration() : 0.0f;
  }

  // Get number of tracks (should match skeleton joints)
  int get_animation_num_tracks(ozz::animation::Animation* anim) {
    return anim ? anim->num_tracks() : 0;
  }

  // Get skeleton joint count
  int get_skeleton_num_joints(ozz::animation::Skeleton* skel) {
    return skel ? skel->num_joints() : 0;
  }

  int get_skeleton_num_soa_joints(ozz::animation::Skeleton* skel) {
    return skel ? skel->num_soa_joints() : 0;
  }

  // Set skeleton in context
  void set_context_skeleton(AnimationContext* ctx, ozz::animation::Skeleton* skel) {
    if (ctx) {
      ctx->skeleton = skel;
    }
  }

  // Add animation to context
  void add_context_animation(AnimationContext* ctx, ozz::animation::Animation* anim) {
    if (ctx && anim) {
      ctx->animations.push_back(anim);
    }
  }

  // Get animation from context
  ozz::animation::Animation* get_context_animation(AnimationContext* ctx, size_t index) {
    if (ctx && index < ctx->animations.size()) {
      return ctx->animations[index];
    }
    return nullptr;
  }

  // ============ MESH LOADING ============

  // Load meshes from .ozz file
  ozz::vector<ozz::sample::Mesh>* load_meshes_ozz(const char* path) {
    ozz::io::File file(path, \"rb\");
    if (!file.opened()) {
      return nullptr;
    }
    ozz::io::IArchive archive(&file);

    ozz::vector<ozz::sample::Mesh>* meshes = new ozz::vector<ozz::sample::Mesh>();
    while (archive.TestTag<ozz::sample::Mesh>()) {
      meshes->resize(meshes->size() + 1);
      archive >> meshes->back();
    }

    if (meshes->empty()) {
      delete meshes;
      return nullptr;
    }
    return meshes;
  }

  // Get mesh count
  int get_mesh_count(ozz::vector<ozz::sample::Mesh>* meshes) {
    return meshes ? static_cast<int>(meshes->size()) : 0;
  }

  // Get mesh vertex count for a specific mesh
  int get_mesh_vertex_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return (*meshes)[mesh_index].vertex_count();
  }

  // Get mesh triangle index count
  int get_mesh_index_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return (*meshes)[mesh_index].triangle_index_count();
  }

  // Get number of joint remaps (for skinning matrix count)
  int get_mesh_joint_remap_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return static_cast<int>((*meshes)[mesh_index].joint_remaps.size());
  }

  // Get highest joint index used by mesh
  int get_mesh_highest_joint(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return (*meshes)[mesh_index].highest_joint_index();
  }

  // Check if mesh is skinned
  bool is_mesh_skinned(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return false;
    }
    return (*meshes)[mesh_index].skinned();
  }

  // Get pointer to triangle indices
  const uint16_t* get_mesh_indices(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    return (*meshes)[mesh_index].triangle_indices.data();
  }

  // Get joint remaps for skinning matrix ordering
  const uint16_t* get_mesh_joint_remaps(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    return (*meshes)[mesh_index].joint_remaps.data();
  }

  // Get inverse bind poses for skinning
  const float* get_mesh_inverse_bind_poses(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    return reinterpret_cast<const float*>((*meshes)[mesh_index].inverse_bind_poses.data());
  }

  // Get mesh part count
  int get_mesh_part_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    return static_cast<int>((*meshes)[mesh_index].parts.size());
  }

  // Get part vertex count
  int get_part_vertex_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return 0;
    }
    return mesh.parts[part_index].vertex_count();
  }

  // Get part positions pointer
  const float* get_part_positions(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].positions.data();
  }

  // Get part normals pointer
  const float* get_part_normals(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].normals.data();
  }

  // Get part UVs pointer
  const float* get_part_uvs(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].uvs.data();
  }

  // Get part joint indices pointer
  const uint16_t* get_part_joint_indices(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].joint_indices.data();
  }

  // Get part joint weights pointer
  const float* get_part_joint_weights(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return nullptr;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return nullptr;
    }
    return mesh.parts[part_index].joint_weights.data();
  }

  // Get influences count (number of joints per vertex)
  int get_part_influences_count(ozz::vector<ozz::sample::Mesh>* meshes, int mesh_index, int part_index) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    const auto& mesh = (*meshes)[mesh_index];
    if (part_index < 0 || part_index >= static_cast<int>(mesh.parts.size())) {
      return 0;
    }
    return mesh.parts[part_index].influences_count();
  }

  // Compute skinning matrices from model matrices and mesh
  void compute_skinning_matrices(
    AnimationContext* ctx,
    ozz::vector<ozz::sample::Mesh>* meshes,
    int mesh_index,
    float* out_matrices  // Should have space for joint_remaps.size() * 16 floats
  ) {
    if (!ctx || !meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return;
    }
    const auto& mesh = (*meshes)[mesh_index];
    for (size_t i = 0; i < mesh.joint_remaps.size(); ++i) {
      ozz::math::Float4x4 skinning_matrix =
          ctx->models[mesh.joint_remaps[i]] * mesh.inverse_bind_poses[i];
      memcpy(out_matrices + i * 16, &skinning_matrix, sizeof(float) * 16);
    }
  }

  // Compute and upload skinning matrices directly to shader
  void compute_and_upload_skinning_matrices(
    AnimationContext* ctx,
    ozz::vector<ozz::sample::Mesh>* meshes,
    int mesh_index,
    GLint uniform_location
  ) {
    if (!ctx || !meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return;
    }
    const auto& mesh = (*meshes)[mesh_index];
    size_t joint_count = mesh.joint_remaps.size();

    // Allocate temp buffer
    std::vector<float> matrices(joint_count * 16);

    for (size_t i = 0; i < joint_count; ++i) {
      ozz::math::Float4x4 skinning_matrix =
          ctx->models[mesh.joint_remaps[i]] * mesh.inverse_bind_poses[i];
      // Float4x4 has 4 SimdFloat4 columns - need to store each column properly
      float* out = matrices.data() + i * 16;
      ozz::math::StorePtrU(skinning_matrix.cols[0], out + 0);
      ozz::math::StorePtrU(skinning_matrix.cols[1], out + 4);
      ozz::math::StorePtrU(skinning_matrix.cols[2], out + 8);
      ozz::math::StorePtrU(skinning_matrix.cols[3], out + 12);
    }

    glUniformMatrix4fv(uniform_location, static_cast<GLsizei>(joint_count), GL_FALSE, matrices.data());
  }
  ")

;; Create a new animation context
(defn create-context
  "Creates an animation context for runtime animation"
  []
  (let [ctx (cpp/new cpp/AnimationContext)]
    (cpp/box ctx)))

;; Load skeleton from file
(defn load-skeleton
  "Loads a skeleton from an .ozz file"
  [{:keys [path context]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        skeleton (cpp/load_skeleton_ozz path)]
    (when (cpp/! skeleton)
      (throw (ex-info "Failed to load skeleton" {:path path})))
    ;; Use helper function since cpp/= on member access doesn't work
    (cpp/set_context_skeleton ctx skeleton)
    (let [num-joints (cpp/get_skeleton_num_joints skeleton)
          num-soa-joints (cpp/get_skeleton_num_soa_joints skeleton)]
      (cpp/.init ctx num-soa-joints num-joints)
      {:num-joints num-joints
       :num-soa-joints num-soa-joints})))

;; Load animation from file
(defn load-animation
  "Loads an animation from an .ozz file, returns animation handle"
  [{:keys [path context]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        animation (cpp/load_animation_ozz path)]
    (when (cpp/! animation)
      (throw (ex-info "Failed to load animation" {:path path})))
    ;; Use helper function to add animation to context
    (cpp/add_context_animation ctx animation)
    (let [animations (cpp/& (cpp/.-animations ctx))]
      {:index (cpp/- (cpp/.size animations) (cpp/size_t 1))
       :duration (cpp/get_animation_duration animation)
       :num-tracks (cpp/get_animation_num_tracks animation)})))

;; Sample animation at time
(defn sample
  "Samples animation at given time ratio (0.0-1.0), updates model matrices in context"
  [{:keys [context animation-index time-ratio]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        ;; Use helper function to get animation from context
        animation (cpp/get_context_animation ctx (cpp/size_t animation-index))]
    (cpp/sample_animation_ozz ctx animation (cpp/float time-ratio))))

;; Get model matrices for rendering
(defn get-model-matrices
  "Gets all model space matrices from context as a flat float array pointer"
  [{:keys [context]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        num-joints (cpp/get_num_joints ctx)]
    {:num-joints num-joints
     :matrices-ptr (when (cpp/> num-joints (cpp/int 0))
                     (cpp/box (cpp/get_model_matrix ctx (cpp/int 0))))}))

;; ============ MESH FUNCTIONS ============

;; Load meshes from file
(defn load-meshes
  "Loads meshes from an .ozz mesh file"
  [{:keys [path]}]
  (let [meshes (cpp/load_meshes_ozz path)]
    (when (cpp/! meshes)
      (throw (ex-info "Failed to load meshes" {:path path})))
    {:meshes (cpp/box meshes)
     :count (cpp/get_mesh_count meshes)}))

;; Get mesh info
(defn get-mesh-info
  "Gets information about a specific mesh"
  [{:keys [meshes mesh-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        idx (cpp/int mesh-index)]
    {:vertex-count (cpp/get_mesh_vertex_count meshes-ptr idx)
     :index-count (cpp/get_mesh_index_count meshes-ptr idx)
     :part-count (cpp/get_mesh_part_count meshes-ptr idx)
     :joint-remap-count (cpp/get_mesh_joint_remap_count meshes-ptr idx)
     :highest-joint (cpp/get_mesh_highest_joint meshes-ptr idx)
     :skinned? (cpp/is_mesh_skinned meshes-ptr idx)}))

;; Get mesh part info
(defn get-part-info
  "Gets information about a specific mesh part"
  [{:keys [meshes mesh-index part-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        mi (cpp/int mesh-index)
        pi (cpp/int part-index)]
    {:vertex-count (cpp/get_part_vertex_count meshes-ptr mi pi)
     :influences-count (cpp/get_part_influences_count meshes-ptr mi pi)}))

;; Get mesh indices pointer
(defn get-mesh-indices
  "Gets pointer to mesh triangle indices (uint16_t)"
  [{:keys [meshes mesh-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)]
    (cpp/box (cpp/get_mesh_indices meshes-ptr (cpp/int mesh-index)))))

;; Get part vertex data pointers
(defn get-part-vertex-data
  "Gets pointers to all vertex attribute data for a mesh part"
  [{:keys [meshes mesh-index part-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        mi (cpp/int mesh-index)
        pi (cpp/int part-index)]
    {:positions (cpp/box (cpp/get_part_positions meshes-ptr mi pi))
     :normals (cpp/box (cpp/get_part_normals meshes-ptr mi pi))
     :uvs (cpp/box (cpp/get_part_uvs meshes-ptr mi pi))
     :joint-indices (cpp/box (cpp/get_part_joint_indices meshes-ptr mi pi))
     :joint-weights (cpp/box (cpp/get_part_joint_weights meshes-ptr mi pi))}))

;; Compute skinning matrices
(defn compute-skinning-matrices
  "Computes skinning matrices from animation context and mesh.
   Returns pointer to matrix array (joint_remap_count * 16 floats)"
  [{:keys [context meshes mesh-index]}]
  (let [ctx (cpp/unbox cpp/AnimationContext* context)
        meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        joint-count (cpp/get_mesh_joint_remap_count meshes-ptr (cpp/int mesh-index))
        ;; Allocate buffer on heap so it survives function return
        buffer (cpp/new (cpp/type "std::vector<float>"))]
    (cpp/.resize buffer (cpp/* joint-count (cpp/int 16)))
    (cpp/compute_skinning_matrices ctx meshes-ptr (cpp/int mesh-index) (cpp/.data buffer))
    {:joint-count joint-count
     :matrices (cpp/box buffer)}))

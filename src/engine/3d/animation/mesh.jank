(ns engine.3d.animation.mesh
  "Creates OpenGL buffers from ozz mesh data for GPU skinning"
  (:require [engine.shaders.interface :as shaders]
            [engine.3d.animation.core :as core]
            [engine.gl.constants :as gl]))

(cpp/raw
 "#include <cstring>
  #include <vector>
  #include \"gl_wrappers.h\"
  #include \"ozz/base/containers/vector.h\"
  #include \"ozz_mesh.h\"

  // Skinned vertex layout matching skinned_vertex.glsl
  // Total stride: 48 bytes
  struct SkinnedVertex {
    float pos[3];       // 12 bytes, offset 0
    float norm[3];      // 12 bytes, offset 12
    float uv[2];        // 8 bytes,  offset 24
    uint16_t joints[4]; // 8 bytes,  offset 32
    float weights[4];   // 16 bytes, offset 40
  };

  // Build interleaved vertex buffer from ozz mesh parts
  // Returns vertex count, fills output buffer
  inline int build_skinned_vertices(
    ozz::vector<ozz::sample::Mesh>* meshes,
    int mesh_index,
    std::vector<SkinnedVertex>& out_vertices
  ) {
    if (!meshes || mesh_index < 0 || mesh_index >= static_cast<int>(meshes->size())) {
      return 0;
    }
    const auto& mesh = (*meshes)[mesh_index];

    // Count total vertices across all parts
    int total_verts = mesh.vertex_count();
    out_vertices.resize(total_verts);

    int vertex_offset = 0;
    for (size_t pi = 0; pi < mesh.parts.size(); ++pi) {
      const auto& part = mesh.parts[pi];
      int part_verts = part.vertex_count();
      int influences = part.influences_count();

      for (int vi = 0; vi < part_verts; ++vi) {
        SkinnedVertex& v = out_vertices[vertex_offset + vi];

        // Position (3 floats per vertex)
        v.pos[0] = part.positions[vi * 3 + 0];
        v.pos[1] = part.positions[vi * 3 + 1];
        v.pos[2] = part.positions[vi * 3 + 2];

        // Normal (3 floats per vertex)
        if (!part.normals.empty()) {
          v.norm[0] = part.normals[vi * 3 + 0];
          v.norm[1] = part.normals[vi * 3 + 1];
          v.norm[2] = part.normals[vi * 3 + 2];
        } else {
          v.norm[0] = 0.0f; v.norm[1] = 1.0f; v.norm[2] = 0.0f;
        }

        // UV (2 floats per vertex)
        if (!part.uvs.empty()) {
          v.uv[0] = part.uvs[vi * 2 + 0];
          v.uv[1] = part.uvs[vi * 2 + 1];
        } else {
          v.uv[0] = 0.0f; v.uv[1] = 0.0f;
        }

        // Joint indices (influences per vertex, pad to 4)
        for (int i = 0; i < 4; ++i) {
          if (i < influences && !part.joint_indices.empty()) {
            v.joints[i] = part.joint_indices[vi * influences + i];
          } else {
            v.joints[i] = 0;
          }
        }

        // Joint weights (influences-1 per vertex because last is implicit, pad to 4)
        // ozz stores N-1 weights, last weight = 1 - sum(others)
        float weight_sum = 0.0f;
        for (int i = 0; i < 4; ++i) {
          if (i < influences - 1 && !part.joint_weights.empty()) {
            v.weights[i] = part.joint_weights[vi * (influences - 1) + i];
            weight_sum += v.weights[i];
          } else if (i == influences - 1 && influences > 0) {
            // Last weight is implicit
            v.weights[i] = 1.0f - weight_sum;
          } else {
            v.weights[i] = 0.0f;
          }
        }
      }
      vertex_offset += part_verts;
    }
    return total_verts;
  }
  ")

;; Using centralized GL constants from engine.gl.constants

(cpp/raw
 "inline void* int_to_ptr(size_t offset) {
    return reinterpret_cast<void*>(offset);
  }

  inline size_t skinned_vertex_size() {
    return sizeof(SkinnedVertex);
  }

  // Wrapper for glVertexAttribIPointer (integer attributes)
  inline void set_vertex_attrib_i_pointer(GLuint index, GLint size, GLenum type, GLsizei stride, size_t offset) {
    glVertexAttribIPointer(index, size, type, stride, reinterpret_cast<void*>(offset));
  }
  ")

(defn create-skinned-vao
  "Creates VAO/VBO/EBO from ozz mesh data for GPU skinning.
   Args: {:meshes boxed-meshes-ptr :mesh-index n}
   Returns: {:vao id :index-count n}"
  [{:keys [meshes mesh-index]}]
  (let [meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)
        mi (cpp/int mesh-index)

        ;; Build interleaved vertex buffer
        vertices ((cpp/type "std::vector<SkinnedVertex>"))
        vertex-count (cpp/build_skinned_vertices meshes-ptr mi vertices)

        ;; Get index data
        index-count (cpp/get_mesh_index_count meshes-ptr mi)
        indices-ptr (cpp/get_mesh_indices meshes-ptr mi)

        ;; Create VAO
        vao (shaders/create-vertex-array-object)
        _ (shaders/bind-vertex-array-object {:vertex-array-object-id vao})

        ;; Create and fill VBO
        vbo ((cpp/type "unsigned int"))
        _ (cpp/wrap_glGenBuffers (cpp/int 1) (cpp/& vbo))
        _ (cpp/wrap_glBindBuffer gl/GL_ARRAY_BUFFER vbo)
        vbo-size (cpp/* (cpp/skinned_vertex_size) (cpp/.size vertices))
        _ (cpp/wrap_glBufferData gl/GL_ARRAY_BUFFER
                            vbo-size
                            (cpp/cast (cpp/type "const void*") (cpp/.data vertices))
                            gl/GL_STATIC_DRAW)

        ;; Create and fill EBO
        ebo ((cpp/type "unsigned int"))
        _ (cpp/wrap_glGenBuffers (cpp/int 1) (cpp/& ebo))
        _ (cpp/wrap_glBindBuffer gl/GL_ELEMENT_ARRAY_BUFFER ebo)
        ebo-size (cpp/* (cpp/int 2) index-count) ;; sizeof(uint16_t) = 2
        _ (cpp/wrap_glBufferData gl/GL_ELEMENT_ARRAY_BUFFER
                            ebo-size
                            (cpp/cast (cpp/type "const void*") indices-ptr)
                            gl/GL_STATIC_DRAW)

        ;; Vertex stride = sizeof(SkinnedVertex) = 48
        stride (cpp/skinned_vertex_size)

        ;; location 0: position (3 floats at offset 0)
        _ (cpp/wrap_glVertexAttribPointer (cpp/int 0) (cpp/int 3) gl/GL_FLOAT gl/GL_FALSE stride (cpp/int_to_ptr 0))
        _ (cpp/wrap_glEnableVertexAttribArray (cpp/int 0))

        ;; location 1: normal (3 floats at offset 12)
        _ (cpp/wrap_glVertexAttribPointer (cpp/int 1) (cpp/int 3) gl/GL_FLOAT gl/GL_FALSE stride (cpp/int_to_ptr 12))
        _ (cpp/wrap_glEnableVertexAttribArray (cpp/int 1))

        ;; location 2: texcoord (2 floats at offset 24)
        _ (cpp/wrap_glVertexAttribPointer (cpp/int 2) (cpp/int 2) gl/GL_FLOAT gl/GL_FALSE stride (cpp/int_to_ptr 24))
        _ (cpp/wrap_glEnableVertexAttribArray (cpp/int 2))

        ;; location 3: joints (4 uint16 at offset 32) - use integer attribute
        _ (cpp/set_vertex_attrib_i_pointer (cpp/int 3) (cpp/int 4) gl/GL_UNSIGNED_SHORT stride (cpp/int 32))
        _ (cpp/wrap_glEnableVertexAttribArray (cpp/int 3))

        ;; location 4: weights (4 floats at offset 40)
        _ (cpp/wrap_glVertexAttribPointer (cpp/int 4) (cpp/int 4) gl/GL_FLOAT gl/GL_FALSE stride (cpp/int_to_ptr 40))
        _ (cpp/wrap_glEnableVertexAttribArray (cpp/int 4))

        ;; Unbind VAO
        _ (cpp/wrap_glBindVertexArray (cpp/int 0))]

    {:vao vao
     :vbo vbo
     :ebo ebo
     :index-count index-count
     :vertex-count vertex-count}))

(ns app.core
  (:require [app.io.interface :as io]
            [app.shaders.interface :as shaders]
            [app.geometry.interface :as geometry]
            [app.textures.interface :as textures]
            [app.math.interface :as math]
            [app.gltf.interface :as gltf]))

(cpp/raw "#include <GLFW/glfw3.h>")

(cpp/raw "#include <glm/glm.hpp> 
          #include <glm/gtc/matrix_transform.hpp> 
          #include <glm/gtc/type_ptr.hpp>")

(cpp/raw "#include <math.h>")

(cpp/raw
 "void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

(cpp/raw
 "glm::mat4 identity_matrix () {
    return glm::mat4(1.0f);
  }")

(def GLFW_PRESS (cpp/value "GLFW_PRESS"))
(def GLFW_KEY_ESCAPE (cpp/value "GLFW_KEY_ESCAPE"))
(def GLFW_KEY_W (cpp/value "GLFW_KEY_W"))
(def GLFW_KEY_S (cpp/value "GLFW_KEY_S"))
(def GLFW_KEY_A (cpp/value "GLFW_KEY_A"))
(def GLFW_KEY_D (cpp/value "GLFW_KEY_D"))

(defn process-input
  [{{:keys [position front up]} :camera
    :keys [window delta-time]}]
  (let [camera-speed (cpp/* (cpp/float 2.5) (math/*-> :float delta-time))
        window (cpp/unbox cpp/GLFWwindow* window)
        camera-position (math/*-> :vec3 position)
        camera-front (math/*-> :vec3 front)
        camera-up (math/*-> :vec3 up)]

    (when (= (cpp/glfwGetKey window GLFW_KEY_ESCAPE)
             GLFW_PRESS)
      (cpp/glfwSetWindowShouldClose window 1))

    (when (= (cpp/glfwGetKey window GLFW_KEY_W) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/+ camera-position
                    (cpp/* camera-speed
                           camera-front)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_S) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/- camera-position
                    (cpp/* camera-speed
                           camera-front)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_A) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/- camera-position
                    (cpp/* (cpp/glm.normalize
                            (cpp/glm.cross
                             camera-front
                             camera-up))
                           camera-speed)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_D) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/+ camera-position
                    (cpp/* (cpp/glm.normalize
                            (cpp/glm.cross
                             camera-front
                             camera-up))
                           camera-speed)))
      nil)))

(defn setup-window
  [{:keys [width height name]}]

  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MAJOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MINOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_PROFILE")
                      (cpp/value "GLFW_OPENGL_CORE_PROFILE"))
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_FORWARD_COMPAT")
                      (cpp/value "GL_TRUE"))

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (if (cpp/! window)
      (do (println "Window creation failed")
          (cpp/exit 0))
      (do
        (cpp/glfwMakeContextCurrent window)
        (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback)
        (cpp/glEnable (cpp/value "GL_DEPTH_TEST"))

        (cpp/box window)))))

(defn update-camera
  [{{:keys [front]} :camera
    :cursor/keys [pitch yaw]}]
  (let [direction (math/gimmie :vec3 [0.0 0.0 0.0])
        pitch (math/*-> :float pitch)
        yaw (math/*-> :float yaw)
        _ (cpp/= (cpp/aget direction (cpp/int 0))
                 (cpp/* (cpp/cos (cpp/glm.radians yaw))
                        (cpp/cos (cpp/glm.radians pitch))))
        _ (cpp/= (cpp/aget direction (cpp/int 1))
                 (cpp/sin (cpp/glm.radians pitch)))
        _ (cpp/= (cpp/aget direction (cpp/int 2))
                 (cpp/* (cpp/sin (cpp/glm.radians yaw))
                        (cpp/cos (cpp/glm.radians pitch))))
        _ (cpp/= (math/*-> :vec3 front) direction)]))

(defn draw-3D
  [{{:keys [position direction right front]} :camera
    :keys [_window model shader] :as context}]
  (let [_ (cpp/glClearColor 0.2 0.3 0.3 1.0)
        _ (cpp/glClear (cpp/| (cpp/value "GL_COLOR_BUFFER_BIT") (cpp/value "GL_DEPTH_BUFFER_BIT")))
        _ (cpp/glUseProgram shader)
        _ (update-camera context)
        camera-position (math/*-> :vec3 position)
        camera-direction (math/*-> :vec3 direction)
        camera-right (math/*-> :vec3 right)
        camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))
        camera-front (math/*-> :vec3 front)

        model-m (cpp/identity_matrix)
        model-m (cpp/glm.scale model-m (cpp/glm.vec3 (cpp/float 50.0) (cpp/float 1.0) (cpp/float 50.0)))
        model-m-loc (cpp/glGetUniformLocation shader "model")
        _ (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr model-m))

        view-m (cpp/glm.lookAt camera-position (cpp/+ camera-position camera-front) camera-up)

        view-m-loc (cpp/glGetUniformLocation shader "view")
        _ (cpp/glUniformMatrix4fv view-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr view-m))

        projection-m-loc (cpp/glGetUniformLocation shader "projection")
        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 800.0) (cpp/float 600.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))

        _ (cpp/glUniformMatrix4fv projection-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr projection-m))
        
        #_#_#_#_positions (math/gimmie :boxed :vec3s
                                       [[0.0 0.0 0.0]
                                        [2.0 5.0 -15.0]
                                        [-1.5 -2.2 -2.5]
                                        [-3.8 -2.0 -12.3]
                                        [2.4 -0.4 -3.5]
                                        [-1.7 3.0 -7.5]
                                        [1.3 -2.0 -2.5]
                                        [1.5  2.0 -2.5]
                                        [1.5  0.2 -1.5]
                                        [-1.3 1.0 -1.5]])

            _ (doseq [i (range 10)]
                (let [p (cpp/aget (math/*-> :vec3s positions) (cpp/int i))
                      model-m (cpp/identity_matrix)
                      model-m (cpp/glm.translate model-m p)
                      angle (cpp/* (cpp/float 20.0) (cpp/int (inc i)))
                      model-m (cpp/glm.rotate model-m
                                              (cpp/float (cpp/* (cpp/glfwGetTime) (cpp/glm.radians angle)))
                                              (cpp/glm.vec3 (cpp/float 1.0) (cpp/float 0.3) (cpp/float 0.5)))
                      model-m-loc (cpp/glGetUniformLocation shader "model")
                      _ (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr model-m))]
                  ((:draw model))))]
    ((:draw model) {:shader shader})
    #_(cpp/delete (math/*-> :vec3s positions))))

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)

        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y)) 

        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)

        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))

        cursor-sensitivity (math/*-> :float sensitivity)

        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)

        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]

    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/+ cursor-pitch y-offset))

    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)

    (when (cpp/> cursor-pitch (cpp/float 89.0))
      (cpp/= cursor-pitch (cpp/float 89.0)))

    (when (cpp/< cursor-pitch (cpp/float -89.0))
      (cpp/= cursor-pitch (cpp/float -89.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

(defn run-loop
  [{:keys [window]
    :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (update-time context)
    (update-cursor context)
    (process-input context)

    (draw-3D context)

    (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
    (cpp/glfwPollEvents)))

(defn setup-textures
  [shader]
  (let [texture1 (textures/load-texture {:path "textures/textures/container.jpg"})
        texture2 (textures/load-texture {:path "textures/textures/awesomeface.png"
                                         :alpha-channel? true})
        _ (cpp/glUseProgram shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "texture1") 0)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "texture2") 1)
        _ (cpp/glActiveTexture (cpp/value "GL_TEXTURE0"))
        _ (cpp/glBindTexture (cpp/value "GL_TEXTURE_2D") texture1)
        _ (cpp/glActiveTexture (cpp/value "GL_TEXTURE1"))
        _ (cpp/glBindTexture (cpp/value "GL_TEXTURE_2D") texture2)]))

(defn setup-camera []
  (let [camera-target (math/gimmie :boxed :vec3 [0.0 0.0 0.0])
        camera-position (math/gimmie :boxed :vec3 [0.0 1.0 3.0])
        up (math/gimmie :boxed :vec3 [0.0 1.0 0.0])
        camera-direction
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.normalize
           (cpp/- (math/*-> :vec3 camera-position)
                  (math/*-> :vec3 camera-target)))))
        camera-right
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.normalize
           (cpp/glm.cross (math/*-> :vec3 up)
                          (math/*-> :vec3 camera-direction)))))
        camera-up
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.cross (math/*-> :vec3 camera-direction)
                         (math/*-> :vec3 camera-right))))
        camera-front (math/gimmie :boxed :vec3 [0.0 0.0 -1.0])]

    {:target camera-target
     :position camera-position
     :direction camera-direction
     :right camera-right
     :up camera-up
     :front camera-front}))

(defn -main [x]
  (let [_ (cpp/glfwInit)
        window (setup-window {:width 800 :height 600 :name "Learn OpenGL"})
        _ (cpp/glfwSetInputMode
           (cpp/unbox cpp/GLFWwindow* window)
           (cpp/value "GLFW_CURSOR")
           (cpp/value "GLFW_CURSOR_DISABLED"))
        shader (shaders/load-shader-program
                {:vertex-shader-path
                 "shaders/basic_vertex.glsl"
                 :fragment-shader-path
                 "shaders/basic_fragment.glsl"}) 
        _ (cpp/glUseProgram shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "uBaseColorTex") 0)
        model (gltf/load {:model (gltf/parse {:path "models/grid-sand.gltf"})})
        #_#__ (shaders/bind-vertex-array-object
               {:vertex-array-object-id (:vao model)})
        #_#__ (setup-textures shader)
        camera (setup-camera)]

    (run-loop {:window window
               :shader shader
               :model model
               :camera camera
               :delta-time          (math/gimmie :boxed :float 0.0)
               :last-frame          (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x       (math/gimmie :boxed :float 400.0)
               :cursor/last-y       (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity  (math/gimmie :boxed :float 0.1)
               :cursor/pitch        (math/gimmie :boxed :float 0.0)
               :cursor/yaw          (math/gimmie :boxed :float -90.0)})))

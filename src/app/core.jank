(ns app.core
  (:require [app.io.interface :as io]
            [app.shaders.interface :as shaders]
            [app.geometry.interface :as geometry]
            [app.textures.interface :as textures]
            [app.math.interface :as math]
            [app.gltf.interface :as gltf]))

(cpp/raw "#include <GLFW/glfw3.h>")

(cpp/raw "#include <glm/glm.hpp> 
          #include <glm/gtc/matrix_transform.hpp> 
          #include <glm/gtc/type_ptr.hpp>")

(cpp/raw "#include <math.h>")

(cpp/raw
 "void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

(def GLFW_PRESS (cpp/value "GLFW_PRESS"))
(def GLFW_KEY_ESCAPE (cpp/value "GLFW_KEY_ESCAPE"))
(def GLFW_KEY_W (cpp/value "GLFW_KEY_W"))
(def GLFW_KEY_S (cpp/value "GLFW_KEY_S"))
(def GLFW_KEY_A (cpp/value "GLFW_KEY_A"))
(def GLFW_KEY_D (cpp/value "GLFW_KEY_D"))

(defn process-input
  [{{:keys [position front up]} :camera
    :keys [window delta-time]}]
  (let [camera-speed (cpp/* (cpp/float 15.0) (math/*-> :float delta-time))
        window (cpp/unbox cpp/GLFWwindow* window)
        camera-position (math/*-> :vec3 position)
        camera-front (math/*-> :vec3 front)
        camera-up (math/*-> :vec3 up)]

    (when (= (cpp/glfwGetKey window GLFW_KEY_ESCAPE)
             GLFW_PRESS)
      (cpp/glfwSetWindowShouldClose window 1))

    (when (= (cpp/glfwGetKey window GLFW_KEY_W) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/+ camera-position
                    (cpp/* camera-speed
                           camera-front)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_S) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/- camera-position
                    (cpp/* camera-speed
                           camera-front)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_A) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/- camera-position
                    (cpp/* (cpp/glm.normalize
                            (cpp/glm.cross
                             camera-front
                             camera-up))
                           camera-speed)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_D) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/+ camera-position
                    (cpp/* (cpp/glm.normalize
                            (cpp/glm.cross
                             camera-front
                             camera-up))
                           camera-speed)))
      nil)))

(defn setup-window
  [{:keys [width height name]}]

  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MAJOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MINOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_PROFILE")
                      (cpp/value "GLFW_OPENGL_CORE_PROFILE"))
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_FORWARD_COMPAT")
                      (cpp/value "GL_TRUE"))

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (if (cpp/! window)
      (do (println "Window creation failed")
          (cpp/exit 0))
      (do
        (cpp/glfwMakeContextCurrent window)
        (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback)
        (cpp/glEnable (cpp/value "GL_DEPTH_TEST"))

        (cpp/box window)))))

(defn update-camera
  [{{:keys [front]} :camera
    :cursor/keys [pitch yaw]}]
  (let [direction (math/gimmie :vec3 [0.0 0.0 0.0])
        pitch (math/*-> :float pitch)
        yaw (math/*-> :float yaw)
        _ (cpp/= (cpp/aget direction (cpp/int 0))
                 (cpp/* (cpp/cos (cpp/glm.radians yaw))
                        (cpp/cos (cpp/glm.radians pitch))))
        _ (cpp/= (cpp/aget direction (cpp/int 1))
                 (cpp/sin (cpp/glm.radians pitch)))
        _ (cpp/= (cpp/aget direction (cpp/int 2))
                 (cpp/* (cpp/sin (cpp/glm.radians yaw))
                        (cpp/cos (cpp/glm.radians pitch))))
        _ (cpp/= (math/*-> :vec3 front) direction)]))

(defn draw-3D
  [{{:keys [position front]} :camera
    :keys [_window models shader] :as context}]
  (let [_ (cpp/glClearColor 0.2 0.3 0.3 1.0)
        _ (cpp/glClear (cpp/| (cpp/value "GL_COLOR_BUFFER_BIT") (cpp/value "GL_DEPTH_BUFFER_BIT")))
        _ (cpp/glUseProgram shader)
        _ (update-camera context)
        camera-position (math/*-> :vec3 position)
        camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))
        camera-front (math/*-> :vec3 front)

        model-m (cpp/identity_matrix)
        model-m-loc (cpp/glGetUniformLocation shader "model")
        _ (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr model-m))

        view-m (cpp/glm.lookAt camera-position (cpp/+ camera-position camera-front) camera-up)

        view-m-loc (cpp/glGetUniformLocation shader "view")
        _ (cpp/glUniformMatrix4fv view-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr view-m))

        projection-m-loc (cpp/glGetUniformLocation shader "projection")
        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))

        _ (cpp/glUniformMatrix4fv projection-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr projection-m))]
    (doseq [m models]
      ((:draw m) {:shader shader
                  :model/local-matrix-uniform "local"}))))

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)

        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y)) 

        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)

        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))

        cursor-sensitivity (math/*-> :float sensitivity)

        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)

        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]

    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/+ cursor-pitch y-offset))

    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)

    (when (cpp/> cursor-pitch (cpp/float 89.0))
      (cpp/= cursor-pitch (cpp/float 89.0)))

    (when (cpp/< cursor-pitch (cpp/float -89.0))
      (cpp/= cursor-pitch (cpp/float -89.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

(defn run-loop
  [{:keys [window]
    :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (update-time context)
    (update-cursor context)
    (process-input context)

    (draw-3D context)

    (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
    (cpp/glfwPollEvents)))

(defn setup-camera []
  (let [camera-target (math/gimmie :boxed :vec3 [0.0 0.0 0.0])
        camera-position (math/gimmie :boxed :vec3 [0.0 1.0 3.0])
        up (math/gimmie :boxed :vec3 [0.0 1.0 0.0])
        camera-direction
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.normalize
           (cpp/- (math/*-> :vec3 camera-position)
                  (math/*-> :vec3 camera-target)))))
        camera-right
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.normalize
           (cpp/glm.cross (math/*-> :vec3 up)
                          (math/*-> :vec3 camera-direction)))))
        camera-up
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.cross (math/*-> :vec3 camera-direction)
                         (math/*-> :vec3 camera-right))))
        camera-front (math/gimmie :boxed :vec3 [0.0 0.0 -1.0])]

    {:target camera-target
     :position camera-position
     :direction camera-direction
     :right camera-right
     :up camera-up
     :front camera-front}))

(defn -main [x]
  (let [_ (cpp/glfwInit)
        window (setup-window {:width 1280 :height 720 :name "Learn OpenGL"})
        _ (cpp/glfwSetInputMode
           (cpp/unbox cpp/GLFWwindow* window)
           (cpp/value "GLFW_CURSOR")
           (cpp/value "GLFW_CURSOR_DISABLED"))
        shader (shaders/load-shader-program
                {:vertex-shader-path
                 "shaders/basic_vertex.glsl"
                 :fragment-shader-path
                 "shaders/basic_fragment.glsl"})
        _ (cpp/glUseProgram shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "uBaseColorTex") 0)
        level (gltf/load {:model (gltf/parse {:path "models/test-level.gltf"})})
        player (gltf/load {:model (gltf/parse {:path "models/player.gltf"})})
        camera (setup-camera)]

    (run-loop {:window window
               :shader shader
               :models [level player]
               :camera camera
               :delta-time          (math/gimmie :boxed :float 0.0)
               :last-frame          (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x       (math/gimmie :boxed :float 400.0)
               :cursor/last-y       (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity  (math/gimmie :boxed :float 0.1)
               :cursor/pitch        (math/gimmie :boxed :float 0.0)
               :cursor/yaw          (math/gimmie :boxed :float -90.0)})))

(ns app.core
  (:require [app.io.interface :as io]
            [app.shaders.interface :as shaders]
            [app.geometry.interface :as geometry]
            [app.textures.interface :as textures]
            [app.math.interface :as math]))

(cpp/raw "#include <GLFW/glfw3.h>")

(cpp/raw "#include <glm/glm.hpp> 
          #include <glm/gtc/matrix_transform.hpp> 
          #include <glm/gtc/type_ptr.hpp>")

(cpp/raw "#include <math.h>")

(cpp/raw
 "void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

(cpp/raw
 "glm::mat4 identity_matrix () {
    return glm::mat4(1.0f);
  }")

(def GLFW_PRESS (cpp/value "GLFW_PRESS"))
(def GLFW_KEY_ESCAPE (cpp/value "GLFW_KEY_ESCAPE"))
(def GLFW_KEY_W (cpp/value "GLFW_KEY_W"))
(def GLFW_KEY_S (cpp/value "GLFW_KEY_S"))
(def GLFW_KEY_A (cpp/value "GLFW_KEY_A"))
(def GLFW_KEY_D (cpp/value "GLFW_KEY_D"))

(defn process-input
  [{{:keys [position front up]} :camera
    :keys [window delta-time]}]
  (let [camera-speed (cpp/* (cpp/float 2.5) (math/*-> :float delta-time))
        window (cpp/unbox cpp/GLFWwindow* window)
        camera-position (math/*-> :vec3 position)
        camera-front (math/*-> :vec3 front)
        camera-up (math/*-> :vec3 up)] 

    (when (= (cpp/glfwGetKey window GLFW_KEY_ESCAPE)
             GLFW_PRESS)
      (cpp/glfwSetWindowShouldClose window 1))

    (when (= (cpp/glfwGetKey window GLFW_KEY_W) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/+ camera-position
                    (cpp/* camera-speed
                           camera-front)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_S) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/- camera-position
                    (cpp/* camera-speed
                           camera-front)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_A) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/- camera-position
                    (cpp/* (cpp/glm.normalize
                            (cpp/glm.cross
                             camera-front
                             camera-up))
                           camera-speed)))
      nil)

    (when (= (cpp/glfwGetKey window GLFW_KEY_D) GLFW_PRESS)
      (cpp/= camera-position
             (cpp/+ camera-position
                    (cpp/* (cpp/glm.normalize
                            (cpp/glm.cross
                             camera-front
                             camera-up))
                           camera-speed)))
      nil)))

(defn setup-window
  []
  (let [width 800
        height 600
        window-name "LearnOpenGL"]

    (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MAJOR") 3)
    (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MINOR") 3)
    (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_PROFILE")
                        (cpp/value "GLFW_OPENGL_CORE_PROFILE"))
    (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_FORWARD_COMPAT")
                        (cpp/value "GL_TRUE"))

    (let [window (cpp/box (cpp/glfwCreateWindow width height window-name cpp/nullptr cpp/nullptr))]
      (if (cpp/! (cpp/unbox cpp/GLFWwindow* window))
        (do (println "Window creation failed")
            (cpp/exit 0))
        (do
          (cpp/glfwMakeContextCurrent (cpp/unbox cpp/GLFWwindow* window))
          (cpp/glfwSetFramebufferSizeCallback (cpp/unbox cpp/GLFWwindow* window) cpp/framebuffer_size_callback)
          (cpp/glEnable (cpp/value "GL_DEPTH_TEST"))

          window)))))

(defn draw-3D
  [{{:keys [position direction right front]} :camera
    :keys [_window model shader]}]
  (let [_ (cpp/glClearColor 0.2 0.3 0.3 1.0)
        _ (cpp/glClear (cpp/| (cpp/value "GL_COLOR_BUFFER_BIT") (cpp/value "GL_DEPTH_BUFFER_BIT")))
        _ (cpp/glUseProgram shader)
        camera-position (math/*-> :vec3 position)
        camera-direction (math/*-> :vec3 direction) 
        camera-right (math/*-> :vec3 right)
        camera-up (cpp/glm.cross camera-direction camera-right)
        camera-front (math/*-> :vec3 front)

        view-m (cpp/glm.lookAt camera-position (cpp/+ camera-position camera-front) camera-up)

        view-m-loc (cpp/glGetUniformLocation shader "view")
        _ (cpp/glUniformMatrix4fv view-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr view-m))

        projection-m-loc (cpp/glGetUniformLocation shader "projection")
        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 800.0) (cpp/float 600.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))

        _ (cpp/glUniformMatrix4fv projection-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr projection-m))

        positions (math/gimmie :boxed :vec3s
                               [[0.0 0.0 0.0]
                                [2.0 5.0 -15.0]
                                [-1.5 -2.2 -2.5]
                                [-3.8 -2.0 -12.3]
                                [2.4 -0.4 -3.5]
                                [-1.7 3.0 -7.5]
                                [1.3 -2.0 -2.5]
                                [1.5  2.0 -2.5]
                                [1.5  0.2 -1.5]
                                [-1.3 1.0 -1.5]])

        _ (doseq [i (range 10)]
            (let [p (cpp/aget (math/*-> :vec3s positions) (cpp/int i))
                  model-m (cpp/identity_matrix)
                  model-m (cpp/glm.translate model-m p)
                  angle (cpp/* (cpp/float 20.0) (cpp/int (inc i)))
                  model-m (cpp/glm.rotate model-m
                                          (cpp/float (cpp/* (cpp/glfwGetTime) (cpp/glm.radians angle)))
                                          (cpp/glm.vec3 (cpp/float 1.0) (cpp/float 0.3) (cpp/float 0.5)))
                  model-m-loc (cpp/glGetUniformLocation shader "model")
                  _ (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr model-m))]
              ((:draw model))))]))

(defn run-loop
  [{:keys [window]
    :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (let [current-frame (cpp/glfwGetTime)
          delta-time (math/*-> :float (:delta-time context))
          last-frame (math/*-> :float (:last-frame context))]
      
      (cpp/= delta-time (cpp/- current-frame last-frame))
      (cpp/= last-frame current-frame)

      (process-input context)

      (draw-3D context)

      (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
      (cpp/glfwPollEvents))))

(defn setup-textures
  [shader]
  (let [texture1 (textures/load-texture {:path "textures/textures/container.jpg"})
        texture2 (textures/load-texture {:path "textures/textures/awesomeface.png"
                                         :alpha-channel? true})
        _ (cpp/glUseProgram shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "texture1") 0)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "texture2") 1)
        _ (cpp/glActiveTexture (cpp/value "GL_TEXTURE0"))
        _ (cpp/glBindTexture (cpp/value "GL_TEXTURE_2D") texture1)
        _ (cpp/glActiveTexture (cpp/value "GL_TEXTURE1"))
        _ (cpp/glBindTexture (cpp/value "GL_TEXTURE_2D") texture2)]))

(defn setup-camera []
  (let [camera-target (math/gimmie :boxed :vec3 [0.0 0.0 0.0])
        camera-position (math/gimmie :boxed :vec3 [0.0 0.0 3.0])
        up (math/gimmie :boxed :vec3 [0.0 1.0 0.0])
        camera-direction
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.normalize
           (cpp/- (math/*-> :vec3 camera-position)
                  (math/*-> :vec3 camera-target)))))
        camera-right
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.normalize
           (cpp/glm.cross (math/*-> :vec3 up)
                          (math/*-> :vec3 camera-direction)))))
        camera-up
        (cpp/box
         (cpp/new
          cpp/glm.vec3
          (cpp/glm.cross (math/*-> :vec3 camera-direction)
                         (math/*-> :vec3 camera-right))))
        camera-front (math/gimmie :boxed :vec3 [0.0 0.0 -1.0])]

    {:target camera-target
     :position camera-position
     :direction camera-direction
     :right camera-right
     :up camera-up
     :front camera-front}))

(defn -main [x]
  (let [_ (cpp/glfwInit)
        window (setup-window)
        shader (shaders/load-shader-program
                {:vertex-shader-path
                 "shaders/basic_vertex.glsl"
                 :fragment-shader-path
                 "shaders/basic_fragment.glsl"})
        model (geometry/textured-cube-3D)
        _ (shaders/bind-vertex-array-object
           {:vertex-array-object-id (:vao model)})
        _ (setup-textures shader)
        camera (setup-camera)]
    
    (run-loop {:window window
               :shader shader
               :model model
               :camera camera
               :delta-time (math/gimmie :boxed :float 0.0)
               :last-frame (math/gimmie :boxed :float 0.0)})))

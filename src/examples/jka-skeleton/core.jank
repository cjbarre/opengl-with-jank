(ns examples.jka-skeleton.core
  "JKA Skeleton Viewer - Displays all converted Jedi Academy animations
   with category-based navigation (TAB cycles categories, 1-9 selects within)"
  (:require [engine.shaders.interface :as shaders]
            [engine.math.interface :as math]
            [engine.3d.animation.interface :as anim]
            [engine.2d.text.interface :as text]
            [engine.io.interface :as io]
            [engine.gl.constants :as gl]))

(cpp/raw "#include \"gl_wrappers.h\"
#include <GLFW/glfw3.h>
#include <cstdio>
#include <vector>

// GLEW initialization for Linux
inline bool init_glew_jka() {
#ifndef __APPLE__
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK) {
        fprintf(stderr, \"GLEW initialization failed: %s\\n\", glewGetErrorString(err));
        return false;
    }
    while (glGetError() != GL_NO_ERROR) {}
    return true;
#else
    return true;
#endif
}
")

(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>
          #include \"gl_utils.h\"

          inline glm::mat4 zup_to_yup_matrix() {
              // gla2ozz now converts correctly - no rotation needed
              return glm::mat4(1.0f);
          }")

(cpp/raw "#include \"animation_types.h\"")

(cpp/raw "
  inline void framebuffer_size_callback_jka(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
  }

  inline glm::vec3 make_vec3(float x, float y, float z) {
      return glm::vec3(x, y, z);
  }

  inline GLuint compile_shader_inline(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);
    return shader;
  }

  inline GLuint create_line_shader(const char* vs, const char* fs) {
    GLuint vert = compile_shader_inline(GL_VERTEX_SHADER, vs);
    GLuint frag = compile_shader_inline(GL_FRAGMENT_SHADER, fs);
    GLuint prog = glCreateProgram();
    glAttachShader(prog, vert);
    glAttachShader(prog, frag);
    glLinkProgram(prog);
    glDeleteShader(vert);
    glDeleteShader(frag);
    return prog;
  }

  inline GLuint create_line_vao(GLuint* vbo_out) {
    GLuint vao, vbo;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, 128 * 6 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
    *vbo_out = vbo;
    return vao;
  }

  inline void update_line_vbo(GLuint vbo, float* vertices, int line_count) {
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, line_count * 6 * sizeof(float), vertices);
  }

  inline float* get_vector_data(std::vector<float>* v) {
    return v->data();
  }

  inline bool starts_with(const char* str, const char* prefix) {
      return strncmp(str, prefix, strlen(prefix)) == 0;
  }
")

;; Simple line shader for skeleton visualization
(def line-vertex-shader
  "#version 330 core
   layout (location = 0) in vec3 aPos;
   uniform mat4 model;
   uniform mat4 view;
   uniform mat4 projection;
   void main() {
       gl_Position = projection * view * model * vec4(aPos, 1.0);
   }")

(def line-fragment-shader
  "#version 330 core
   out vec4 FragColor;
   uniform vec3 lineColor;
   void main() {
       FragColor = vec4(lineColor, 1.0);
   }")

(defn setup-window
  [{:keys [width height name]}]
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MAJOR 3)
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MINOR 3)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_PROFILE gl/GLFW_OPENGL_CORE_PROFILE)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_FORWARD_COMPAT gl/GL_TRUE)

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    (when (cpp/! (cpp/init_glew_jka))
      (println "GLEW initialization failed")
      (cpp/exit 1))
    (cpp/glfwSwapInterval 1)
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback_jka)
    (cpp/wrap_glEnable gl/GL_DEPTH_TEST)
    (cpp/box window)))

;; ============================================================================
;; Animation Loading
;; ============================================================================

(def PAGE_SIZE 9)

(cpp/raw "
  // Debug: Compare animation model matrices vs rest pose model matrices
  inline void debug_compare_anim_vs_rest(AnimationContext* ctx) {
    if (!ctx || !ctx->skeleton) return;

    ozz::animation::Skeleton* skel = ctx->skeleton;
    int num_joints = skel->num_joints();
    int num_soa = skel->num_soa_joints();

    // Compute REST POSE model matrices
    std::vector<ozz::math::SoaTransform> rest_locals(num_soa);
    std::vector<ozz::math::Float4x4> rest_models(num_joints);
    for (int i = 0; i < num_soa; ++i) {
      rest_locals[i] = skel->joint_rest_poses()[i];
    }
    ozz::animation::LocalToModelJob ltm_job;
    ltm_job.skeleton = skel;
    ltm_job.input = ozz::make_span(rest_locals);
    ltm_job.output = ozz::make_span(rest_models);
    ltm_job.Run();

    // Compare with animation model matrices (already in ctx->models)
    printf(\"\\n=== COMPARING ANIMATION vs REST POSE ===\\n\");
    printf(\"%-20s  %-24s  %-24s  %s\\n\", \"Joint\", \"REST (x,y,z)\", \"ANIM (x,y,z)\", \"Delta\");

    float max_delta = 0;
    int max_delta_joint = -1;

    for (int i = 0; i < std::min(15, num_joints); ++i) {
      // Rest position
      float rx = ozz::math::GetX(rest_models[i].cols[3]);
      float ry = ozz::math::GetY(rest_models[i].cols[3]);
      float rz = ozz::math::GetZ(rest_models[i].cols[3]);

      // Animation position
      float ax = ozz::math::GetX(ctx->models[i].cols[3]);
      float ay = ozz::math::GetY(ctx->models[i].cols[3]);
      float az = ozz::math::GetZ(ctx->models[i].cols[3]);

      float delta = sqrtf((rx-ax)*(rx-ax) + (ry-ay)*(ry-ay) + (rz-az)*(rz-az));
      if (delta > max_delta) {
        max_delta = delta;
        max_delta_joint = i;
      }

      printf(\"%-20s  (%.3f, %.3f, %.3f)  (%.3f, %.3f, %.3f)  %.3f\\n\",
             skel->joint_names()[i], rx, ry, rz, ax, ay, az, delta);
    }

    printf(\"\\nMax delta: %.3f at joint %d ('%s')\\n\",
           max_delta, max_delta_joint,
           max_delta_joint >= 0 ? skel->joint_names()[max_delta_joint] : \"none\");

    // Also print the LOCAL transforms from animation (what SamplingJob produced)
    printf(\"\\n=== ANIMATION LOCAL TRANSFORMS (from SamplingJob) ===\\n\");
    printf(\"%-20s  %-30s  %-30s\\n\", \"Joint\", \"Local Translation\", \"Local Rotation (quat)\");

    // Access SoaTransform data - need to transpose for individual joints
    for (int soa_idx = 0; soa_idx < std::min(4, num_soa); ++soa_idx) {
      const ozz::math::SoaTransform& soa = ctx->locals[soa_idx];

      // ozz stores 4 joints per SoaTransform using SIMD
      // We need to extract individual components from the SIMD vectors
      alignas(16) float tx[4], ty[4], tz[4];
      alignas(16) float rx[4], ry[4], rz[4], rw[4];

      // Store SIMD vectors to arrays (ozz cross-platform)
      ozz::math::StorePtrU(soa.translation.x, tx);
      ozz::math::StorePtrU(soa.translation.y, ty);
      ozz::math::StorePtrU(soa.translation.z, tz);
      ozz::math::StorePtrU(soa.rotation.x, rx);
      ozz::math::StorePtrU(soa.rotation.y, ry);
      ozz::math::StorePtrU(soa.rotation.z, rz);
      ozz::math::StorePtrU(soa.rotation.w, rw);

      for (int lane = 0; lane < 4; ++lane) {
        int joint = soa_idx * 4 + lane;
        if (joint >= num_joints) break;

        printf(\"%-20s  (%.4f, %.4f, %.4f)        (%.4f, %.4f, %.4f, %.4f)\\n\",
               skel->joint_names()[joint],
               tx[lane], ty[lane], tz[lane],
               rx[lane], ry[lane], rz[lane], rw[lane]);
      }
    }

    // Also compare REST POSE local transforms
    printf(\"\\n=== REST POSE LOCAL TRANSFORMS ===\\n\");
    printf(\"%-20s  %-30s  %-30s\\n\", \"Joint\", \"Local Translation\", \"Local Rotation (quat)\");
    for (int soa_idx = 0; soa_idx < std::min(4, num_soa); ++soa_idx) {
      const ozz::math::SoaTransform& soa = skel->joint_rest_poses()[soa_idx];

      alignas(16) float tx[4], ty[4], tz[4];
      alignas(16) float rx[4], ry[4], rz[4], rw[4];

      ozz::math::StorePtrU(soa.translation.x, tx);
      ozz::math::StorePtrU(soa.translation.y, ty);
      ozz::math::StorePtrU(soa.translation.z, tz);
      ozz::math::StorePtrU(soa.rotation.x, rx);
      ozz::math::StorePtrU(soa.rotation.y, ry);
      ozz::math::StorePtrU(soa.rotation.z, rz);
      ozz::math::StorePtrU(soa.rotation.w, rw);

      for (int lane = 0; lane < 4; ++lane) {
        int joint = soa_idx * 4 + lane;
        if (joint >= num_joints) break;

        printf(\"%-20s  (%.4f, %.4f, %.4f)        (%.4f, %.4f, %.4f, %.4f)\\n\",
               skel->joint_names()[joint],
               tx[lane], ty[lane], tz[lane],
               rx[lane], ry[lane], rz[lane], rw[lane]);
      }
    }

    printf(\"=== END DEBUG ===\\n\\n\");
  }
")

(defn load-animations
  "Load skeleton and animations from jka directory"
  []
  (println "Loading JKA skeleton and animations...")
  (let [base-path "models/player/jka/"
        ctx (anim/create-context)

        ;; Load skeleton
        skeleton-info (anim/load-skeleton {:path (str base-path "humanoid.ozz")
                                           :context ctx})
        _ (println "  Skeleton loaded:" (:num-joints skeleton-info) "joints")

        ;; List all .ozz files from directory using engine io module
        all-anim-names (io/list-dir {:path base-path
                                     :extension ".ozz"
                                     :exclude #{"humanoid"}})
        _ (println "  Found" (count all-anim-names) "animation files")

        ;; Put BOTH_STAND1 first, then other animations
        stand-first (vec (concat
                          (filter #(= % "BOTH_STAND1") all-anim-names)
                          (take 99 (remove #(= % "BOTH_STAND1") all-anim-names))))
        anim-names stand-first
        _ (println "  Loading" (count anim-names) "animations (starting with BOTH_STAND1)...")

        ;; Load animations
        anim-infos (loop [names anim-names
                         idx 0
                         result []]
                     (if (empty? names)
                       result
                       (let [anim-name (first names)
                             path (str base-path anim-name ".ozz")
                             info (anim/load-animation {:path path :context ctx})]
                         (recur (rest names)
                                (inc idx)
                                (conj result {:name anim-name
                                              :idx idx
                                              :duration (double (:duration info))})))))
        _ (println "  Ready!")]
    {:context ctx
     :animations anim-infos
     :current-anim 0
     :anim-time 0.0
     :num-joints (:num-joints skeleton-info)
     :use-rest-pose false}))  ;; Use animations

;; ============================================================================
;; Time Update (matches demo pattern)
;; ============================================================================

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

;; ============================================================================
;; Input Processing (matches demo cond-> pattern)
;; ============================================================================

(defn process-input
  [{:keys [window state]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)
        anim-count (count (:animations @state))]
    (cond-> {:command/name :viewer/input}
      ;; ESC to exit
      (= (cpp/glfwGetKey window gl/GLFW_KEY_ESCAPE) gl/GLFW_PRESS)
      (assoc :exit true)

      ;; LEFT arrow - previous animation
      (= (cpp/glfwGetKey window gl/GLFW_KEY_LEFT) gl/GLFW_PRESS)
      (assoc :prev-anim true)

      ;; RIGHT arrow - next animation
      (= (cpp/glfwGetKey window gl/GLFW_KEY_RIGHT) gl/GLFW_PRESS)
      (assoc :next-anim true)

      ;; Number keys 1-9 direct select
      (= (cpp/glfwGetKey window gl/GLFW_KEY_1) gl/GLFW_PRESS) (assoc :select-anim 0)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_2) gl/GLFW_PRESS) (assoc :select-anim 1)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_3) gl/GLFW_PRESS) (assoc :select-anim 2)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_4) gl/GLFW_PRESS) (assoc :select-anim 3)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_5) gl/GLFW_PRESS) (assoc :select-anim 4)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_6) gl/GLFW_PRESS) (assoc :select-anim 5)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_7) gl/GLFW_PRESS) (assoc :select-anim 6)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_8) gl/GLFW_PRESS) (assoc :select-anim 7)
      (= (cpp/glfwGetKey window gl/GLFW_KEY_9) gl/GLFW_PRESS) (assoc :select-anim 8))))

;; ============================================================================
;; Command Handling
;; ============================================================================

(defn handle-command
  [{:keys [command window state key-state]}]
  (let [window-ptr (cpp/unbox cpp/GLFWwindow* window)
        anim-count (count (:animations @state))
        prev-key-state @key-state]

    ;; Handle exit
    (when (:exit command)
      (cpp/glfwSetWindowShouldClose window-ptr 1))

    ;; Handle prev/next with debouncing
    (when (and (:prev-anim command) (not (:prev-anim prev-key-state)))
      (swap! state update :current-anim #(mod (dec (+ % anim-count)) anim-count))
      (swap! state assoc :anim-time 0.0))

    (when (and (:next-anim command) (not (:next-anim prev-key-state)))
      (swap! state update :current-anim #(mod (inc %) anim-count))
      (swap! state assoc :anim-time 0.0))

    ;; Handle number key selection with debouncing
    (when-let [sel (:select-anim command)]
      (when (and (< sel anim-count) (not (:select-anim prev-key-state)))
        (swap! state assoc :current-anim sel :anim-time 0.0)))

    ;; Update key state for debouncing
    (reset! key-state {:prev-anim (:prev-anim command)
                       :next-anim (:next-anim command)
                       :select-anim (:select-anim command)})))

;; ============================================================================
;; Animation Update
;; ============================================================================

(defn update-animation
  [{:keys [state delta-time]}]
  (let [dt (double (math/*-> :float delta-time))
        {:keys [context animations current-anim anim-time debug-printed]} @state]
    (when (seq animations)
      (let [anim-info (nth animations current-anim)
            duration (double (:duration anim-info 1.0))
            new-time (mod (+ anim-time dt) (max duration 0.001))
            time-ratio (/ new-time (max duration 0.001))]
        (swap! state assoc :anim-time new-time)
        (anim/sample {:context context
                      :animation-index (:idx anim-info)
                      :time-ratio time-ratio})
        ;; Debug: print positions once after first sample
        (when (not debug-printed)
          (println "DEBUG: Playing animation:" (:name anim-info))
          ;; Compare animation vs rest pose matrices
          (let [ctx (cpp/unbox cpp/AnimationContext* context)]
            (cpp/debug_compare_anim_vs_rest ctx))
          (swap! state assoc :debug-printed true))))))

;; ============================================================================
;; Rendering
;; ============================================================================

(defn render
  [{:keys [state line-shader line-vao line-vbo text-shader]}]
  (cpp/wrap_glClearColor 0.1 0.1 0.15 1.0)
  (cpp/wrap_glClear gl/GL_COLOR_DEPTH_BUFFER_BITS)

  (let [{:keys [context animations current-anim use-rest-pose lines-printed]} @state]
    ;; Build skeleton lines - use REST POSE for debugging
    (let [lines-data (if use-rest-pose
                       (anim/build-skeleton-lines-rest-pose {:context context :max-lines 128})
                       (anim/build-skeleton-lines {:context context :max-lines 128}))
          line-count (int (:line-count lines-data))
          verts-box (:vertices lines-data)
          verts-ptr (cpp/get_vector_data (cpp/unbox (cpp/type "std::vector<float>*") verts-box))]


      ;; Update VBO
      (cpp/update_line_vbo line-vbo verts-ptr (cpp/int line-count))

      ;; Setup matrices
      (let [model (cpp/zup_to_yup_matrix)
            view (cpp/glm.lookAt (cpp/make_vec3 3.0 2.0 3.0)
                                  (cpp/make_vec3 0.0 1.0 0.0)
                                  (cpp/make_vec3 0.0 1.0 0.0))
            projection (cpp/glm.perspective (cpp/glm.radians (cpp/float 45.0))
                                             (cpp/float (/ 1280.0 720.0))
                                             (cpp/float 0.1)
                                             (cpp/float 100.0))]

        ;; Draw skeleton
        (cpp/wrap_glUseProgram line-shader)

        ;; Set uniforms
        (cpp/wrap_glUniformMatrix4fv (cpp/glGetUniformLocation line-shader "model")
                                     1 gl/GL_FALSE (cpp/glm.value_ptr model))
        (cpp/wrap_glUniformMatrix4fv (cpp/glGetUniformLocation line-shader "view")
                                     1 gl/GL_FALSE (cpp/glm.value_ptr view))
        (cpp/wrap_glUniformMatrix4fv (cpp/glGetUniformLocation line-shader "projection")
                                     1 gl/GL_FALSE (cpp/glm.value_ptr projection))
        (cpp/wrap_glUniform3f (cpp/glGetUniformLocation line-shader "lineColor") 0.0 1.0 0.5)

        (cpp/wrap_glBindVertexArray line-vao)
        (cpp/wrap_glDrawArrays gl/GL_LINES 0 (cpp/* (cpp/int line-count) (cpp/int 2)))
        (cpp/wrap_glBindVertexArray 0)))

    ;; Render HUD
    (when (seq animations)
      (let [anim-info (nth animations current-anim)]
        (text/render-text (str "Animation: " (:name anim-info))
                          10.0 30.0 [1.0 1.0 1.0] 1280 720)
        (text/render-text (str "[" (inc current-anim) "/" (count animations) "]")
                          10.0 55.0 [0.7 0.7 0.7] 1280 720)
        (text/render-text "LEFT/RIGHT: change | 1-9: select | ESC: exit"
                          10.0 80.0 [0.5 0.5 0.5] 1280 720)))))

;; ============================================================================
;; Main Loop
;; ============================================================================

(defn run-loop
  [{:keys [window] :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (update-time context)
    (let [command (process-input context)]
      (handle-command (assoc context :command command)))
    (update-animation context)
    (render context)
    (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
    (cpp/glfwPollEvents)))

(defn -main
  []
  (println "=== JKA Skeleton Viewer ===")
  (println "Controls: LEFT/RIGHT arrows, 1-9 keys, ESC to exit")
  (println "")

  (let [_ (cpp/glfwInit)
        window (setup-window {:width 1280 :height 720 :name "JKA Skeleton Viewer"})

        ;; Create shaders
        line-shader (cpp/create_line_shader line-vertex-shader line-fragment-shader)
        line-vbo-ptr (cpp/new cpp/GLuint)
        line-vao (cpp/create_line_vao line-vbo-ptr)
        line-vbo (cpp/* line-vbo-ptr)

        ;; Load text shader
        text-shader (shaders/load-shader-program
                     {:vertex-shader-path "shaders/text_vertex.glsl"
                      :fragment-shader-path "shaders/text_fragment.glsl"})
        _ (text/init-font "fonts/JetBrainsMono-Regular.ttf" 20.0 text-shader)

        ;; Load animations
        state (atom (load-animations))

        ;; Key debouncing state
        key-state (atom {})

        ;; Timing
        delta-time (math/gimmie :boxed :float 0.0)
        last-frame (math/gimmie :boxed :float 0.0)]

    (run-loop {:window window
               :state state
               :key-state key-state
               :delta-time delta-time
               :last-frame last-frame
               :line-shader line-shader
               :line-vao line-vao
               :line-vbo line-vbo
               :text-shader text-shader})))

(ns examples.jka-skeleton.core
  "JKA Skeleton Viewer - Displays converted Jedi Academy animations as skeleton lines"
  (:require [engine.shaders.interface :as shaders]
            [engine.math.interface :as math]
            [engine.3d.animation.interface :as anim]
            [engine.2d.text.interface :as text]
            [engine.gl.constants :as gl]))

(cpp/raw "#include \"gl_wrappers.h\"
#include <GLFW/glfw3.h>
#include <cstdio>

// GLEW initialization for Linux
inline bool init_glew_jka() {
#ifndef __APPLE__
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK) {
        fprintf(stderr, \"GLEW initialization failed: %s\\n\", glewGetErrorString(err));
        return false;
    }
    while (glGetError() != GL_NO_ERROR) {}
    return true;
#else
    return true;
#endif
}")

(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>
          #include \"gl_utils.h\"

          // Create a Z-up to Y-up conversion matrix (rotate -90 deg around X)
          inline glm::mat4 zup_to_yup_matrix() {
              return glm::rotate(glm::mat4(1.0f), glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
          }")

(cpp/raw "#include \"animation_types.h\"")

;; GLFW key codes and GL constants not in engine.gl.constants
(cpp/raw "
  inline int glfw_key_1() { return GLFW_KEY_1; }
  inline int glfw_key_2() { return GLFW_KEY_2; }
  inline int glfw_key_3() { return GLFW_KEY_3; }
  inline int glfw_key_4() { return GLFW_KEY_4; }
  inline int glfw_key_5() { return GLFW_KEY_5; }
  inline int gl_lines() { return GL_LINES; }
")
(def GLFW_KEY_1 (cpp/glfw_key_1))
(def GLFW_KEY_2 (cpp/glfw_key_2))
(def GLFW_KEY_3 (cpp/glfw_key_3))
(def GLFW_KEY_4 (cpp/glfw_key_4))
(def GLFW_KEY_5 (cpp/glfw_key_5))
(def GL_LINES (cpp/gl_lines))

(cpp/raw
 "inline void framebuffer_size_callback_jka(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }

  inline glm::vec3 make_vec3(float x, float y, float z) {
      return glm::vec3(x, y, z);
  }")

;; Simple line shader for skeleton visualization
(def line-vertex-shader
  "#version 330 core
   layout (location = 0) in vec3 aPos;
   uniform mat4 model;
   uniform mat4 view;
   uniform mat4 projection;
   void main() {
       gl_Position = projection * view * model * vec4(aPos, 1.0);
   }")

(def line-fragment-shader
  "#version 330 core
   out vec4 FragColor;
   uniform vec3 lineColor;
   void main() {
       FragColor = vec4(lineColor, 1.0);
   }")

(defn setup-window
  [{:keys [width height name]}]
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MAJOR 3)
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MINOR 3)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_PROFILE gl/GLFW_OPENGL_CORE_PROFILE)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_FORWARD_COMPAT gl/GL_TRUE)

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    (when (cpp/! (cpp/init_glew_jka))
      (println "GLEW initialization failed")
      (cpp/exit 1))
    (cpp/glfwSwapInterval 1)
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback_jka)
    (cpp/wrap_glEnable gl/GL_DEPTH_TEST)
    (cpp/box window)))

(cpp/raw
 "inline GLuint compile_shader_inline(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char log[512];
        glGetShaderInfoLog(shader, 512, nullptr, log);
        fprintf(stderr, \"Shader compile error: %s\\n\", log);
    }
    return shader;
  }

  inline GLuint create_line_shader(const char* vs, const char* fs) {
    GLuint vert = compile_shader_inline(GL_VERTEX_SHADER, vs);
    GLuint frag = compile_shader_inline(GL_FRAGMENT_SHADER, fs);
    GLuint prog = glCreateProgram();
    glAttachShader(prog, vert);
    glAttachShader(prog, frag);
    glLinkProgram(prog);
    GLint success;
    glGetProgramiv(prog, GL_LINK_STATUS, &success);
    if (!success) {
        char log[512];
        glGetProgramInfoLog(prog, 512, nullptr, log);
        fprintf(stderr, \"Shader link error: %s\\n\", log);
    }
    glDeleteShader(vert);
    glDeleteShader(frag);
    return prog;
  }

  // Create VAO for skeleton lines (dynamic updates)
  inline GLuint create_line_vao(GLuint* vbo_out) {
    GLuint vao, vbo;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    // Allocate space for 128 lines * 2 verts * 3 floats
    glBufferData(GL_ARRAY_BUFFER, 128 * 6 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
    *vbo_out = vbo;
    return vao;
  }

  // Update line VBO with new vertices
  inline void update_line_vbo(GLuint vbo, float* vertices, int line_count) {
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, line_count * 6 * sizeof(float), vertices);
  }

  // Get std::vector data pointer
  inline float* get_vector_data(std::vector<float>* v) {
    return v->data();
  }
  ")

(defn init-jka-animation
  "Initialize JKA animation system"
  []
  (println "Loading JKA _humanoid skeleton and animations...")
  (let [ctx (anim/create-context)
        skeleton-info (anim/load-skeleton {:path "models/player/jka/humanoid.ozz"
                                           :context ctx})
        _ (println "  Skeleton loaded:" (:num-joints skeleton-info) "joints")

        ;; Load available animations
        run-info (anim/load-animation {:path "models/player/jka/run1.ozz" :context ctx})
        _ (println "  Animation 0 (run1):" (:duration run-info) "s")

        walk-info (anim/load-animation {:path "models/player/jka/walk1.ozz" :context ctx})
        _ (println "  Animation 1 (walk1):" (:duration walk-info) "s")

        stand-info (anim/load-animation {:path "models/player/jka/stand1.ozz" :context ctx})
        _ (println "  Animation 2 (stand1):" (:duration stand-info) "s")

        death-info (anim/load-animation {:path "models/player/jka/death1.ozz" :context ctx})
        _ (println "  Animation 3 (death1):" (:duration death-info) "s")

        ;; Skip skeleton info for now - just use joint count from skeleton-info
        _ (println "  Ready to animate!")]
    {:context ctx
     :animations [{:name "run1" :duration (:duration run-info)}
                  {:name "walk1" :duration (:duration walk-info)}
                  {:name "stand1" :duration (:duration stand-info)}
                  {:name "death1" :duration (:duration death-info)}]
     :current-anim 0
     :time 0.0
     :num-joints 53}))

(defn -main
  []
  (println "=== JKA Skeleton Viewer ===")
  (println "Controls: 1-4 to switch animations, ESC to exit")
  (println "")

  (let [_ (cpp/glfwInit)
        window (setup-window {:width 1280 :height 720 :name "JKA Skeleton Viewer"})

        ;; Create line shader
        line-shader (cpp/create_line_shader line-vertex-shader line-fragment-shader)

        ;; Create line VAO/VBO
        line-vbo-ptr (cpp/new cpp/GLuint)
        line-vao (cpp/create_line_vao line-vbo-ptr)
        line-vbo (cpp/* line-vbo-ptr)

        ;; Load text shader for HUD
        text-shader (shaders/load-shader-program
                     {:vertex-shader-path "shaders/text_vertex.glsl"
                      :fragment-shader-path "shaders/text_fragment.glsl"})
        _ (text/init-font "fonts/JetBrainsMono-Regular.ttf" 24.0 text-shader)

        ;; Initialize animation
        anim-data (atom (init-jka-animation))

        ;; Timing
        delta-time (math/gimmie :boxed :float 0.0)
        last-frame (math/gimmie :boxed :float 0.0)

        ;; Camera settings
        cam-distance 4.0
        cam-height 1.2
        cam-angle (atom 0.0)]

    ;; Main loop
    (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
      (let [current-frame (cpp/glfwGetTime)
            dt-f (math/*-> :float delta-time)
            lf-f (math/*-> :float last-frame)
            _ (cpp/= dt-f (cpp/- current-frame lf-f))
            _ (cpp/= lf-f current-frame)
            dt (float dt-f)

            state @anim-data
            ctx (:context state)
            anims (:animations state)
            curr-idx (:current-anim state)
            curr-anim (nth anims curr-idx)
            duration (:duration curr-anim)

            ;; Update animation time
            new-time (mod (+ (:time state) dt) duration)
            time-ratio (/ new-time duration)
            _ (swap! anim-data assoc :time new-time)

            ;; Sample animation
            _ (anim/sample {:context ctx :animation-index curr-idx :time-ratio time-ratio})

            ;; Debug: print joint positions once at startup only
            _ (when (and (< (:time state) 0.01) (= curr-idx 0))
                (println "Animation playing - press 1-4 to switch animations")
                (println "Key joint positions (Y should be UP):")
                (cpp/debug_print_joint_positions (cpp/unbox cpp/AnimationContext* (:context state)) (cpp/int 20)))

            ;; Build skeleton lines from animation
            lines-data (anim/build-skeleton-lines {:context ctx :max-lines 128})
            line-count (:line-count lines-data)
            verts-box (:vertices lines-data)
            verts-ptr (cpp/get_vector_data (cpp/unbox (cpp/type "std::vector<float>*") verts-box))]

        ;; Check input
        (let [win (cpp/unbox cpp/GLFWwindow* window)]
          (when (= (cpp/glfwGetKey win gl/GLFW_KEY_ESCAPE) gl/GLFW_PRESS)
            (cpp/glfwSetWindowShouldClose win 1))
          (when (= (cpp/glfwGetKey win GLFW_KEY_1) gl/GLFW_PRESS)
            (swap! anim-data assoc :current-anim 0 :time 0.0))
          (when (= (cpp/glfwGetKey win GLFW_KEY_2) gl/GLFW_PRESS)
            (swap! anim-data assoc :current-anim 1 :time 0.0))
          (when (= (cpp/glfwGetKey win GLFW_KEY_3) gl/GLFW_PRESS)
            (swap! anim-data assoc :current-anim 2 :time 0.0))
          (when (= (cpp/glfwGetKey win GLFW_KEY_4) gl/GLFW_PRESS)
            (swap! anim-data assoc :current-anim 3 :time 0.0)))

        ;; Rotate camera slowly
        (swap! cam-angle + (* dt 0.3))

        ;; Clear
        (cpp/wrap_glClearColor 0.15 0.15 0.2 1.0)
        (cpp/wrap_glClear gl/GL_COLOR_DEPTH_BUFFER_BITS)

        ;; Set up matrices
        (let [angle (float @cam-angle)
              cam-x (cpp/* (cpp/float cam-distance) (cpp/cos (cpp/float angle)))
              cam-z (cpp/* (cpp/float cam-distance) (cpp/sin (cpp/float angle)))
              view-m (cpp/glm.lookAt
                      (cpp/make_vec3 (cpp/float cam-x) (cpp/float cam-height) (cpp/float cam-z))
                      (cpp/make_vec3 (cpp/float 0.0) (cpp/float 0.5) (cpp/float 0.0))
                      (cpp/make_vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0)))
              proj-m (cpp/glm.perspective
                      (cpp/glm.radians (cpp/float 60.0))
                      (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                      (cpp/float 0.1)
                      (cpp/float 100.0))
              ;; Model matrix - identity since coordinate conversion is done in converter
              model-m (cpp/glm.mat4 (cpp/float 1.0))]

          ;; Draw skeleton lines
          (cpp/wrap_glUseProgram line-shader)
          (cpp/wrap_glUniformMatrix4fv
           (cpp/wrap_glGetUniformLocation line-shader "model")
           (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr model-m))
          (cpp/wrap_glUniformMatrix4fv
           (cpp/wrap_glGetUniformLocation line-shader "view")
           (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr view-m))
          (cpp/wrap_glUniformMatrix4fv
           (cpp/wrap_glGetUniformLocation line-shader "projection")
           (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr proj-m))
          (cpp/wrap_glUniform3f
           (cpp/wrap_glGetUniformLocation line-shader "lineColor")
           (cpp/float 0.2) (cpp/float 0.8) (cpp/float 0.3))

          ;; Update VBO and draw
          (cpp/update_line_vbo line-vbo verts-ptr (cpp/int line-count))
          (cpp/wrap_glBindVertexArray line-vao)
          (cpp/glLineWidth (cpp/float 2.0))
          (cpp/wrap_glDrawArrays GL_LINES (cpp/int 0) (cpp/* (cpp/int line-count) (cpp/int 2)))
          (cpp/wrap_glBindVertexArray (cpp/GLuint 0)))

        ;; Draw HUD
        (text/render-text (str "Animation: " (:name curr-anim)) 10.0 30.0 [1.0 1.0 1.0] 1280 720)
        (text/render-text (str "Time: " (int (* new-time 100)) "ms / " (int (* duration 1000)) "ms")
                          10.0 55.0 [0.8 0.8 0.8] 1280 720)
        (text/render-text (str "Joints: " (:num-joints state))
                          10.0 80.0 [0.8 0.8 0.8] 1280 720)
        (text/render-text "[1-4: Switch animation | ESC: Exit]"
                          10.0 105.0 [0.6 0.6 0.6] 1280 720)

        (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
        (cpp/glfwPollEvents)))

    (cpp/glfwTerminate)
    (println "Done.")))

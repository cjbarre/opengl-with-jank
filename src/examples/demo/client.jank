(ns examples.demo.client
  "Networked game client for the demo.

   Features:
   - Client-side prediction for local player (instant response)
   - Snapshot interpolation for remote players (smooth motion)
   - Server reconciliation (correct prediction errors)"
  (:require [engine.networking.protocol :as net]
            [examples.demo.networking.snapshot :as snapshot]
            [examples.demo.networking.interpolation :as interp]
            [examples.demo.networking.prediction :as pred]
            [examples.demo.shared :as shared]
            [engine.io.interface :as io]
            [engine.shaders.interface :as shaders]
            [engine.math.interface :as math]
            [engine.3d.gltf.interface :as gltf]
            [engine.3d.collision.interface :as collision]
            [engine.2d.text.interface :as text]
            [engine.2d.graphics.interface :as gfx2d]
            [engine.3d.animation.interface :as anim]
            [examples.demo.animation.jka :as jka]
            [examples.demo.strafehelper.interface :as strafehelper]
            [engine.gl.constants :as gl]))

(cpp/raw "#include \"gl_wrappers.h\"
#include <GLFW/glfw3.h>
#include <cstdio>

// GLEW initialization for Linux - must be called after glfwMakeContextCurrent
inline bool init_glew_client() {
#ifndef __APPLE__
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK) {
        fprintf(stderr, \"GLEW initialization failed: %s\\n\", glewGetErrorString(err));
        return false;
    }
    // Clear any GL errors from glewInit (common issue)
    while (glGetError() != GL_NO_ERROR) {}
    return true;
#else
    return true;
#endif
}")
(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>")
(cpp/raw "#include <math.h>")
(cpp/raw "#include <vector>")

;; Shared animation types header for AOT
(cpp/raw "#include \"animation_types.h\"")
(cpp/raw "#include \"gl_utils.h\"")

;; Line rendering helpers for skeleton visualization
(cpp/raw "
  inline GLuint compile_shader_client(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);
    return shader;
  }

  inline GLuint create_line_shader_client(const char* vs, const char* gs, const char* fs) {
    GLuint vert = compile_shader_client(GL_VERTEX_SHADER, vs);
    GLuint geom = compile_shader_client(GL_GEOMETRY_SHADER, gs);
    GLuint frag = compile_shader_client(GL_FRAGMENT_SHADER, fs);
    GLuint prog = glCreateProgram();
    glAttachShader(prog, vert);
    glAttachShader(prog, geom);
    glAttachShader(prog, frag);
    glLinkProgram(prog);
    glDeleteShader(vert);
    glDeleteShader(geom);
    glDeleteShader(frag);
    return prog;
  }

  inline GLuint create_line_vao_client(GLuint* vbo_out) {
    GLuint vao, vbo;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, 128 * 6 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
    *vbo_out = vbo;
    return vao;
  }

  inline void update_line_vbo_client(GLuint vbo, float* vertices, int line_count) {
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, line_count * 6 * sizeof(float), vertices);
  }

  inline float* get_vector_data_client(std::vector<float>* v) {
    return v->data();
  }
")

;; Thick line shader for skeleton visualization using geometry shader
(def line-vertex-shader
  "#version 330 core
   layout (location = 0) in vec3 aPos;
   uniform mat4 model;
   uniform mat4 view;
   out vec3 worldPos;
   void main() {
       vec4 wp = model * vec4(aPos, 1.0);
       worldPos = wp.xyz;
       gl_Position = view * wp;
   }")

(def line-geometry-shader
  "#version 330 core
   layout (lines) in;
   layout (triangle_strip, max_vertices = 4) out;
   uniform mat4 projection;
   uniform float lineWidth;
   in vec3 worldPos[];
   out float edgeDist;
   out float boneHeight;
   void main() {
       vec4 p0 = gl_in[0].gl_Position;
       vec4 p1 = gl_in[1].gl_Position;

       // Calculate line direction in screen space
       vec2 dir = normalize(p1.xy/p1.w - p0.xy/p0.w);
       vec2 normal = vec2(-dir.y, dir.x) * lineWidth * 0.5;

       // Pass bone height for gradient (use average Y)
       float h = (worldPos[0].y + worldPos[1].y) * 0.5;

       // Emit quad vertices
       edgeDist = -1.0; boneHeight = h;
       gl_Position = projection * vec4(p0.xy + normal * p0.w, p0.z, p0.w);
       EmitVertex();

       edgeDist = 1.0; boneHeight = h;
       gl_Position = projection * vec4(p0.xy - normal * p0.w, p0.z, p0.w);
       EmitVertex();

       edgeDist = -1.0; boneHeight = h;
       gl_Position = projection * vec4(p1.xy + normal * p1.w, p1.z, p1.w);
       EmitVertex();

       edgeDist = 1.0; boneHeight = h;
       gl_Position = projection * vec4(p1.xy - normal * p1.w, p1.z, p1.w);
       EmitVertex();

       EndPrimitive();
   }")

(def line-fragment-shader
  "#version 330 core
   out vec4 FragColor;
   uniform vec3 lineColor;
   uniform vec3 lineColor2;
   in float edgeDist;
   in float boneHeight;
   void main() {
       // Gradient based on bone height (feet to head)
       float t = clamp(boneHeight * 0.5 + 0.5, 0.0, 1.0);
       vec3 color = mix(lineColor, lineColor2, t);

       // Soft edge falloff for anti-aliasing
       float alpha = 1.0 - smoothstep(0.7, 1.0, abs(edgeDist));

       // Slight glow at center
       float glow = 1.0 + 0.3 * (1.0 - abs(edgeDist));
       FragColor = vec4(color * glow, alpha);
   }")

;; C++ helper for identity bones (same as core.jank)
(cpp/raw
 "inline void client_upload_identity_bones(GLint loc, int count) {
    std::vector<float> identity_bones(count * 16);
    for (int i = 0; i < count; ++i) {
      identity_bones[i*16 + 0] = 1.0f;
      identity_bones[i*16 + 5] = 1.0f;
      identity_bones[i*16 + 10] = 1.0f;
      identity_bones[i*16 + 15] = 1.0f;
    }
    glUniformMatrix4fv(loc, count, GL_FALSE, identity_bones.data());
  }")

(cpp/raw
 "inline void framebuffer_size_callback_client(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

;; =============================================================================
;; Constants (GLFW constants from engine.gl.constants)
;; =============================================================================

(def DEFAULT_SERVER_ADDRESS "127.0.0.1")
(def DEFAULT_SERVER_PORT 7777)


;; =============================================================================
;; Animation System
;; =============================================================================

(defn init-player-animation
  "Initialize JKA player animation system for line skeleton rendering"
  []
  (println "Initializing JKA player animation...")
  (let [ctx (anim/create-context)
        base-path "models/player/jka/"

        ;; Load JKA skeleton
        skeleton-info (anim/load-skeleton {:path (str base-path "humanoid.ozz")
                                           :context ctx})
        _ (println "  Skeleton loaded:" (:num-joints skeleton-info) "joints")

        ;; Load JKA movement animations
        anim-data (jka/load-jka-animations ctx base-path)
        _ (println "  Animations loaded:" (count (:indices anim-data)))

        ;; Sample initial animation
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})

        ;; Create JKA animation state
        jka-state (jka/create-jka-state)]

    (println "  Ready for line skeleton rendering!")
    {:animation/context ctx
     :animation/indices (:indices anim-data)
     :animation/durations (:durations anim-data)
     :animation/jka-state jka-state
     :animation/time 0.0
     :num-joints (:num-joints skeleton-info)}))

(defn init-remote-player-animation
  "Initialize JKA animation context for a remote player."
  []
  (let [ctx (anim/create-context)
        base-path "models/player/jka/"

        ;; Load JKA skeleton
        _ (anim/load-skeleton {:path (str base-path "humanoid.ozz")
                               :context ctx})

        ;; Load JKA movement animations
        anim-data (jka/load-jka-animations ctx base-path)

        ;; Sample initial animation
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})

        ;; Create JKA animation state
        jka-state (jka/create-jka-state)]

    {:animation/context ctx
     :animation/indices (:indices anim-data)
     :animation/durations (:durations anim-data)
     :animation/jka-state jka-state}))

(defn ensure-remote-player-anim
  "Ensure a remote player has an animation context.
   Returns updated remote-players map."
  [remote-players entity-id]
  (if (contains? remote-players entity-id)
    remote-players
    (do
      (println "Creating animation context for remote player:" entity-id)
      (assoc remote-players entity-id
             (assoc (init-remote-player-animation) :animation/time 0.0)))))

(defn update-remote-player-animation
  "Update a remote player's animation based on their velocity/grounded state.
   Returns updated anim-data with new animation time."
  [anim-data velocity grounded delta-time]
  (let [[vx _ vz] velocity
        horiz-speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                     (cpp/* (cpp/float vz) (cpp/float vz))))
        is-moving (and grounded (> horiz-speed 0.5))
        current-time (double (or (:animation/time anim-data) 0.0))
        run-duration (double (or (:animation/duration anim-data) 1.0))]
    (cond
      ;; In air - show crouch animation held at 30%
      (not grounded)
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 1  ; crouch
                      :time-ratio 0.3})
        (assoc anim-data :animation/time 0.0 :animation/current-index 1))

      ;; On ground and moving - play run animation
      is-moving
      (let [new-time (mod (+ current-time (* delta-time (/ horiz-speed 8.0))) run-duration)
            time-ratio (/ new-time run-duration)]
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio time-ratio})
        (assoc anim-data :animation/time new-time :animation/current-index 0))

      ;; On ground idle - hold at run frame 0
      :else
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio 0.0})
        (assoc anim-data :animation/time 0.0 :animation/current-index 0)))))

(defn render-skeleton-entity
  "Render a player entity as line skeleton at the given position.
   Applies JKA-style lean based on strafe input."
  [line-shader line-vao line-vbo anim-data position yaw input]
  (let [[px py pz] position
        ctx (:animation/context anim-data)
        ;; Lean based on strafe input keys directly
        ;; Left strafe = lean left (negative roll), Right strafe = lean right (positive roll)
        lean-amount (cond
                      (:left input) -12.0
                      (:right input) 12.0
                      :else 0.0)]
    ;; Set model matrix (offset Y by 0.5 to align with ground)
    (let [model-m (-> (cpp/identity_matrix)
                      (cpp/glm.translate (math/gimmie :vec3 [px (+ py 0.5) pz]))
                      (cpp/glm.rotate (cpp/glm.radians (cpp/float (- 90.0 yaw)))
                                      (math/gimmie :vec3 [0.0 1.0 0.0]))
                      ;; Apply lean (roll around forward axis)
                      (cpp/glm.rotate (cpp/glm.radians (cpp/float lean-amount))
                                      (math/gimmie :vec3 [0.0 0.0 1.0])))
          model-m-loc (cpp/wrap_glGetUniformLocation line-shader "model")]
      (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE
                              (cpp/glm.value_ptr model-m)))
    ;; Build skeleton lines from animation context
    (let [lines-data (anim/build-skeleton-lines {:context ctx :max-lines 128})
          line-count (int (:line-count lines-data))
          verts-box (:vertices lines-data)
          verts-ptr (cpp/get_vector_data_client (cpp/unbox (cpp/type "std::vector<float>*") verts-box))]
      ;; Update VBO with line vertices
      (cpp/update_line_vbo_client line-vbo verts-ptr (cpp/int line-count))
      ;; Draw lines
      (cpp/wrap_glBindVertexArray line-vao)
      (cpp/wrap_glDrawArrays gl/GL_LINES 0 (cpp/* (cpp/int line-count) (cpp/int 2)))
      (cpp/wrap_glBindVertexArray 0))))

(defn update-player-animation
  "Update JKA animation state machine based on input keys and grounded state.
   Input should include: forward, backward, left, right, jump-held, crouch, speed, height, grounded
   Optional: wall-left, wall-right, wall-front (for wall mechanics)"
  [anim-data input grounded delta-time]
  (let [;; Get current JKA state
        jka-state (or (:animation/jka-state anim-data) (jka/create-jka-state))
        indices (:animation/indices anim-data {})
        durations (:animation/durations anim-data {})

        ;; Input already has :grounded from caller, just use it directly
        ;; The caller (update loop) now builds the complete input with speed, height, etc.

        ;; Update JKA state machine
        new-jka-state (jka/update-jka-state jka-state input delta-time durations)

        ;; Get animation index and time ratio
        anim-name (:current-anim new-jka-state)
        anim-index (get indices anim-name 0)
        time-ratio (jka/get-time-ratio new-jka-state durations)]

    ;; Sample animation
    (anim/sample {:context (:animation/context anim-data)
                  :animation-index anim-index
                  :time-ratio time-ratio})

    ;; Return updated anim-data
    (assoc anim-data :animation/jka-state new-jka-state)))

;; =============================================================================
;; Client State
;; =============================================================================

(defn make-client-state
  "Create initial client state."
  []
  {:my-player-id nil               ; Our player ID (assigned by server)
   :connected? false
   :interp-state (interp/make-interp-state)
   :pred-state (pred/make-prediction-state)
   :remote-players {}              ; player-id -> animation data
   :level-collision nil
   :debug/overlay-visible true
   :strafehelper/visible false
   :f3-was-pressed false
   :f4-was-pressed false})

;; =============================================================================
;; Window Setup
;; =============================================================================

(defn setup-window
  [{:keys [width height name]}]
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MAJOR 3)
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MINOR 3)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_PROFILE
                      gl/GLFW_OPENGL_CORE_PROFILE)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_FORWARD_COMPAT
                      gl/GL_TRUE)

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    ;; Initialize GLEW for Linux (no-op on macOS)
    (when (cpp/! (cpp/init_glew_client))
      (println "GLEW initialization failed")
      (cpp/exit 1))
    (cpp/glfwSwapInterval 0)
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback_client)
    (cpp/wrap_glEnable gl/GL_DEPTH_TEST)
    (cpp/box window)))

;; =============================================================================
;; Input Processing
;; =============================================================================

(defn process-input
  "Get current input state."
  [{:keys [window delta-time cursor/pitch cursor/yaw]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cond-> {:delta-time (float (math/*-> :float delta-time))
             :pitch (float (math/*-> :float pitch))
             :yaw (float (math/*-> :float yaw))}
      (= (cpp/glfwGetKey window gl/GLFW_KEY_ESCAPE) gl/GLFW_PRESS)
      (assoc :exit true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_W) gl/GLFW_PRESS)
      (assoc :forward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_S) gl/GLFW_PRESS)
      (assoc :backward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_A) gl/GLFW_PRESS)
      (assoc :left true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_D) gl/GLFW_PRESS)
      (assoc :right true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_SPACE) gl/GLFW_PRESS)
      (assoc :jump-held true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_LEFT_CONTROL) gl/GLFW_PRESS)
      (assoc :crouch true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F3) gl/GLFW_PRESS)
      (assoc :f3-pressed true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F4) gl/GLFW_PRESS)
      (assoc :f4-pressed true))))

;; =============================================================================
;; Cursor / Time Updates
;; =============================================================================

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)
        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y))
        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)
        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))
        cursor-sensitivity (math/*-> :float sensitivity)
        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)
        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]
    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/- cursor-pitch y-offset))
    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)
    (when (cpp/> cursor-pitch (cpp/float 60.0))
      (cpp/= cursor-pitch (cpp/float 60.0)))
    (when (cpp/< cursor-pitch (cpp/float -30.0))
      (cpp/= cursor-pitch (cpp/float -30.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

;; =============================================================================
;; Network Message Handling
;; =============================================================================

(defn handle-welcome
  "Handle welcome message from server."
  [client-state msg]
  (println "Received welcome! My player ID:" (:your-player-id msg))
  (-> client-state
      (assoc :my-player-id (:your-player-id msg))
      (assoc :connected? true)))

(defn handle-snapshot
  "Handle snapshot from server."
  [client-state snapshot collision-mesh]
  (let [{:keys [my-player-id pred-state interp-state]} client-state]
    (if my-player-id
      (let [;; NOTE: Full reconciliation disabled - causes rubber-banding due to
            ;; timing mismatch between client prediction and server simulation.
            ;; For now, just remove acknowledged commands and trust local prediction.
            ;; TODO: Fix reconciliation with better state comparison or dead reckoning.
            ack-sequence (get-in snapshot [:last-processed-commands my-player-id] 0)
            new-pred-state (pred/remove-acknowledged-commands pred-state ack-sequence)
            ;; Add snapshot to interpolation buffer (for remote players)
            new-interp-state (interp/add-snapshot interp-state snapshot)]
        (-> client-state
            (assoc :pred-state new-pred-state)
            (assoc :interp-state new-interp-state)))
      ;; Not yet assigned a player ID
      (update client-state :interp-state interp/add-snapshot snapshot))))

(defn handle-player-spawned
  "Handle player spawn event."
  [client-state msg]
  (println "Player spawned:" (:player-id msg))
  client-state)

(defn handle-player-disconnected
  "Handle player disconnect event."
  [client-state msg]
  (println "Player disconnected:" (:player-id msg))
  (update client-state :remote-players dissoc (:player-id msg)))

(defn handle-network-message
  "Handle a network message."
  [client-state msg collision-mesh]
  (case (:type msg)
    :event
    (case (:event/type msg)
      :client/welcome (handle-welcome client-state msg)
      :player/spawned (handle-player-spawned client-state msg)
      :player/disconnected (handle-player-disconnected client-state msg)
      client-state)

    :snapshot
    (handle-snapshot client-state msg collision-mesh)

    client-state))

;; =============================================================================
;; Rendering
;; =============================================================================

(defn render-entity-at-position
  "Render an entity at a given position/angles."
  [shader position yaw model]
  (let [[px py pz] position
        model-m (-> (cpp/identity_matrix)
                    (cpp/glm.translate (math/gimmie :vec3 [px py pz]))
                    (cpp/glm.rotate (cpp/glm.radians (cpp/float (- yaw)))
                                    (math/gimmie :vec3 [0.0 1.0 0.0])))
        model-m-loc (cpp/wrap_glGetUniformLocation shader "model")]
    (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE
                            (cpp/glm.value_ptr model-m))
    (when model
      ((:draw model) {:shader shader :model/local-matrix-uniform "local"}))))

(defn render-camera
  "Set up camera view based on player position."
  [shader position yaw pitch]
  (let [[px py pz] position
        distance 2.5
        height 1.0
        look-offset 1.2
        yaw-rad (cpp/glm.radians (cpp/float yaw))
        pitch-rad (cpp/glm.radians (cpp/float pitch))
        offset-x (cpp/* (cpp/- (cpp/float 0.0) (cpp/cos yaw-rad))
                        (cpp/* (cpp/float distance) (cpp/cos pitch-rad)))
        offset-z (cpp/* (cpp/- (cpp/float 0.0) (cpp/sin yaw-rad))
                        (cpp/* (cpp/float distance) (cpp/cos pitch-rad)))
        offset-y (cpp/+ (cpp/float height)
                        (cpp/* (cpp/float distance) (cpp/sin pitch-rad)))
        camera-pos (cpp/glm.vec3
                    (cpp/+ (cpp/float px) offset-x)
                    (cpp/+ (cpp/float py) offset-y)
                    (cpp/+ (cpp/float pz) offset-z))
        look-target (cpp/glm.vec3 (cpp/float px)
                                  (cpp/+ (cpp/float py) (cpp/float look-offset))
                                  (cpp/float pz))
        camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))
        view-m (cpp/glm.lookAt camera-pos look-target camera-up)
        view-m-loc (cpp/wrap_glGetUniformLocation shader "view")]
    (cpp/wrap_glUniformMatrix4fv view-m-loc (cpp/int 1) gl/GL_FALSE
                            (cpp/glm.value_ptr view-m))))

(defn draw-world
  "Draw the game world."
  [{:keys [shader line-shader line-vao line-vbo level-model player-anim-data client-state delta-time input] :as context}]
  (cpp/wrap_glClearColor 0.2 0.3 0.3 1.0)
  (cpp/wrap_glClear gl/GL_COLOR_DEPTH_BUFFER_BITS)

  (let [projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))]
    ;; Render level with basic shader
    (cpp/wrap_glUseProgram shader)
    (let [projection-m-loc (cpp/wrap_glGetUniformLocation shader "projection")]
      (cpp/wrap_glUniformMatrix4fv projection-m-loc (cpp/int 1) gl/GL_FALSE
                              (cpp/glm.value_ptr projection-m)))

    ;; Get local player state for camera
    (let [state @client-state
          pred-state (:pred-state state)
          my-id (:my-player-id state)
          render-state (pred/get-render-state pred-state)
          local-pos (or (:position render-state) [0.0 50.0 0.0])
          local-yaw (or (:yaw render-state) 0.0)
          local-pitch (or (:pitch render-state) 0.0)]

      ;; Set up camera from local player
      (render-camera shader local-pos local-yaw local-pitch)

      ;; Render level
      (when level-model
        (let [model-m-loc (cpp/wrap_glGetUniformLocation shader "model")]
          (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE
                                  (cpp/glm.value_ptr (cpp/identity_matrix))))
        ((:draw level-model) {:shader shader :model/local-matrix-uniform "local"}))

      ;; Switch to line shader for player skeleton rendering
      (cpp/wrap_glUseProgram line-shader)
      (let [projection-m-loc (cpp/wrap_glGetUniformLocation line-shader "projection")]
        (cpp/wrap_glUniformMatrix4fv projection-m-loc (cpp/int 1) gl/GL_FALSE
                                (cpp/glm.value_ptr projection-m)))
      ;; Set line width (in normalized device coords, ~0.01-0.05 looks good)
      (cpp/wrap_glUniform1f (cpp/wrap_glGetUniformLocation line-shader "lineWidth") 0.025)
      ;; Set line colors: cyan at feet, bright teal at head
      (cpp/wrap_glUniform3f (cpp/wrap_glGetUniformLocation line-shader "lineColor") 0.0 0.8 0.6)
      (cpp/wrap_glUniform3f (cpp/wrap_glGetUniformLocation line-shader "lineColor2") 0.2 1.0 0.9)
      ;; Enable blending for soft edges
      (cpp/glEnable (cpp/int 0x0BE2))  ;; GL_BLEND
      (cpp/glBlendFunc (cpp/int 0x0302) (cpp/int 0x0303))  ;; GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
      ;; Set camera for line shader
      (render-camera line-shader local-pos local-yaw local-pitch)

      ;; Render local player (line skeleton)
      (when player-anim-data
        (render-skeleton-entity line-shader line-vao line-vbo @player-anim-data local-pos local-yaw input))

      ;; Render remote players (interpolated, line skeleton)
      (let [interp-state (:interp-state state)
            remote-entities (interp/get-all-entity-render-states interp-state)]
        (doseq [[entity-id entity-state] remote-entities]
          (when (not= entity-id my-id)
            (let [pos (:lerp-origin entity-state)
                  [_pitch yaw] (:lerp-angles entity-state)]
              ;; Ensure this remote player has an animation context
              (when-not (contains? (:remote-players @client-state) entity-id)
                (swap! client-state update :remote-players ensure-remote-player-anim entity-id))
              ;; Get the animation context and render
              (when-let [remote-anim (get (:remote-players @client-state) entity-id)]
                (when pos
                  ;; Use interpolated animation state from server (synchronized with position)
                  (let [anim-name (or (:animation-name entity-state) "BOTH_STAND1")
                        anim-index (get (:animation/indices remote-anim) anim-name 0)
                        anim-time (or (:animation-time entity-state) 0.0)
                        durations (:animation/durations remote-anim {})
                        duration (get durations anim-name 1.0)
                        time-ratio (/ anim-time duration)]
                    ;; Sample at interpolated time
                    (anim/sample {:context (:animation/context remote-anim)
                                  :animation-index anim-index
                                  :time-ratio time-ratio})
                    ;; Remote players don't have input, so no lean
                    (render-skeleton-entity line-shader line-vao line-vbo remote-anim pos (or yaw 0.0) {}))))))))

      ;; Disable blending after skeleton rendering
      (cpp/glDisable (cpp/int 0x0BE2)))))  ;; GL_BLEND

;; =============================================================================
;; Main Client Loop
;; =============================================================================

(defn run-client-loop
  [{:keys [window network client-state delta-time gfx2d] :as context}]
  (println "Entering client loop")
  (while (and (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
              (net/connected? network))

    (let [_ (update-time context)
          _ (update-cursor context)
          dt (math/*-> :float delta-time)
          dt-ms (* dt 1000.0)]

      ;; Process network events
      (let [events (net/poll-events! network 0)]
        (doseq [event events]
          (case (:type event)
            :message
            (swap! client-state handle-network-message
                   (:message event) (:level-collision @client-state))

            :disconnect
            (do (println "Disconnected from server")
                (swap! client-state assoc :connected? false))

            nil)))

      ;; Get input
      (let [input (process-input context)
            state @client-state]

        ;; Handle exit
        (when (:exit input)
          (cpp/glfwSetWindowShouldClose
           (cpp/unbox cpp/GLFWwindow* window) 1))

        ;; Handle debug toggles
        (when (and (:f3-pressed input) (not (:f3-was-pressed state)))
          (swap! client-state update :debug/overlay-visible not))
        (swap! client-state assoc :f3-was-pressed (:f3-pressed input))

        (when (and (:f4-pressed input) (not (:f4-was-pressed state)))
          (swap! client-state update :strafehelper/visible not))
        (swap! client-state assoc :f4-was-pressed (:f4-pressed input))

        ;; If connected and have player ID, predict and send commands
        (when (and (:connected? state) (:my-player-id state))
          (let [physics-fn (fn [phys-state inp dt-val]
                             (shared/simulate-physics phys-state inp dt-val
                                                      (:level-collision state)))
                cmd-input (shared/command->input input)
                cmd-input (assoc cmd-input
                                 :pitch (:pitch input)
                                 :yaw (:yaw input))]
            ;; Run prediction
            (swap! client-state update :pred-state
                   pred/predict cmd-input physics-fn dt)

            ;; Send command to server
            (let [new-state @client-state
                  seq-num (dec (:next-sequence (:pred-state new-state)))]
              (net/send! network
                         {:message {:type :command
                                    :command (snapshot/make-input-command
                                              {:client-id (:my-player-id state)
                                               :sequence seq-num
                                               :forward (:forward input)
                                               :backward (:backward input)
                                               :left (:left input)
                                               :right (:right input)
                                               :jump-held (:jump-held input)
                                               :pitch (:pitch input)
                                               :yaw (:yaw input)
                                               :delta-time dt})}
                          :reliable false}))))

        ;; Update interpolation for remote players
        (swap! client-state update :interp-state interp/update-interpolation dt-ms)

        ;; Update prediction error smoothing
        (swap! client-state update :pred-state pred/update-error-smoothing dt-ms)

        ;; Update player animation (use input keys directly for animation selection)
        (when-let [anim-data-atom (:player-anim-data context)]
          (let [render-state (pred/get-render-state (:pred-state @client-state))
                velocity (or (:velocity render-state) [0.0 0.0 0.0])
                position (or (:position render-state) [0.0 0.0 0.0])
                [vx vy vz] velocity
                [_ py _] position
                ;; Calculate horizontal speed
                speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                       (cpp/* (cpp/float vz) (cpp/float vz))))
                ;; Determine grounded: use physics state if available, otherwise infer from velocity
                grounded (if (contains? render-state :grounded?)
                           (:grounded? render-state)
                           ;; If no grounded info, infer: grounded if not moving vertically
                           (< (abs vy) 0.1))
                ;; Build enhanced input for animation state machine
                ;; vy is used for glide detection: glide only when falling (vy <= 0) and not holding jump
                anim-input (assoc input
                                  :speed (double speed)
                                  :height (double py)
                                  :vy (double vy)
                                  :grounded grounded)]
            (swap! anim-data-atom update-player-animation anim-input grounded dt)))

        ;; Render (pass input for lean effect)
        (draw-world (assoc context :input input)))

      ;; Render debug overlay
      (when (:debug/overlay-visible @client-state)
        (let [state @client-state
              pred-state (:pred-state state)
              render-state (pred/get-render-state pred-state)
              [px py pz] (or (:position render-state) [0.0 0.0 0.0])
              [vx vy vz] (or (:velocity render-state) [0.0 0.0 0.0])
              grounded (or (:grounded? render-state) false)
              dt (math/*-> :float delta-time)
              fps (if (> dt 0.0) (/ 1.0 dt) 0.0)
              speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                     (cpp/* (cpp/float vz) (cpp/float vz))))]
          (text/render-text (str "FPS: " (int fps)) 10.0 30.0 [1.0 1.0 1.0] 1280 720)
          (text/render-text (str "Pos: " (int px) ", " (int py) ", " (int pz))
                            10.0 55.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Vel: " (int vx) ", " (int vy) ", " (int vz))
                            10.0 80.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Speed: " (int speed)) 10.0 105.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Grounded: " grounded) 10.0 130.0
                            (if grounded [0.5 1.0 0.5] [1.0 0.5 0.5]) 1280 720)
          (text/render-text "[NETWORKED]" 10.0 155.0 [0.5 0.8 1.0] 1280 720)))

      ;; Render strafehelper
      (when (:strafehelper/visible @client-state)
        (let [state @client-state
              pred-state (:pred-state state)
              render-state (pred/get-render-state pred-state)
              velocity (or (:velocity render-state) [0.0 0.0 0.0])
              yaw (or (:yaw render-state) 0.0)
              grounded (or (:grounded? render-state) false)]
          (strafehelper/render-strafehelper gfx2d velocity yaw grounded 1280 720)))

      (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
      (cpp/glfwPollEvents))))

;; =============================================================================
;; Entry Point
;; =============================================================================

(cpp/raw "
  #include <string>
  #include <cstdlib>

  inline std::string parse_host(const char* addr) {
    std::string s(addr);
    // Strip tcp:// prefix
    if (s.rfind(\"tcp://\", 0) == 0) s = s.substr(6);
    // Find last colon for port
    auto pos = s.rfind(':');
    if (pos != std::string::npos) {
      return s.substr(0, pos);
    }
    return s;
  }

  inline int parse_port(const char* addr, int default_port) {
    std::string s(addr);
    if (s.rfind(\"tcp://\", 0) == 0) s = s.substr(6);
    auto pos = s.rfind(':');
    if (pos != std::string::npos) {
      return std::atoi(s.substr(pos + 1).c_str());
    }
    return default_port;
  }
")

(defn run-client
  "Run the game client."
  ([] (run-client DEFAULT_SERVER_ADDRESS))
  ([server-address]
   (let [host (str (cpp/parse_host server-address))
         port (cpp/parse_port server-address DEFAULT_SERVER_PORT)]
     (println "Starting demo client, connecting to" host ":" port "...")

   (let [_ (cpp/glfwInit)
         window (setup-window {:width 1280 :height 720 :name "Demo - Client"})
         _ (cpp/glfwSetInputMode
            (cpp/unbox cpp/GLFWwindow* window)
            gl/GLFW_CURSOR
            gl/GLFW_CURSOR_DISABLED)

         ;; Load shaders
         shader (shaders/load-shader-program
                 {:vertex-shader-path "shaders/basic_vertex.glsl"
                  :fragment-shader-path "shaders/basic_fragment.glsl"})
         _ (cpp/wrap_glUseProgram shader)
         _ (cpp/wrap_glUniform1i (cpp/wrap_glGetUniformLocation shader "uBaseColorTex") (cpp/int 0))

         ;; Line shader for skeleton rendering (with geometry shader for thick lines)
         line-shader (cpp/create_line_shader_client line-vertex-shader line-geometry-shader line-fragment-shader)
         line-vbo-ptr (cpp/new cpp/GLuint)
         line-vao (cpp/create_line_vao_client line-vbo-ptr)
         line-vbo (cpp/* line-vbo-ptr)

         text-shader (shaders/load-shader-program
                      {:vertex-shader-path "shaders/text_vertex.glsl"
                       :fragment-shader-path "shaders/text_fragment.glsl"})
         _ (text/init-font "fonts/JetBrainsMono-Regular.ttf" 24.0 text-shader)

         graphics2d-shader (shaders/load-shader-program
                            {:vertex-shader-path "shaders/graphics2d_vertex.glsl"
                             :fragment-shader-path "shaders/graphics2d_fragment.glsl"})
         gfx2d (gfx2d/init-graphics2d graphics2d-shader)

         ;; Load level
         level-loaded (gltf/load {:model (gltf/parse {:path "models/hills.gltf"})
                                  :base-path "models/"})
         level-collision (when-let [col (first (:collision level-loaded))]
                          (collision/prepare-collision-mesh col))

         ;; Initialize player animation
         player-anim-data (init-player-animation)

         ;; Create client state
         client-state (atom (-> (make-client-state)
                                (assoc :level-collision level-collision)))

         ;; Connect to server
         network (net/start-client {:address host :port port})]

     (if (nil? network)
       (println "ERROR: Failed to create client")

       (do
         (println "Connecting...")
         (if (net/wait-for-connection! network 5000)
           (do
             (println "Connected to server!")

             ;; Process any events received during connection (e.g., welcome message)
             (let [events (net/poll-events! network 100)]
               (doseq [event events]
                 (when (= :message (:type event))
                   (swap! client-state handle-network-message
                          (:message event) level-collision))))

             (run-client-loop
              {:window window
               :network network
               :client-state client-state
               :shader shader
               :line-shader line-shader
               :line-vao line-vao
               :line-vbo line-vbo
               :level-model level-loaded
               :player-anim-data (atom player-anim-data)
               :gfx2d gfx2d
               :delta-time (math/gimmie :boxed :float 0.0)
               :last-frame (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x (math/gimmie :boxed :float 400.0)
               :cursor/last-y (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity (math/gimmie :boxed :float 0.05)
               :cursor/pitch (math/gimmie :boxed :float 0.0)
               :cursor/yaw (math/gimmie :boxed :float -90.0)})

             (net/stop network))

           (do
             (println "ERROR: Connection timed out")
             (net/stop network)))))

     (cpp/glfwTerminate)
     (println "Client finished.")))))

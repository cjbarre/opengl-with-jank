(ns examples.demo.client
  "Networked game client for the demo.

   Features:
   - Client-side prediction for local player (instant response)
   - Snapshot interpolation for remote players (smooth motion)
   - Server reconciliation (correct prediction errors)"
  (:require [engine.networking.protocol :as net]
            [engine.networking.snapshot :as snapshot]
            [engine.networking.interpolation :as interp]
            [engine.networking.prediction :as pred]
            [examples.demo.shared :as shared]
            [engine.io.interface :as io]
            [engine.shaders.interface :as shaders]
            [engine.math.interface :as math]
            [engine.3d.gltf.interface :as gltf]
            [engine.3d.collision.interface :as collision]
            [engine.2d.text.interface :as text]
            [engine.2d.graphics.interface :as gfx2d]
            [engine.3d.animation.interface :as anim]
            [examples.demo.strafehelper.interface :as strafehelper]
            [engine.gl.constants :as gl]))

(cpp/raw "#include <GLFW/glfw3.h>
          extern \"C\" { void glBindVertexArray(GLuint array); }")
(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>")
(cpp/raw "#include <math.h>")
(cpp/raw "#include <vector>")

;; Shared animation types header for AOT
(cpp/raw "#include \"animation_types.h\"")
(cpp/raw "#include \"gl_utils.h\"")

;; C++ helper for identity bones (same as core.jank)
(cpp/raw
 "inline void client_upload_identity_bones(GLint loc, int count) {
    std::vector<float> identity_bones(count * 16);
    for (int i = 0; i < count; ++i) {
      identity_bones[i*16 + 0] = 1.0f;
      identity_bones[i*16 + 5] = 1.0f;
      identity_bones[i*16 + 10] = 1.0f;
      identity_bones[i*16 + 15] = 1.0f;
    }
    glUniformMatrix4fv(loc, count, GL_FALSE, identity_bones.data());
  }")

(cpp/raw
 "inline void framebuffer_size_callback_client(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

;; =============================================================================
;; Constants (GLFW constants from engine.gl.constants)
;; =============================================================================

(def DEFAULT_SERVER_ADDRESS "127.0.0.1")
(def DEFAULT_SERVER_PORT 7777)

;; =============================================================================
;; Animation System
;; =============================================================================

(defn init-player-animation
  "Initialize player animation system with ozz assets"
  []
  (println "Initializing player animation...")
  (let [ctx (anim/create-context)
        skeleton-info (anim/load-skeleton {:path "models/player/mixamo_skeleton.ozz"
                                           :context ctx})
        run-info (anim/load-animation {:path "models/player/run.ozz"
                                       :context ctx})
        jump-info (anim/load-animation {:path "models/player/crouch.ozz"
                                        :context ctx})
        mesh-data (anim/load-meshes {:path "models/player/mixamo_mesh.ozz"})
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})
        mesh-count (:count mesh-data)
        vaos (vec (map (fn [i]
                         (anim/create-skinned-vao {:meshes (:meshes mesh-data)
                                                   :mesh-index i}))
                       (range mesh-count)))]
    (println "  Animation loaded: skeleton=" (:num-joints skeleton-info)
             "meshes=" mesh-count)
    {:animation/context ctx
     :animation/current-index 0
     :animation/duration (:duration run-info)
     :animation/meshes (:meshes mesh-data)
     :animation/mesh-count mesh-count
     :animation/vaos vaos
     :animation/time 0.0}))

(defn init-remote-player-animation
  "Initialize animation context for a remote player.
   Each remote player needs their own ozz context for independent animation sampling."
  []
  (let [ctx (anim/create-context)
        _ (anim/load-skeleton {:path "models/player/mixamo_skeleton.ozz"
                               :context ctx})
        run-info (anim/load-animation {:path "models/player/run.ozz"
                                       :context ctx})
        _ (anim/load-animation {:path "models/player/crouch.ozz"
                                :context ctx})
        mesh-data (anim/load-meshes {:path "models/player/mixamo_mesh.ozz"})
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})
        mesh-count (:count mesh-data)
        vaos (vec (map (fn [i]
                         (anim/create-skinned-vao {:meshes (:meshes mesh-data)
                                                   :mesh-index i}))
                       (range mesh-count)))]
    {:animation/context ctx
     :animation/duration (:duration run-info)
     :animation/meshes (:meshes mesh-data)
     :animation/mesh-count mesh-count
     :animation/vaos vaos}))

(defn ensure-remote-player-anim
  "Ensure a remote player has an animation context.
   Returns updated remote-players map."
  [remote-players entity-id]
  (if (contains? remote-players entity-id)
    remote-players
    (do
      (println "Creating animation context for remote player:" entity-id)
      (assoc remote-players entity-id
             (assoc (init-remote-player-animation) :animation/time 0.0)))))

(defn update-remote-player-animation
  "Update a remote player's animation based on their velocity/grounded state.
   Returns updated anim-data with new animation time."
  [anim-data velocity grounded delta-time]
  (let [[vx _ vz] velocity
        horiz-speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                     (cpp/* (cpp/float vz) (cpp/float vz))))
        is-moving (and grounded (> horiz-speed 0.5))
        current-time (double (or (:animation/time anim-data) 0.0))
        run-duration (double (or (:animation/duration anim-data) 1.0))]
    (cond
      ;; In air - show crouch animation held at 30%
      (not grounded)
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 1  ; crouch
                      :time-ratio 0.3})
        (assoc anim-data :animation/time 0.0 :animation/current-index 1))

      ;; On ground and moving - play run animation
      is-moving
      (let [new-time (mod (+ current-time (* delta-time (/ horiz-speed 8.0))) run-duration)
            time-ratio (/ new-time run-duration)]
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio time-ratio})
        (assoc anim-data :animation/time new-time :animation/current-index 0))

      ;; On ground idle - hold at run frame 0
      :else
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio 0.0})
        (assoc anim-data :animation/time 0.0 :animation/current-index 0)))))

(defn render-animated-entity
  "Render an animated player entity at the given position."
  [skinned-shader anim-data position yaw]
  (let [[px py pz] position
        meshes (:animation/meshes anim-data)
        vaos (:animation/vaos anim-data)
        ctx (:animation/context anim-data)
        mesh-count (:animation/mesh-count anim-data)]
    ;; Set model matrix
    (let [model-m (-> (cpp/identity_matrix)
                      (cpp/glm.translate (math/gimmie :vec3 [px py pz]))
                      (cpp/glm.rotate (cpp/glm.radians (cpp/float (- 90.0 yaw)))
                                      (math/gimmie :vec3 [0.0 1.0 0.0])))
          model-m-loc (cpp/glGetUniformLocation skinned-shader "model")]
      (cpp/glUniformMatrix4fv model-m-loc 1 gl/GL_FALSE
                              (cpp/glm.value_ptr model-m)))
    ;; Set base color
    (cpp/glUniform4f (cpp/glGetUniformLocation skinned-shader "uBaseColorFactor")
                     (cpp/float 0.8) (cpp/float 0.6) (cpp/float 0.5) (cpp/float 1.0))
    (cpp/glUniform1i (cpp/glGetUniformLocation skinned-shader "uHasBaseColorTex") 0)
    ;; Render each mesh
    (doseq [mesh-idx (range mesh-count)]
      (let [loc (cpp/glGetUniformLocation skinned-shader "uBoneMatrices")
            ctx-ptr (cpp/unbox cpp/AnimationContext* ctx)
            meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)]
        (cpp/compute_and_upload_skinning_matrices ctx-ptr meshes-ptr (cpp/int mesh-idx) loc)
        (let [vao-data (nth vaos mesh-idx)
              index-count (:index-count vao-data)]
          (cpp/glBindVertexArray (:vao vao-data))
          (cpp/glDrawElements gl/GL_TRIANGLES
                              index-count
                              gl/GL_UNSIGNED_SHORT
                              cpp/nullptr))))))

(defn update-player-animation
  "Update animation sampling based on velocity and grounded state.
   - In air (not grounded): crouch animation (index 1), held at 30%
   - On ground moving: run animation (index 0), speed based on velocity
   - On ground idle: run animation at frame 0 (standing pose)"
  [anim-data velocity grounded delta-time]
  (let [[vx _ vz] velocity
        horiz-speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                     (cpp/* (cpp/float vz) (cpp/float vz))))
        is-moving (and grounded (> horiz-speed 0.5))
        current-time (double (:animation/time anim-data 0.0))
        run-duration (double (:animation/duration anim-data 1.0))]
    (cond
      ;; In air - show crouch animation held at 30%
      (not grounded)
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 1  ; crouch
                      :time-ratio 0.3})
        (assoc anim-data :animation/time 0.0))

      ;; On ground and moving - play run animation
      is-moving
      (let [new-time (mod (+ current-time (* delta-time (/ horiz-speed 8.0))) run-duration)
            time-ratio (/ new-time run-duration)]
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio time-ratio})
        (assoc anim-data :animation/time new-time))

      ;; On ground idle - hold at run frame 0
      :else
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio 0.0})
        (assoc anim-data :animation/time 0.0)))))

;; =============================================================================
;; Client State
;; =============================================================================

(defn make-client-state
  "Create initial client state."
  []
  {:my-player-id nil               ; Our player ID (assigned by server)
   :connected? false
   :interp-state (interp/make-interp-state)
   :pred-state (pred/make-prediction-state)
   :remote-players {}              ; player-id -> animation data
   :level-collision nil
   :debug/overlay-visible true
   :strafehelper/visible false
   :f3-was-pressed false
   :f4-was-pressed false})

;; =============================================================================
;; Window Setup
;; =============================================================================

(defn setup-window
  [{:keys [width height name]}]
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MAJOR 3)
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MINOR 3)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_PROFILE
                      gl/GLFW_OPENGL_CORE_PROFILE)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_FORWARD_COMPAT
                      gl/GL_TRUE)

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    (cpp/glfwSwapInterval 0)
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback_client)
    (cpp/glEnable gl/GL_DEPTH_TEST)
    (cpp/box window)))

;; =============================================================================
;; Input Processing
;; =============================================================================

(defn process-input
  "Get current input state."
  [{:keys [window delta-time cursor/pitch cursor/yaw]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cond-> {:delta-time (float (math/*-> :float delta-time))
             :pitch (float (math/*-> :float pitch))
             :yaw (float (math/*-> :float yaw))}
      (= (cpp/glfwGetKey window gl/GLFW_KEY_ESCAPE) gl/GLFW_PRESS)
      (assoc :exit true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_W) gl/GLFW_PRESS)
      (assoc :forward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_S) gl/GLFW_PRESS)
      (assoc :backward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_A) gl/GLFW_PRESS)
      (assoc :left true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_D) gl/GLFW_PRESS)
      (assoc :right true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_SPACE) gl/GLFW_PRESS)
      (assoc :jump-held true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F3) gl/GLFW_PRESS)
      (assoc :f3-pressed true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F4) gl/GLFW_PRESS)
      (assoc :f4-pressed true))))

;; =============================================================================
;; Cursor / Time Updates
;; =============================================================================

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)
        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y))
        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)
        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))
        cursor-sensitivity (math/*-> :float sensitivity)
        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)
        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]
    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/- cursor-pitch y-offset))
    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)
    (when (cpp/> cursor-pitch (cpp/float 60.0))
      (cpp/= cursor-pitch (cpp/float 60.0)))
    (when (cpp/< cursor-pitch (cpp/float -30.0))
      (cpp/= cursor-pitch (cpp/float -30.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

;; =============================================================================
;; Network Message Handling
;; =============================================================================

(defn handle-welcome
  "Handle welcome message from server."
  [client-state msg]
  (println "Received welcome! My player ID:" (:your-player-id msg))
  (-> client-state
      (assoc :my-player-id (:your-player-id msg))
      (assoc :connected? true)))

(defn handle-snapshot
  "Handle snapshot from server."
  [client-state snapshot collision-mesh]
  (let [{:keys [my-player-id pred-state interp-state]} client-state]
    (if my-player-id
      (let [;; NOTE: Full reconciliation disabled - causes rubber-banding due to
            ;; timing mismatch between client prediction and server simulation.
            ;; For now, just remove acknowledged commands and trust local prediction.
            ;; TODO: Fix reconciliation with better state comparison or dead reckoning.
            ack-sequence (get-in snapshot [:last-processed-commands my-player-id] 0)
            new-pred-state (pred/remove-acknowledged-commands pred-state ack-sequence)
            ;; Add snapshot to interpolation buffer (for remote players)
            new-interp-state (interp/add-snapshot interp-state snapshot)]
        (-> client-state
            (assoc :pred-state new-pred-state)
            (assoc :interp-state new-interp-state)))
      ;; Not yet assigned a player ID
      (update client-state :interp-state interp/add-snapshot snapshot))))

(defn handle-player-spawned
  "Handle player spawn event."
  [client-state msg]
  (println "Player spawned:" (:player-id msg))
  client-state)

(defn handle-player-disconnected
  "Handle player disconnect event."
  [client-state msg]
  (println "Player disconnected:" (:player-id msg))
  (update client-state :remote-players dissoc (:player-id msg)))

(defn handle-network-message
  "Handle a network message."
  [client-state msg collision-mesh]
  (case (:type msg)
    :event
    (case (:event/type msg)
      :client/welcome (handle-welcome client-state msg)
      :player/spawned (handle-player-spawned client-state msg)
      :player/disconnected (handle-player-disconnected client-state msg)
      client-state)

    :snapshot
    (handle-snapshot client-state msg collision-mesh)

    client-state))

;; =============================================================================
;; Rendering
;; =============================================================================

(defn render-entity-at-position
  "Render an entity at a given position/angles."
  [shader position yaw model]
  (let [[px py pz] position
        model-m (-> (cpp/identity_matrix)
                    (cpp/glm.translate (math/gimmie :vec3 [px py pz]))
                    (cpp/glm.rotate (cpp/glm.radians (cpp/float (- yaw)))
                                    (math/gimmie :vec3 [0.0 1.0 0.0])))
        model-m-loc (cpp/glGetUniformLocation shader "model")]
    (cpp/glUniformMatrix4fv model-m-loc 1 gl/GL_FALSE
                            (cpp/glm.value_ptr model-m))
    (when model
      ((:draw model) {:shader shader :model/local-matrix-uniform "local"}))))

(defn render-camera
  "Set up camera view based on player position."
  [shader position yaw pitch]
  (let [[px py pz] position
        distance 2.5
        height 1.0
        look-offset 1.2
        yaw-rad (cpp/glm.radians (cpp/float yaw))
        pitch-rad (cpp/glm.radians (cpp/float pitch))
        offset-x (cpp/* (cpp/- (cpp/float 0.0) (cpp/cos yaw-rad))
                        (cpp/* (cpp/float distance) (cpp/cos pitch-rad)))
        offset-z (cpp/* (cpp/- (cpp/float 0.0) (cpp/sin yaw-rad))
                        (cpp/* (cpp/float distance) (cpp/cos pitch-rad)))
        offset-y (cpp/+ (cpp/float height)
                        (cpp/* (cpp/float distance) (cpp/sin pitch-rad)))
        camera-pos (cpp/glm.vec3
                    (cpp/+ (cpp/float px) offset-x)
                    (cpp/+ (cpp/float py) offset-y)
                    (cpp/+ (cpp/float pz) offset-z))
        look-target (cpp/glm.vec3 (cpp/float px)
                                  (cpp/+ (cpp/float py) (cpp/float look-offset))
                                  (cpp/float pz))
        camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))
        view-m (cpp/glm.lookAt camera-pos look-target camera-up)
        view-m-loc (cpp/glGetUniformLocation shader "view")]
    (cpp/glUniformMatrix4fv view-m-loc 1 gl/GL_FALSE
                            (cpp/glm.value_ptr view-m))))

(defn draw-world
  "Draw the game world."
  [{:keys [shader skinned-shader level-model player-anim-data client-state delta-time] :as context}]
  (cpp/glClearColor 0.2 0.3 0.3 1.0)
  (cpp/glClear gl/GL_COLOR_DEPTH_BUFFER_BITS)

  (let [projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))]
    ;; Render level with basic shader
    (cpp/glUseProgram shader)
    (let [projection-m-loc (cpp/glGetUniformLocation shader "projection")]
      (cpp/glUniformMatrix4fv projection-m-loc 1 gl/GL_FALSE
                              (cpp/glm.value_ptr projection-m)))

    ;; Get local player state for camera
    (let [state @client-state
          pred-state (:pred-state state)
          my-id (:my-player-id state)
          render-state (pred/get-render-state pred-state)
          local-pos (or (:position render-state) [0.0 50.0 0.0])
          local-yaw (or (:yaw render-state) 0.0)
          local-pitch (or (:pitch render-state) 0.0)]

      ;; Set up camera from local player
      (render-camera shader local-pos local-yaw local-pitch)

      ;; Render level
      (when level-model
        (let [model-m-loc (cpp/glGetUniformLocation shader "model")]
          (cpp/glUniformMatrix4fv model-m-loc 1 gl/GL_FALSE
                                  (cpp/glm.value_ptr (cpp/identity_matrix))))
        ((:draw level-model) {:shader shader :model/local-matrix-uniform "local"}))

      ;; Switch to skinned shader for player
      (cpp/glDisable gl/GL_CULL_FACE)
      (cpp/glUseProgram skinned-shader)
      (let [projection-m-loc (cpp/glGetUniformLocation skinned-shader "projection")]
        (cpp/glUniformMatrix4fv projection-m-loc 1 gl/GL_FALSE
                                (cpp/glm.value_ptr projection-m)))
      ;; Set camera for skinned shader too
      (render-camera skinned-shader local-pos local-yaw local-pitch)

      ;; Render local player (animated)
      (when player-anim-data
        (render-animated-entity skinned-shader @player-anim-data local-pos local-yaw))

      ;; Render remote players (interpolated, animated)
      (let [interp-state (:interp-state state)
            remote-entities (interp/get-all-entity-render-states interp-state)]
        (doseq [[entity-id entity-state] remote-entities]
          (when (not= entity-id my-id)
            (let [pos (:lerp-origin entity-state)
                  [_pitch yaw] (:lerp-angles entity-state)]
              ;; Ensure this remote player has an animation context
              (when-not (contains? (:remote-players @client-state) entity-id)
                (swap! client-state update :remote-players ensure-remote-player-anim entity-id))
              ;; Get the animation context and render
              (when-let [remote-anim (get (:remote-players @client-state) entity-id)]
                (when pos
                  ;; Use interpolated animation state from server (synchronized with position)
                  (let [anim-index (or (:animation-index entity-state) 0)
                        anim-time (or (:animation-time entity-state) 0.0)
                        run-duration (or (:animation/duration remote-anim) 1.0)
                        time-ratio (/ anim-time run-duration)]
                    ;; Sample at interpolated time
                    (anim/sample {:context (:animation/context remote-anim)
                                  :animation-index anim-index
                                  :time-ratio time-ratio})
                    (render-animated-entity skinned-shader remote-anim pos (or yaw 0.0))))))))))))

;; =============================================================================
;; Main Client Loop
;; =============================================================================

(defn run-client-loop
  [{:keys [window network client-state delta-time gfx2d] :as context}]
  (println "Entering client loop")
  (while (and (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
              (net/connected? network))

    (let [_ (update-time context)
          _ (update-cursor context)
          dt (math/*-> :float delta-time)
          dt-ms (* dt 1000.0)]

      ;; Process network events
      (let [events (net/poll-events! network 0)]
        (doseq [event events]
          (case (:type event)
            :message
            (swap! client-state handle-network-message
                   (:message event) (:level-collision @client-state))

            :disconnect
            (do (println "Disconnected from server")
                (swap! client-state assoc :connected? false))

            nil)))

      ;; Get input
      (let [input (process-input context)
            state @client-state]

        ;; Handle exit
        (when (:exit input)
          (cpp/glfwSetWindowShouldClose
           (cpp/unbox cpp/GLFWwindow* window) 1))

        ;; Handle debug toggles
        (when (and (:f3-pressed input) (not (:f3-was-pressed state)))
          (swap! client-state update :debug/overlay-visible not))
        (swap! client-state assoc :f3-was-pressed (:f3-pressed input))

        (when (and (:f4-pressed input) (not (:f4-was-pressed state)))
          (swap! client-state update :strafehelper/visible not))
        (swap! client-state assoc :f4-was-pressed (:f4-pressed input))

        ;; If connected and have player ID, predict and send commands
        (when (and (:connected? state) (:my-player-id state))
          (let [physics-fn (fn [phys-state inp dt-val]
                             (shared/simulate-physics phys-state inp dt-val
                                                      (:level-collision state)))
                cmd-input (shared/command->input input)
                cmd-input (assoc cmd-input
                                 :pitch (:pitch input)
                                 :yaw (:yaw input))]
            ;; Run prediction
            (swap! client-state update :pred-state
                   pred/predict cmd-input physics-fn dt)

            ;; Send command to server
            (let [new-state @client-state
                  seq-num (dec (:next-sequence (:pred-state new-state)))]
              (net/send! network
                         {:message {:type :command
                                    :command (snapshot/make-input-command
                                              {:client-id (:my-player-id state)
                                               :sequence seq-num
                                               :forward (:forward input)
                                               :backward (:backward input)
                                               :left (:left input)
                                               :right (:right input)
                                               :jump-held (:jump-held input)
                                               :pitch (:pitch input)
                                               :yaw (:yaw input)
                                               :delta-time dt})}
                          :reliable false}))))

        ;; Update interpolation for remote players
        (swap! client-state update :interp-state interp/update-interpolation dt-ms)

        ;; Update prediction error smoothing
        (swap! client-state update :pred-state pred/update-error-smoothing dt-ms)

        ;; Update player animation
        (when-let [anim-data-atom (:player-anim-data context)]
          (let [render-state (pred/get-render-state (:pred-state state))
                velocity (or (:velocity render-state) [0.0 0.0 0.0])
                [_ vy _] velocity
                ;; Determine grounded: use physics state if available, otherwise infer from velocity
                grounded (if (contains? render-state :grounded?)
                           (:grounded? render-state)
                           ;; If no grounded info, infer: grounded if not moving vertically
                           (< (abs vy) 0.1))]
            (swap! anim-data-atom update-player-animation velocity grounded dt))))

      ;; Render
      (draw-world context)

      ;; Render debug overlay
      (when (:debug/overlay-visible @client-state)
        (let [state @client-state
              pred-state (:pred-state state)
              render-state (pred/get-render-state pred-state)
              [px py pz] (or (:position render-state) [0.0 0.0 0.0])
              [vx vy vz] (or (:velocity render-state) [0.0 0.0 0.0])
              grounded (or (:grounded? render-state) false)
              dt (math/*-> :float delta-time)
              fps (if (> dt 0.0) (/ 1.0 dt) 0.0)
              speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                     (cpp/* (cpp/float vz) (cpp/float vz))))]
          (text/render-text (str "FPS: " (int fps)) 10.0 30.0 [1.0 1.0 1.0] 1280 720)
          (text/render-text (str "Pos: " (int px) ", " (int py) ", " (int pz))
                            10.0 55.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Vel: " (int vx) ", " (int vy) ", " (int vz))
                            10.0 80.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Speed: " (int speed)) 10.0 105.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Grounded: " grounded) 10.0 130.0
                            (if grounded [0.5 1.0 0.5] [1.0 0.5 0.5]) 1280 720)
          (text/render-text "[NETWORKED]" 10.0 155.0 [0.5 0.8 1.0] 1280 720)))

      ;; Render strafehelper
      (when (:strafehelper/visible @client-state)
        (let [state @client-state
              pred-state (:pred-state state)
              render-state (pred/get-render-state pred-state)
              velocity (or (:velocity render-state) [0.0 0.0 0.0])
              yaw (or (:yaw render-state) 0.0)
              grounded (or (:grounded? render-state) false)]
          (strafehelper/render-strafehelper gfx2d velocity yaw grounded 1280 720)))

      (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
      (cpp/glfwPollEvents))))

;; =============================================================================
;; Entry Point
;; =============================================================================

(defn run-client
  "Run the game client."
  ([] (run-client DEFAULT_SERVER_ADDRESS))
  ([server-address]
   (println "Starting demo client, connecting to" server-address ":" DEFAULT_SERVER_PORT "...")

   (let [_ (cpp/glfwInit)
         window (setup-window {:width 1280 :height 720 :name "Demo - Client"})
         _ (cpp/glfwSetInputMode
            (cpp/unbox cpp/GLFWwindow* window)
            gl/GLFW_CURSOR
            gl/GLFW_CURSOR_NORMAL)

         ;; Load shaders
         shader (shaders/load-shader-program
                 {:vertex-shader-path "shaders/basic_vertex.glsl"
                  :fragment-shader-path "shaders/basic_fragment.glsl"})
         _ (cpp/glUseProgram shader)
         _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "uBaseColorTex") 0)

         ;; Skinned shader for animated player
         skinned-shader (shaders/load-shader-program
                         {:vertex-shader-path "shaders/skinned_vertex.glsl"
                          :fragment-shader-path "shaders/skinned_fragment.glsl"})
         _ (cpp/glUseProgram skinned-shader)
         _ (cpp/glUniform1i (cpp/glGetUniformLocation skinned-shader "uBaseColorTex") 0)

         text-shader (shaders/load-shader-program
                      {:vertex-shader-path "shaders/text_vertex.glsl"
                       :fragment-shader-path "shaders/text_fragment.glsl"})
         _ (text/init-font "fonts/JetBrainsMono-Regular.ttf" 24.0 text-shader)

         graphics2d-shader (shaders/load-shader-program
                            {:vertex-shader-path "shaders/graphics2d_vertex.glsl"
                             :fragment-shader-path "shaders/graphics2d_fragment.glsl"})
         gfx2d (gfx2d/init-graphics2d graphics2d-shader)

         ;; Load level
         level-loaded (gltf/load {:model (gltf/parse {:path "models/hills.gltf"})
                                  :base-path "models/"})
         level-collision (when-let [col (first (:collision level-loaded))]
                          (collision/prepare-collision-mesh col))

         ;; Initialize player animation
         player-anim-data (init-player-animation)

         ;; Create client state
         client-state (atom (-> (make-client-state)
                                (assoc :level-collision level-collision)))

         ;; Connect to server
         network (net/start-client {:address server-address :port DEFAULT_SERVER_PORT})]

     (if (nil? network)
       (println "ERROR: Failed to create client")

       (do
         (println "Connecting...")
         (if (net/wait-for-connection! network 5000)
           (do
             (println "Connected to server!")

             ;; Process any events received during connection (e.g., welcome message)
             (let [events (net/poll-events! network 100)]
               (doseq [event events]
                 (when (= :message (:type event))
                   (swap! client-state handle-network-message
                          (:message event) level-collision))))

             (run-client-loop
              {:window window
               :network network
               :client-state client-state
               :shader shader
               :skinned-shader skinned-shader
               :level-model level-loaded
               :player-anim-data (atom player-anim-data)
               :gfx2d gfx2d
               :delta-time (math/gimmie :boxed :float 0.0)
               :last-frame (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x (math/gimmie :boxed :float 400.0)
               :cursor/last-y (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity (math/gimmie :boxed :float 0.05)
               :cursor/pitch (math/gimmie :boxed :float 0.0)
               :cursor/yaw (math/gimmie :boxed :float -90.0)})

             (net/stop network))

           (do
             (println "ERROR: Connection timed out")
             (net/stop network)))))

     (cpp/glfwTerminate)
     (println "Client finished."))))

(ns examples.demo.client
  "Networked game client for the demo.

   Features:
   - Client-side prediction for local player (instant response)
   - Snapshot interpolation for remote players (smooth motion)
   - Server reconciliation (correct prediction errors)"
  (:require [engine.networking.protocol :as net]
            [examples.demo.networking.snapshot :as snapshot]
            [examples.demo.networking.interpolation :as interp]
            [examples.demo.networking.prediction :as pred]
            [examples.demo.shared :as shared]
            [examples.demo.camera :as camera]
            [engine.io.interface :as io]
            [engine.shaders.interface :as shaders]
            [engine.math.interface :as math]
            [engine.gfx3d.gltf.interface :as gltf]
            [engine.gfx3d.collision.interface :as collision]
            [engine.gfx2d.text.interface :as text]
            [engine.gfx2d.graphics.interface :as gfx2d]
            [engine.gfx3d.animation.interface :as anim]
            [examples.demo.animation.player :as player]
            [examples.demo.strafehelper.interface :as strafehelper]
            [engine.gl.constants :as gl]
            [engine.gl.interface :as gl-state]))

(cpp/raw "#include \"gl_wrappers.h\"
#include <GLFW/glfw3.h>
#include <cstdio>

// GLEW initialization for Linux - must be called after glfwMakeContextCurrent
inline bool init_glew_client() {
#ifndef __APPLE__
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK) {
        fprintf(stderr, \"GLEW initialization failed: %s\\n\", glewGetErrorString(err));
        return false;
    }
    // Clear any GL errors from glewInit (common issue)
    while (glGetError() != GL_NO_ERROR) {}
    return true;
#else
    return true;
#endif
}")
(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>")
(cpp/raw "#include <math.h>")
(cpp/raw "#include <vector>")

;; Shared animation types header for AOT
(cpp/raw "#include \"animation_types.h\"")
(cpp/raw "#include \"gl_utils.h\"")

;; Line rendering helpers for skeleton visualization
(cpp/raw "
  inline GLuint create_line_vao_client(GLuint* vbo_out) {
    GLuint vao, vbo;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, 128 * 6 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
    *vbo_out = vbo;
    return vao;
  }

  inline void update_line_vbo_client(GLuint vbo, float* vertices, int line_count) {
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, line_count * 6 * sizeof(float), vertices);
  }

  inline float* get_vector_data_client(std::vector<float>* v) {
    return v->data();
  }
")

;; C++ helper for identity bones (same as core.jank)
(cpp/raw
 "inline void client_upload_identity_bones(GLint loc, int count) {
    std::vector<float> identity_bones(count * 16);
    for (int i = 0; i < count; ++i) {
      identity_bones[i*16 + 0] = 1.0f;
      identity_bones[i*16 + 5] = 1.0f;
      identity_bones[i*16 + 10] = 1.0f;
      identity_bones[i*16 + 15] = 1.0f;
    }
    glUniformMatrix4fv(loc, count, GL_FALSE, identity_bones.data());
  }")

(cpp/raw
 "inline void framebuffer_size_callback_client(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

;; =============================================================================
;; Constants (GLFW constants from engine.gl.constants)
;; =============================================================================

(def DEFAULT_SERVER_ADDRESS "127.0.0.1")
(def DEFAULT_SERVER_PORT 7777)


;; =============================================================================
;; Animation System
;; =============================================================================

(defn init-player-animation
  "Initialize player animation system for line skeleton rendering"
  []
  (println "Initializing player animation...")
  (let [ctx (anim/create-context)
        base-path "models/player/animations/"

        ;; Load skeleton
        skeleton-info (anim/load-skeleton {:path (str base-path "humanoid.ozz")
                                           :context ctx})
        _ (println "  Skeleton loaded:" (:num-joints skeleton-info) "joints")

        ;; Load movement animations
        anim-data (player/load-player-animations ctx base-path)
        _ (println "  Animations loaded:" (count (:indices anim-data)))

        ;; Sample initial animation
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})

        ;; Create player animation state
        player-state (player/create-player-state)]

    (println "  Ready for line skeleton rendering!")
    {:animation/context ctx
     :animation/indices (:indices anim-data)
     :animation/durations (:durations anim-data)
     :animation/player-state player-state
     :animation/time 0.0
     :num-joints (:num-joints skeleton-info)}))

(defn init-remote-player-animation
  "Initialize animation context for a remote player."
  []
  (let [ctx (anim/create-context)
        base-path "models/player/animations/"

        ;; Load skeleton
        _ (anim/load-skeleton {:path (str base-path "humanoid.ozz")
                               :context ctx})

        ;; Load movement animations
        anim-data (player/load-player-animations ctx base-path)

        ;; Sample initial animation
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})

        ;; Create player animation state
        player-state (player/create-player-state)]

    {:animation/context ctx
     :animation/indices (:indices anim-data)
     :animation/durations (:durations anim-data)
     :animation/player-state player-state}))

(defn ensure-remote-player-anim
  "Ensure a remote player has an animation context.
   Returns updated remote-players map."
  [remote-players entity-id]
  (if (contains? remote-players entity-id)
    remote-players
    (do
      (println "Creating animation context for remote player:" entity-id)
      (assoc remote-players entity-id
             (assoc (init-remote-player-animation) :animation/time 0.0)))))

(defn update-remote-player-animation
  "Update a remote player's animation based on their velocity/grounded state.
   Returns updated anim-data with new animation time."
  [anim-data velocity grounded delta-time]
  (let [[vx _ vz] velocity
        horiz-speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                     (cpp/* (cpp/float vz) (cpp/float vz))))
        is-moving (and grounded (> horiz-speed 0.5))
        current-time (double (or (:animation/time anim-data) 0.0))
        run-duration (double (or (:animation/duration anim-data) 1.0))]
    (cond
      ;; In air - show crouch animation held at 30%
      (not grounded)
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 1  ; crouch
                      :time-ratio 0.3})
        (assoc anim-data :animation/time 0.0 :animation/current-index 1))

      ;; On ground and moving - play run animation
      is-moving
      (let [new-time (mod (+ current-time (* delta-time (/ horiz-speed 8.0))) run-duration)
            time-ratio (/ new-time run-duration)]
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio time-ratio})
        (assoc anim-data :animation/time new-time :animation/current-index 0))

      ;; On ground idle - hold at run frame 0
      :else
      (do
        (anim/sample {:context (:animation/context anim-data)
                      :animation-index 0  ; run
                      :time-ratio 0.0})
        (assoc anim-data :animation/time 0.0 :animation/current-index 0)))))

(defn render-skeleton-entity
  "Render a player entity as line skeleton at the given position.
   Applies lean based on strafe input."
  [line-shader line-vao line-vbo anim-data position yaw input]
  (let [[px py pz] position
        ctx (:animation/context anim-data)
        ;; Lean based on strafe input keys directly
        ;; Left strafe = lean left (negative roll), Right strafe = lean right (positive roll)
        lean-amount (cond
                      (:left input) -12.0
                      (:right input) 12.0
                      :else 0.0)]
    ;; Set model matrix (offset Y by 0.5 to align with ground)
    (let [model-m (-> (cpp/identity_matrix)
                      (cpp/glm.translate (math/gimmie :vec3 [px (+ py 0.5) pz]))
                      (cpp/glm.rotate (cpp/glm.radians (cpp/float (- 90.0 yaw)))
                                      (math/gimmie :vec3 [0.0 1.0 0.0]))
                      ;; Apply lean (roll around forward axis)
                      (cpp/glm.rotate (cpp/glm.radians (cpp/float lean-amount))
                                      (math/gimmie :vec3 [0.0 0.0 1.0])))
          model-m-loc (cpp/wrap_glGetUniformLocation line-shader "model")
          _ (do (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE
                                        (cpp/glm.value_ptr model-m)) nil)]
      nil)
    ;; Build skeleton lines from animation context
    (let [skeleton-lines (anim/build-skeleton-lines {:context ctx :max-lines 128})
          line-count (int (:line-count skeleton-lines))
          verts-box (:vertices skeleton-lines)
          verts-ptr (cpp/get_vector_data_client (cpp/unbox (cpp/type "std::vector<float>*") verts-box))
          ;; Update VBO with line vertices
          _ (do (cpp/update_line_vbo_client line-vbo verts-ptr (cpp/int line-count)) nil)
          ;; Draw lines
          _ (do (cpp/wrap_glBindVertexArray line-vao) nil)
          _ (do (cpp/wrap_glDrawArrays gl/GL_LINES (cpp/int 0) (cpp/* (cpp/int line-count) (cpp/int 2))) nil)
          _ (do (cpp/wrap_glBindVertexArray (cpp/int 0)) nil)]
      nil)))

(defn update-player-animation
  "Update player animation state machine based on input keys and grounded state.
   Input should include: forward, backward, left, right, jump-held, crouch, speed, height, grounded
   Optional: wall-left, wall-right, wall-front (for wall mechanics)"
  [anim-data input grounded delta-time]
  (let [;; Get current player state
        player-state (or (:animation/player-state anim-data) (player/create-player-state))
        indices (:animation/indices anim-data {})
        durations (:animation/durations anim-data {})

        ;; Input already has :grounded from caller, just use it directly
        ;; The caller (update loop) now builds the complete input with speed, height, etc.

        ;; Update player state machine
        new-player-state (player/update-player-state player-state input delta-time durations)

        ;; Get animation index and time ratio
        anim-name (:current-anim new-player-state)
        anim-index (get indices anim-name 0)
        time-ratio (player/get-time-ratio new-player-state durations)
        movement-state (:movement-state new-player-state)]

    ;; Sample animation
    (anim/sample {:context (:animation/context anim-data)
                  :animation-index anim-index
                  :time-ratio time-ratio})

    ;; Return updated anim-data
    (assoc anim-data :animation/player-state new-player-state)))

;; =============================================================================
;; Client State
;; =============================================================================

(defn make-client-state
  "Create initial client state."
  []
  {:my-player-id nil               ; Our player ID (assigned by server)
   :connected? false
   :interp-state (interp/make-interp-state)
   :pred-state (pred/make-prediction-state)
   :remote-players {}              ; player-id -> animation data
   :level-collision nil
   :camera-state (camera/create-state)  ; Third-person camera with damping
   :debug/overlay-visible true
   :strafehelper/visible false
   :f3-was-pressed false
   :f4-was-pressed false})

;; =============================================================================
;; Window Setup
;; =============================================================================

(defn setup-window
  [{:keys [width height name]}]
  (let [_ (do (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MAJOR 3) nil)
        _ (do (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MINOR 3) nil)
        _ (do (cpp/glfwWindowHint gl/GLFW_OPENGL_PROFILE gl/GLFW_OPENGL_CORE_PROFILE) nil)
        _ (do (cpp/glfwWindowHint gl/GLFW_OPENGL_FORWARD_COMPAT gl/GL_TRUE) nil)
        window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0)
      nil)
    (do (cpp/glfwMakeContextCurrent window) nil)
    ;; Initialize GLEW for Linux (no-op on macOS)
    (when (cpp/! (cpp/init_glew_client))
      (println "GLEW initialization failed")
      (cpp/exit 1)
      nil)
    (do (cpp/glfwSwapInterval 0) nil)
    (do (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback_client) nil)
    (do (cpp/wrap_glEnable gl/GL_DEPTH_TEST) nil)
    (cpp/box window)))

;; =============================================================================
;; Input Processing
;; =============================================================================

(defn process-input
  "Get current input state."
  [{:keys [window delta-time cursor/pitch cursor/yaw]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cond-> {:delta-time (float (math/*-> :float delta-time))
             :pitch (float (math/*-> :float pitch))
             :yaw (float (math/*-> :float yaw))}
      (= (cpp/glfwGetKey window gl/GLFW_KEY_ESCAPE) gl/GLFW_PRESS)
      (assoc :exit true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_W) gl/GLFW_PRESS)
      (assoc :forward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_S) gl/GLFW_PRESS)
      (assoc :backward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_A) gl/GLFW_PRESS)
      (assoc :left true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_D) gl/GLFW_PRESS)
      (assoc :right true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_SPACE) gl/GLFW_PRESS)
      (assoc :jump-held true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_LEFT_CONTROL) gl/GLFW_PRESS)
      (assoc :crouch true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F3) gl/GLFW_PRESS)
      (assoc :f3-pressed true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F4) gl/GLFW_PRESS)
      (assoc :f4-pressed true))))

;; =============================================================================
;; Cursor / Time Updates
;; =============================================================================

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)
        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y))
        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)
        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))
        cursor-sensitivity (math/*-> :float sensitivity)
        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)
        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]
    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/- cursor-pitch y-offset))
    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)
    (when (cpp/> cursor-pitch (cpp/float 60.0))
      (cpp/= cursor-pitch (cpp/float 60.0))
      nil)
    (when (cpp/< cursor-pitch (cpp/float -30.0))
      (cpp/= cursor-pitch (cpp/float -30.0))
      nil)
    nil))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)
    nil))

;; =============================================================================
;; Network Message Handling
;; =============================================================================

(defn handle-welcome
  "Handle welcome message from server."
  [client-state msg]
  (println "Received welcome! My player ID:" (:your-player-id msg))
  (-> client-state
      (assoc :my-player-id (:your-player-id msg))
      (assoc :connected? true)))

(defn handle-snapshot
  "Handle snapshot from server."
  [client-state snapshot collision-mesh]
  (let [{:keys [my-player-id pred-state interp-state]} client-state]
    (if my-player-id
      (let [;; NOTE: Full reconciliation disabled - causes rubber-banding due to
            ;; timing mismatch between client prediction and server simulation.
            ;; For now, just remove acknowledged commands and trust local prediction.
            ;; TODO: Fix reconciliation with better state comparison or dead reckoning.
            ack-sequence (get-in snapshot [:last-processed-commands my-player-id] 0)
            new-pred-state (pred/remove-acknowledged-commands pred-state ack-sequence)
            ;; Add snapshot to interpolation buffer (for remote players)
            new-interp-state (interp/add-snapshot interp-state snapshot)]
        (-> client-state
            (assoc :pred-state new-pred-state)
            (assoc :interp-state new-interp-state)))
      ;; Not yet assigned a player ID
      (update client-state :interp-state interp/add-snapshot snapshot))))

(defn handle-player-spawned
  "Handle player spawn event."
  [client-state msg]
  (println "Player spawned:" (:player-id msg))
  client-state)

(defn handle-player-disconnected
  "Handle player disconnect event."
  [client-state msg]
  (println "Player disconnected:" (:player-id msg))
  (update client-state :remote-players dissoc (:player-id msg)))

(defn handle-network-message
  "Handle a network message."
  [client-state msg collision-mesh]
  (case (:type msg)
    :event
    (case (:event/type msg)
      :client/welcome (handle-welcome client-state msg)
      :player/spawned (handle-player-spawned client-state msg)
      :player/disconnected (handle-player-disconnected client-state msg)
      client-state)

    :snapshot
    (handle-snapshot client-state msg collision-mesh)

    client-state))

;; =============================================================================
;; Rendering
;; =============================================================================

(defn render-entity-at-position
  "Render an entity at a given position/angles."
  [shader position yaw model]
  (let [[px py pz] position
        model-m (-> (cpp/identity_matrix)
                    (cpp/glm.translate (math/gimmie :vec3 [px py pz]))
                    (cpp/glm.rotate (cpp/glm.radians (cpp/float (- yaw)))
                                    (math/gimmie :vec3 [0.0 1.0 0.0])))
        model-m-loc (cpp/wrap_glGetUniformLocation shader "model")
        _ (do (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE
                                      (cpp/glm.value_ptr model-m)) nil)]
    (when model
      ((:draw model) {:shader shader :model/local-matrix-uniform "local"})
      nil)
    nil))

(defn draw-world
  "Draw the game world."
  [{:keys [shader line-shader line-vao line-vbo level-model player-anim-data client-state delta-time input] :as context}]
  (let [_ (do (cpp/wrap_glClearColor 0.2 0.3 0.3 1.0) nil)
        _ (do (cpp/wrap_glClear gl/GL_COLOR_DEPTH_BUFFER_BITS) nil)

        fov (:fov camera/default-config 90.0)
        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float fov))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))
        ;; Get delta time in milliseconds
        dt-sec (math/*-> :float delta-time)
        dt-ms (* (double dt-sec) 1000.0)

        ;; Render level with basic shader
        _ (do (cpp/wrap_glUseProgram shader) nil)
        projection-m-loc (cpp/wrap_glGetUniformLocation shader "projection")
        _ (do (cpp/wrap_glUniformMatrix4fv projection-m-loc (cpp/int 1) gl/GL_FALSE
                              (cpp/glm.value_ptr projection-m)) nil)

        ;; Get local player state for camera
        state @client-state
        pred-state (:pred-state state)
        my-id (:my-player-id state)
        render-state (pred/get-render-state pred-state)
        local-pos (or (:position render-state) [0.0 50.0 0.0])
        local-yaw (or (:yaw render-state) 0.0)
        local-pitch (or (:pitch render-state) 0.0)

        ;; Update camera with damping (sets view uniform on shader)
        new-cam-state (camera/update-camera shader
                                            (:camera-state state)
                                            camera/default-config
                                            local-pos
                                            local-yaw
                                            local-pitch
                                            dt-ms)
        _ (swap! client-state assoc :camera-state new-cam-state)

        ;; Render level
        _ (when level-model
            (let [model-m-loc (cpp/wrap_glGetUniformLocation shader "model")
                  _ (do (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE
                                        (cpp/glm.value_ptr (cpp/identity_matrix))) nil)]
              ((:draw level-model) {:shader shader :model/local-matrix-uniform "local"})
              nil))

        ;; Switch to line shader for player skeleton rendering
        _ (do (cpp/wrap_glUseProgram line-shader) nil)
        line-projection-m-loc (cpp/wrap_glGetUniformLocation line-shader "projection")
        _ (do (cpp/wrap_glUniformMatrix4fv line-projection-m-loc (cpp/int 1) gl/GL_FALSE
                                (cpp/glm.value_ptr projection-m)) nil)
        ;; Set line width (in normalized device coords, ~0.01-0.05 looks good)
        _ (do (cpp/wrap_glUniform1f (cpp/wrap_glGetUniformLocation line-shader "lineWidth") 0.025) nil)
        ;; Set line colors: cyan at feet, bright teal at head
        _ (do (cpp/wrap_glUniform3f (cpp/wrap_glGetUniformLocation line-shader "lineColor") 0.0 0.8 0.6) nil)
        _ (do (cpp/wrap_glUniform3f (cpp/wrap_glGetUniformLocation line-shader "lineColor2") 0.2 1.0 0.9) nil)]
      ;; Enable blending for soft edges
      (gl-state/enable {:capability gl/GL_BLEND})
      (gl-state/set-blend-func {:src gl/GL_SRC_ALPHA :dest gl/GL_ONE_MINUS_SRC_ALPHA})
      ;; Set camera for line shader (same damped position)
      (camera/update-camera line-shader
                            (:camera-state @client-state)
                            camera/default-config
                            local-pos
                            local-yaw
                            local-pitch
                            0.0)  ;; 0 delta-ms to reuse same position

      ;; Render local player (line skeleton)
      (when player-anim-data
        (render-skeleton-entity line-shader line-vao line-vbo @player-anim-data local-pos local-yaw input))

      ;; Render remote players (interpolated, line skeleton)
      (let [interp-state (:interp-state state)
            remote-entities (interp/get-all-entity-render-states interp-state)]
        (doseq [[entity-id entity-state] remote-entities]
          (when (not= entity-id my-id)
            (let [pos (:lerp-origin entity-state)
                  [_pitch yaw] (:lerp-angles entity-state)]
              ;; Ensure this remote player has an animation context
              (when-not (contains? (:remote-players @client-state) entity-id)
                (swap! client-state update :remote-players ensure-remote-player-anim entity-id))
              ;; Get the animation context and render
              (when-let [remote-anim (get (:remote-players @client-state) entity-id)]
                (when pos
                  ;; Use interpolated animation state from server (synchronized with position)
                  (let [anim-name (or (:animation-name entity-state) "BOTH_STAND1")
                        anim-index (get (:animation/indices remote-anim) anim-name 0)
                        anim-time (or (:animation-time entity-state) 0.0)
                        durations (:animation/durations remote-anim {})
                        duration (get durations anim-name 1.0)
                        time-ratio (/ anim-time duration)]
                    ;; Sample at interpolated time
                    (anim/sample {:context (:animation/context remote-anim)
                                  :animation-index anim-index
                                  :time-ratio time-ratio})
                    ;; Remote players don't have input, so no lean
                    (render-skeleton-entity line-shader line-vao line-vbo remote-anim pos (or yaw 0.0) {}))))))))

      ;; Disable blending after skeleton rendering
      (gl-state/disable {:capability gl/GL_BLEND})))

;; =============================================================================
;; Main Client Loop
;; =============================================================================

(defn run-client-loop
  [{:keys [window network client-state delta-time gfx2d] :as context}]
  (println "Entering client loop")
  (while (and (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
              (net/connected? network))

    (let [_ (update-time context)
          _ (update-cursor context)
          dt (math/*-> :float delta-time)
          dt-ms (* dt 1000.0)]

      ;; Process network events
      (let [events (net/poll-events! network 0)]
        (doseq [event events]
          (case (:type event)
            :message
            (swap! client-state handle-network-message
                   (:message event) (:level-collision @client-state))

            :disconnect
            (do (println "Disconnected from server")
                (swap! client-state assoc :connected? false))

            nil)))

      ;; Get input
      (let [input (process-input context)
            state @client-state]

        ;; Handle exit
        (when (:exit input)
          (cpp/glfwSetWindowShouldClose
           (cpp/unbox cpp/GLFWwindow* window) 1)
          nil)

        ;; Handle debug toggles
        (when (and (:f3-pressed input) (not (:f3-was-pressed state)))
          (swap! client-state update :debug/overlay-visible not))
        (swap! client-state assoc :f3-was-pressed (:f3-pressed input))

        (when (and (:f4-pressed input) (not (:f4-was-pressed state)))
          (swap! client-state update :strafehelper/visible not))
        (swap! client-state assoc :f4-was-pressed (:f4-pressed input))

        ;; If connected and have player ID, predict and send commands
        (when (and (:connected? state) (:my-player-id state))
          (let [physics-fn (fn [phys-state inp dt-val]
                             (shared/simulate-physics phys-state inp dt-val
                                                      (:level-collision state)))
                cmd-input (shared/command->input input)
                cmd-input (assoc cmd-input
                                 :pitch (:pitch input)
                                 :yaw (:yaw input))]
            ;; Run prediction
            (swap! client-state update :pred-state
                   pred/predict cmd-input physics-fn dt)

            ;; Send command to server
            (let [new-state @client-state
                  seq-num (dec (:next-sequence (:pred-state new-state)))]
              (net/send! network
                         {:message {:type :command
                                    :command (snapshot/make-input-command
                                              {:client-id (:my-player-id state)
                                               :sequence seq-num
                                               :forward (:forward input)
                                               :backward (:backward input)
                                               :left (:left input)
                                               :right (:right input)
                                               :jump-held (:jump-held input)
                                               :pitch (:pitch input)
                                               :yaw (:yaw input)
                                               :delta-time dt})}
                          :reliable false}))))

        ;; Update interpolation for remote players
        (swap! client-state update :interp-state interp/update-interpolation dt-ms)

        ;; Update prediction error smoothing
        (swap! client-state update :pred-state pred/update-error-smoothing dt-ms)

        ;; Update player animation (use input keys directly for animation selection)
        (when-let [anim-data-atom (:player-anim-data context)]
          (let [render-state (pred/get-render-state (:pred-state @client-state))
                velocity (or (:velocity render-state) [0.0 0.0 0.0])
                position (or (:position render-state) [0.0 0.0 0.0])
                [vx vy vz] velocity
                [_ py _] position
                ;; Calculate horizontal speed
                speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                       (cpp/* (cpp/float vz) (cpp/float vz))))
                ;; Determine grounded: use physics state if available, otherwise infer from velocity
                grounded (if (contains? render-state :grounded?)
                           (:grounded? render-state)
                           ;; If no grounded info, infer: grounded if not moving vertically
                           (< (abs vy) 0.1))
                ;; Build enhanced input for animation state machine
                ;; vy is used for glide detection: glide only when falling (vy <= 0) and not holding jump
                anim-input (assoc input
                                  :speed (double speed)
                                  :height (double py)
                                  :vy (double vy)
                                  :grounded grounded)]
            (swap! anim-data-atom update-player-animation anim-input grounded dt)))

        ;; Render (pass input for lean effect)
        (draw-world (assoc context :input input)))

      ;; Render debug overlay
      (when (:debug/overlay-visible @client-state)
        (let [state @client-state
              pred-state (:pred-state state)
              render-state (pred/get-render-state pred-state)
              [px py pz] (or (:position render-state) [0.0 0.0 0.0])
              [vx vy vz] (or (:velocity render-state) [0.0 0.0 0.0])
              grounded (or (:grounded? render-state) false)
              dt (math/*-> :float delta-time)
              fps (if (> dt 0.0) (/ 1.0 dt) 0.0)
              speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                     (cpp/* (cpp/float vz) (cpp/float vz))))]
          (text/render-text (str "FPS: " (int fps)) 10.0 30.0 [1.0 1.0 1.0] 1280 720)
          (text/render-text (str "Pos: " (int px) ", " (int py) ", " (int pz))
                            10.0 55.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Vel: " (int vx) ", " (int vy) ", " (int vz))
                            10.0 80.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Speed: " (int speed)) 10.0 105.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Grounded: " grounded) 10.0 130.0
                            (if grounded [0.5 1.0 0.5] [1.0 0.5 0.5]) 1280 720)
          (text/render-text "[NETWORKED]" 10.0 155.0 [0.5 0.8 1.0] 1280 720)))

      ;; Render strafehelper
      (when (:strafehelper/visible @client-state)
        (let [state @client-state
              pred-state (:pred-state state)
              render-state (pred/get-render-state pred-state)
              velocity (or (:velocity render-state) [0.0 0.0 0.0])
              yaw (or (:yaw render-state) 0.0)
              grounded (or (:grounded? render-state) false)]
          (strafehelper/render-strafehelper gfx2d velocity yaw grounded 1280 720)))

      (do (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window)) nil)
      (do (cpp/glfwPollEvents) nil))))

;; =============================================================================
;; Entry Point
;; =============================================================================

;; Address parsing helpers (C++ due to std::string method overload ambiguity)
(cpp/raw "
  #include <string>
  #include <cstdlib>

  inline std::string parse_host_helper(const char* addr) {
    std::string s(addr);
    if (s.rfind(\"tcp://\", 0) == 0) s = s.substr(6);
    auto pos = s.rfind(':');
    if (pos != std::string::npos) {
      return s.substr(0, pos);
    }
    return s;
  }

  inline int parse_port_helper(const char* addr, int default_port) {
    std::string s(addr);
    if (s.rfind(\"tcp://\", 0) == 0) s = s.substr(6);
    auto pos = s.rfind(':');
    if (pos != std::string::npos) {
      return std::atoi(s.substr(pos + 1).c_str());
    }
    return default_port;
  }
")

(defn parse-host
  "Extract host from address string like 'tcp://host:port' or 'host:port'."
  [addr]
  (str (cpp/parse_host_helper addr)))

(defn parse-port
  "Extract port from address string, or return default if not found."
  [addr default-port]
  (cpp/parse_port_helper addr default-port))

(defn run-client
  "Run the game client."
  ([] (run-client DEFAULT_SERVER_ADDRESS))
  ([server-address]
   (let [host (parse-host server-address)
         port (parse-port server-address DEFAULT_SERVER_PORT)]
     (println "Starting demo client, connecting to" host ":" port "...")

   (let [_ (do (cpp/glfwInit) nil)
         window (setup-window {:width 1280 :height 720 :name "Demo - Client"})
         _ (do (cpp/glfwSetInputMode
                (cpp/unbox cpp/GLFWwindow* window)
                gl/GLFW_CURSOR
                gl/GLFW_CURSOR_DISABLED) nil)

         ;; Load shaders
         shader (shaders/load-shader-program
                 {:vertex-shader-path "shaders/basic_vertex.glsl"
                  :fragment-shader-path "shaders/basic_fragment.glsl"})
         _ (do (cpp/wrap_glUseProgram shader) nil)
         _ (do (cpp/wrap_glUniform1i (cpp/wrap_glGetUniformLocation shader "uBaseColorTex") (cpp/int 0)) nil)

         ;; Line shader for skeleton rendering (with geometry shader for thick lines)
         line-shader (shaders/load-shader-program-with-geometry
                      {:vertex-shader-path "shaders/line_vertex.glsl"
                       :geometry-shader-path "shaders/line_geometry.glsl"
                       :fragment-shader-path "shaders/line_fragment.glsl"})
         line-vbo-ptr (cpp/new cpp/GLuint)
         line-vao (cpp/create_line_vao_client line-vbo-ptr)
         line-vbo (cpp/* line-vbo-ptr)

         text-shader (shaders/load-shader-program
                      {:vertex-shader-path "shaders/text_vertex.glsl"
                       :fragment-shader-path "shaders/text_fragment.glsl"})
         _ (text/init-font "fonts/JetBrainsMono-Regular.ttf" 24.0 text-shader)

         graphics2d-shader (shaders/load-shader-program
                            {:vertex-shader-path "shaders/graphics2d_vertex.glsl"
                             :fragment-shader-path "shaders/graphics2d_fragment.glsl"})
         gfx2d (gfx2d/init-graphics2d graphics2d-shader)

         ;; Load level
         level-loaded (gltf/load {:model (gltf/parse {:path "models/hills.gltf"})
                                  :base-path "models/"})
         level-collision (when-let [col (first (:collision level-loaded))]
                          (collision/prepare-collision-mesh col))

         ;; Initialize player animation
         player-anim-data (init-player-animation)

         ;; Create client state
         client-state (atom (-> (make-client-state)
                                (assoc :level-collision level-collision)))

         ;; Connect to server
         network (net/start-client {:address host :port port})]

     (if (nil? network)
       (println "ERROR: Failed to create client")

       (do
         (println "Connecting...")
         (if (net/wait-for-connection! network 5000)
           (do
             (println "Connected to server!")

             ;; Process any events received during connection (e.g., welcome message)
             (let [events (net/poll-events! network 100)]
               (doseq [event events]
                 (when (= :message (:type event))
                   (swap! client-state handle-network-message
                          (:message event) level-collision))))

             (run-client-loop
              {:window window
               :network network
               :client-state client-state
               :shader shader
               :line-shader line-shader
               :line-vao line-vao
               :line-vbo line-vbo
               :level-model level-loaded
               :player-anim-data (atom player-anim-data)
               :gfx2d gfx2d
               :delta-time (math/gimmie :boxed :float 0.0)
               :last-frame (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x (math/gimmie :boxed :float 400.0)
               :cursor/last-y (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity (math/gimmie :boxed :float 0.05)
               :cursor/pitch (math/gimmie :boxed :float 0.0)
               :cursor/yaw (math/gimmie :boxed :float -90.0)})

             (net/stop network))

           (do
             (println "ERROR: Connection timed out")
             (net/stop network)))))

     (cpp/glfwTerminate)
     (println "Client finished.")))))

(ns examples.demo.core
  (:require [engine.io.interface :as io]
            [engine.shaders.interface :as shaders]
            [engine.geometry.interface :as geometry]
            [engine.textures.interface :as textures]
            [engine.math.interface :as math]
            [engine.gltf.interface :as gltf]
            [engine.events.interface :as es]))

(cpp/raw "#include <GLFW/glfw3.h>")

(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>")

(cpp/raw "#include <math.h>")

(cpp/raw
 "void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

(def GLFW_PRESS (cpp/value "GLFW_PRESS"))
(def GLFW_KEY_ESCAPE (cpp/value "GLFW_KEY_ESCAPE"))
(def GLFW_KEY_W (cpp/value "GLFW_KEY_W"))
(def GLFW_KEY_S (cpp/value "GLFW_KEY_S"))
(def GLFW_KEY_A (cpp/value "GLFW_KEY_A"))
(def GLFW_KEY_D (cpp/value "GLFW_KEY_D"))

(defn process-input
  [{:keys [window delta-time cursor/pitch cursor/yaw]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cond-> {:command/name :player/process-input
             :id #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"
             :delta-time (float (math/*-> :float delta-time))
             :pitch (float (math/*-> :float pitch))
             :yaw (float (math/*-> :float yaw))}
      (= (cpp/glfwGetKey window GLFW_KEY_ESCAPE)
         GLFW_PRESS)
      (assoc :exit true)

      (= (cpp/glfwGetKey window GLFW_KEY_W) GLFW_PRESS)
      (assoc :forward true)

      (= (cpp/glfwGetKey window GLFW_KEY_S) GLFW_PRESS)
      (assoc :backward true)

      (= (cpp/glfwGetKey window GLFW_KEY_A) GLFW_PRESS)
      (assoc :left true)

      (= (cpp/glfwGetKey window GLFW_KEY_D) GLFW_PRESS)
      (assoc :right true))))

(defn setup-window
  [{:keys [width height name]}]

  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MAJOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MINOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_PROFILE")
                      (cpp/value "GLFW_OPENGL_CORE_PROFILE"))
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_FORWARD_COMPAT")
                      (cpp/value "GL_TRUE"))

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback)
    (cpp/glEnable (cpp/value "GL_DEPTH_TEST"))
    (cpp/box window)))

(cpp/raw
 "glm::mat4* new_identity_matrix () {
    return new glm::mat4(1.0f);
  }")

(defn transform-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (if (contains? tags :transform)
    (let [[px py pz] (:transform/position entity)
          yaw (:transform/yaw entity 0.0)
          ;; Translate then rotate around Y axis (negate yaw to match camera direction)
          model-m (-> (cpp/identity_matrix)
                      (cpp/glm.translate (math/gimmie :vec3 [px py pz]))
                      (cpp/glm.rotate (cpp/glm.radians (cpp/- (cpp/float 0.0) (cpp/float yaw)))
                                      (math/gimmie :vec3 [0.0 1.0 0.0])))
          model-m-loc (cpp/glGetUniformLocation shader "model")]
      (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr model-m))
      :done)
    (let [model-m-loc (cpp/glGetUniformLocation shader "model")]
      (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr (cpp/identity_matrix)))
      :done)))

(defn render-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (when (contains? tags :render)
    ((:draw (:model entity))
     {:shader shader
      :model/local-matrix-uniform "local"})))


(defn camera-system
  [{{:keys [follow-distance follow-height look-height-offset]} :camera
    :keys [shader state]
    :cursor/keys [yaw pitch]}]
  (when-let [player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])]
    (let [[px py pz] (:transform/position player)

          ;; Get parameters
          distance (math/*-> :float follow-distance)
          height (math/*-> :float follow-height)
          look-offset (math/*-> :float look-height-offset)
          player-yaw (math/*-> :float yaw)
          camera-pitch (math/*-> :float pitch)

          ;; Camera offset behind player (spherical coords)
          yaw-rad (cpp/glm.radians player-yaw)
          pitch-rad (cpp/glm.radians camera-pitch)

          ;; Horizontal offset: negate cos/sin to be BEHIND player
          offset-x (cpp/* (cpp/- (cpp/float 0.0) (cpp/cos yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-z (cpp/* (cpp/- (cpp/float 0.0) (cpp/sin yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-y (cpp/+ height (cpp/* distance (cpp/sin pitch-rad)))

          ;; Camera world position
          camera-pos (cpp/glm.vec3
                      (cpp/+ (cpp/float px) offset-x)
                      (cpp/+ (cpp/float py) offset-y)
                      (cpp/+ (cpp/float pz) offset-z))

          ;; Look at player head
          look-target (cpp/glm.vec3 (cpp/float px)
                                    (cpp/+ (cpp/float py) look-offset)
                                    (cpp/float pz))
          camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))

          ;; Set view matrix
          view-m (cpp/glm.lookAt camera-pos look-target camera-up)
          view-m-loc (cpp/glGetUniformLocation shader "view")]
      (cpp/glUniformMatrix4fv view-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr view-m)))))

(defn draw-3D
  [{:keys [state shader] :as context}]
  (let [_ (cpp/glClearColor 0.2 0.3 0.3 1.0)
        _ (cpp/glClear (cpp/| (cpp/value "GL_COLOR_BUFFER_BIT") (cpp/value "GL_DEPTH_BUFFER_BIT")))
        _ (cpp/glUseProgram shader)

        projection-m-loc (cpp/glGetUniformLocation shader "projection")
        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))

        _ (cpp/glUniformMatrix4fv projection-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr projection-m))
        _ (camera-system context)]
    (doseq [e (vals (:entities @state))]
      (transform-system context e)
      (render-system context e))))

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)

        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y))

        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)

        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))

        cursor-sensitivity (math/*-> :float sensitivity)

        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)

        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]

    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/- cursor-pitch y-offset))

    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)

    ;; Pitch constraints for third-person camera
    (when (cpp/> cursor-pitch (cpp/float 60.0))
      (cpp/= cursor-pitch (cpp/float 60.0)))

    (when (cpp/< cursor-pitch (cpp/float -30.0))
      (cpp/= cursor-pitch (cpp/float -30.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

(defmulti handle-event
  (fn [state {:keys [event]}] (:event/type event)))

(defmethod handle-event :system/exit
  [state {:keys [window]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cpp/glfwSetWindowShouldClose window 1)
    state))

(defmethod handle-event :level/spawned
  [state {{:keys [id] :as event} :event}]
  (update state :entities assoc id
          (-> event
              (select-keys [:id :model])
              (update :model #(gltf/load {:model (gltf/parse {:path %})
                                          :base-path "models/"}))
              (update :tags (fnil conj #{}) :render))))

(defmethod handle-event :player/spawned
  [state {{:keys [id] :as event} :event}]
  (update state :entities assoc id
          (-> event
              (select-keys [:id :model :transform/position])
              (assoc :transform/pitch 0.0 :transform/yaw -90.0)
              (update :model #(gltf/load {:model (gltf/parse {:path %})
                                          :base-path "models/"}))
              (update :tags (fnil conj #{}) :render :transform :camera))))


(defmethod handle-event :player/moved
  [{:keys [entities] :as state}
   {{:keys [id forward backward left right yaw pitch delta-time]} :event}]
  (let [player (get entities id)
        movespeed (cpp/* (cpp/float 5.0) (cpp/float delta-time))
        yaw-radians (cpp/glm.radians (cpp/float yaw))
        front (math/gimmie :vec3 [(cpp/cos yaw-radians) 0.0 (cpp/sin yaw-radians)])
        velocity (->> front
                      (cpp/* movespeed))
        [px py pz] (:transform/position player)
        current-position (math/gimmie :vec3 [px py pz])
        up (math/gimmie :vec3 [0.0 1.0 0.0])
        _ (when forward
            (cpp/= current-position
                   (cpp/+ current-position
                          (cpp/* movespeed
                                 front)))
            nil)
        _ (when backward
            (cpp/= current-position
                   (cpp/- current-position
                          (cpp/* movespeed
                                 front)))
            nil)
        _ (when left
            (cpp/= current-position
                   (cpp/- current-position
                          (cpp/* (cpp/glm.normalize
                                  (cpp/glm.cross
                                   front
                                   up))
                                 movespeed)))
            nil)
        _ (when right
            (cpp/= current-position
                   (cpp/+ current-position
                          (cpp/* (cpp/glm.normalize
                                  (cpp/glm.cross
                                   front
                                   up))
                                 movespeed)))
            nil)
        adjusted-position (cpp/+ current-position (cpp/* (cpp/float delta-time) velocity))]
    (-> state
        (update-in [:entities id] assoc
                   :transform/position
                   [(cpp/aget adjusted-position (cpp/int 0))
                    (cpp/aget adjusted-position (cpp/int 1))
                    (cpp/aget adjusted-position (cpp/int 2))]
                   :transform/pitch pitch
                   :transform/yaw yaw))))

(defmethod handle-event :default
  [state _]
  state)

(defmulti handle-command
  (fn [{:keys [command]}] (:command/name command)))

(defmethod handle-command :player/process-input
  [{:keys [command]}]
  (let [{:keys [exit]} command]
    (cond
      exit [{:event/type :system/exit}]
      ;; Always generate :player/moved to keep yaw in sync with camera
      :else [(-> command
                 (dissoc :command/name)
                 (assoc :event/type :player/moved))])))

(defmethod handle-command :default
  [])

(defn run-loop
  [{:keys [window event-store state]
    :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (let [_ (update-time context)
          _ (update-cursor context)
          command (process-input context)
          events (handle-command (assoc context :command command))
          _ (es/append event-store {:events events})
          _ (reset! state (reduce
                           (fn [state event]
                             (handle-event state (assoc context :event event)))
                           @state
                           (es/read event-store {})))
          _ (reset! event-store {:events []})]

      (draw-3D context)

      (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
      (cpp/glfwPollEvents))))

(defn setup-camera []
  {:follow-distance    (math/gimmie :boxed :float 5.0)   ; Distance behind player
   :follow-height      (math/gimmie :boxed :float 2.0)   ; Height above player
   :look-height-offset (math/gimmie :boxed :float 1.5)}) ; Look at head, not feet

(defn -main
  ([] (-main nil))
  ([x]
  (let [_ (cpp/glfwInit)
        window (setup-window {:width 1280 :height 720 :name "Learn OpenGL"})
        _ (cpp/glfwSetInputMode
           (cpp/unbox cpp/GLFWwindow* window)
           (cpp/value "GLFW_CURSOR")
           (cpp/value "GLFW_CURSOR_DISABLED"))
        shader (shaders/load-shader-program
                {:vertex-shader-path
                 "shaders/basic_vertex.glsl"
                 :fragment-shader-path
                 "shaders/basic_fragment.glsl"})
        _ (cpp/glUseProgram shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "uBaseColorTex") 0)
        camera (setup-camera)
        event-store (es/start {})
        _ (es/append event-store {:events [{:event/type :level/spawned
                                            :event/tags #{}
                                            :id #uuid "bbf1bbe7-a35d-4be1-ba62-6fe382a53345"
                                            :model "models/test-level.gltf"}
                                           {:event/type :player/spawned
                                            :id #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"
                                            :model "models/player.gltf"
                                            :transform/position [0.0 0.0 0.0]}]})]

    (run-loop {:event-store event-store
               :state (atom {})
               :window window
               :shader shader
               :models []
               :camera camera
               :delta-time          (math/gimmie :boxed :float 0.0)
               :last-frame          (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x       (math/gimmie :boxed :float 400.0)
               :cursor/last-y       (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity  (math/gimmie :boxed :float 0.05)
               :cursor/pitch        (math/gimmie :boxed :float 0.0)
               :cursor/yaw          (math/gimmie :boxed :float -90.0)}))))

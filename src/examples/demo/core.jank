(ns examples.demo.core
  (:require [engine.io.interface :as io]
            [engine.shaders.interface :as shaders]
            [engine.3d.geometry.interface :as geometry]
            [engine.3d.textures.interface :as textures]
            [engine.math.interface :as math]
            [engine.3d.gltf.interface :as gltf]
            [engine.events.interface :as es]
            [engine.3d.collision.interface :as collision]
            [engine.2d.text.interface :as text]
            [engine.2d.graphics.interface :as gfx2d]
            [engine.3d.animation.interface :as anim]
            [examples.demo.animation.state :as anim-state]
            [examples.demo.strafehelper.interface :as strafehelper]
            [examples.demo.server :as server]
            [examples.demo.client :as client]
            [engine.gl.constants :as gl]))

(cpp/raw "#include \"gl_wrappers.h\"
#include <GLFW/glfw3.h>
#include <cstdio>

// GLEW initialization for Linux - must be called after glfwMakeContextCurrent
inline bool init_glew() {
#ifndef __APPLE__
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK) {
        fprintf(stderr, \"GLEW initialization failed: %s\\n\", glewGetErrorString(err));
        return false;
    }
    // Clear any GL errors from glewInit (common issue)
    while (glGetError() != GL_NO_ERROR) {}
    return true;
#else
    return true;
#endif
}")

(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>")

(cpp/raw "#include <math.h>")

(cpp/raw "#include \"animation_types.h\"")
(cpp/raw "#include \"gl_utils.h\"")

;; Simple line shader for skeleton visualization
(def line-vertex-shader
  "#version 330 core
   layout (location = 0) in vec3 aPos;
   uniform mat4 model;
   uniform mat4 view;
   uniform mat4 projection;
   void main() {
       gl_Position = projection * view * model * vec4(aPos, 1.0);
   }")

(def line-fragment-shader
  "#version 330 core
   out vec4 FragColor;
   uniform vec3 lineColor;
   void main() {
       FragColor = vec4(lineColor, 1.0);
   }")

;; C++ helpers for line rendering
(cpp/raw "
  inline GLuint compile_shader_inline_demo(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char log[512];
        glGetShaderInfoLog(shader, 512, nullptr, log);
        fprintf(stderr, \"Shader compile error: %s\\n\", log);
    }
    return shader;
  }

  inline GLuint create_line_shader_demo(const char* vs, const char* fs) {
    GLuint vert = compile_shader_inline_demo(GL_VERTEX_SHADER, vs);
    GLuint frag = compile_shader_inline_demo(GL_FRAGMENT_SHADER, fs);
    GLuint prog = glCreateProgram();
    glAttachShader(prog, vert);
    glAttachShader(prog, frag);
    glLinkProgram(prog);
    GLint success;
    glGetProgramiv(prog, GL_LINK_STATUS, &success);
    if (!success) {
        char log[512];
        glGetProgramInfoLog(prog, 512, nullptr, log);
        fprintf(stderr, \"Shader link error: %s\\n\", log);
    }
    glDeleteShader(vert);
    glDeleteShader(frag);
    return prog;
  }

  // Create VAO for skeleton lines (dynamic updates)
  inline GLuint create_line_vao_demo(GLuint* vbo_out) {
    GLuint vao, vbo;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    // Allocate space for 128 lines * 2 verts * 3 floats
    glBufferData(GL_ARRAY_BUFFER, 128 * 6 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
    *vbo_out = vbo;
    return vao;
  }

  // Update line VBO with new vertices
  inline void update_line_vbo_demo(GLuint vbo, float* vertices, int line_count) {
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, line_count * 6 * sizeof(float), vertices);
  }

  // Get std::vector data pointer
  inline float* get_vector_data_demo(std::vector<float>* v) {
    return v->data();
  }

  inline int gl_lines_demo() { return GL_LINES; }
")

(def GL_LINES_CONST (cpp/gl_lines_demo))

(cpp/raw
 "inline void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

;; Using centralized GLFW constants from engine.gl.constants

;; JKA-style physics constants (scaled for game world)
(def GRAVITY 25.6)
(def JUMP_VELOCITY 7.2)
(def FORCE_JUMP_STRENGTH 26.88)  ;; Level 3 force jump strength (840 scaled)
(def FORCE_JUMP_HEIGHT 12.3)     ;; Level 3 max height above jump start (384 scaled)
(def GROUND_ACCEL 10.0)
(def AIR_ACCEL 1.0)       ;; Key for JKA feel: 10:1 ratio
(def FRICTION 6.0)
(def STOP_SPEED 2.5)
(def MAX_SPEED 8.0)
(def GROUND_HEIGHT 0.1)

(defn process-input
  [{:keys [window delta-time cursor/pitch cursor/yaw]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cond-> {:command/name :player/process-input
             :id #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"
             :delta-time (float (math/*-> :float delta-time))
             :pitch (float (math/*-> :float pitch))
             :yaw (float (math/*-> :float yaw))}
      (= (cpp/glfwGetKey window gl/GLFW_KEY_ESCAPE)
         gl/GLFW_PRESS)
      (assoc :exit true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_W) gl/GLFW_PRESS)
      (assoc :forward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_S) gl/GLFW_PRESS)
      (assoc :backward true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_A) gl/GLFW_PRESS)
      (assoc :left true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_D) gl/GLFW_PRESS)
      (assoc :right true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_SPACE) gl/GLFW_PRESS)
      (assoc :jump-held true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F3) gl/GLFW_PRESS)
      (assoc :f3-pressed true)

      (= (cpp/glfwGetKey window gl/GLFW_KEY_F4) gl/GLFW_PRESS)
      (assoc :f4-pressed true))))

(defn setup-window
  [{:keys [width height name]}]

  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MAJOR 3)
  (cpp/glfwWindowHint gl/GLFW_CONTEXT_VERSION_MINOR 3)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_PROFILE
                      gl/GLFW_OPENGL_CORE_PROFILE)
  (cpp/glfwWindowHint gl/GLFW_OPENGL_FORWARD_COMPAT
                      gl/GL_TRUE)

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    ;; Initialize GLEW for Linux (no-op on macOS)
    (when (cpp/! (cpp/init_glew))
      (println "GLEW initialization failed")
      (cpp/exit 1))
    (cpp/glfwSwapInterval 0)  ;; Disable VSync
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback)
    (cpp/wrap_glEnable gl/GL_DEPTH_TEST)
    (cpp/box window)))

(cpp/raw
 "inline glm::mat4* new_identity_matrix () {
    return new glm::mat4(1.0f);
  }")

(defn transform-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (if (contains? tags :transform)
    (let [[px py pz] (:transform/position entity)
          yaw (:transform/yaw entity 0.0)
          ;; Model rotation offset (some models face different directions)
          model-offset (if (contains? tags :animated) 90.0 0.0)
          ;; JKA skeleton origin is at pelvis, not feet - raise it up
          model-y-offset (if (contains? tags :animated) 0.5 0.0)
          ;; Mixamo models may need scaling
          model-scale (if (contains? tags :animated) 1.0 1.0)
          ;; Translate then rotate around Y axis (negate yaw to match camera direction)
          model-m (-> (cpp/identity_matrix)
                      (cpp/glm.translate (math/gimmie :vec3 [px (+ py model-y-offset) pz]))
                      (cpp/glm.rotate (cpp/glm.radians (cpp/- (cpp/float model-offset) (cpp/float yaw)))
                                      (math/gimmie :vec3 [0.0 1.0 0.0]))
                      (cpp/glm.scale (math/gimmie :vec3 [model-scale model-scale model-scale])))
          model-m-loc (cpp/wrap_glGetUniformLocation shader "model")]
      (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr model-m))
      :done)
    (let [model-m-loc (cpp/wrap_glGetUniformLocation shader "model")]
      (cpp/wrap_glUniformMatrix4fv model-m-loc (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr (cpp/identity_matrix)))
      :done)))

(defn render-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (when (contains? tags :render)
    ((:draw (:model entity))
     {:shader shader
      :model/local-matrix-uniform "local"})))


(defn camera-system
  [{{:keys [follow-distance follow-height look-height-offset]} :camera
    :keys [shader state]
    :cursor/keys [yaw pitch]}]
  (when-let [player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])]
    (let [[px py pz] (:transform/position player)

          ;; Get parameters
          distance (math/*-> :float follow-distance)
          height (math/*-> :float follow-height)
          look-offset (math/*-> :float look-height-offset)
          player-yaw (math/*-> :float yaw)
          camera-pitch (math/*-> :float pitch)

          ;; Camera offset behind player (spherical coords)
          yaw-rad (cpp/glm.radians player-yaw)
          pitch-rad (cpp/glm.radians camera-pitch)

          ;; Horizontal offset: negate cos/sin to be BEHIND player
          offset-x (cpp/* (cpp/- (cpp/float 0.0) (cpp/cos yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-z (cpp/* (cpp/- (cpp/float 0.0) (cpp/sin yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-y (cpp/+ height (cpp/* distance (cpp/sin pitch-rad)))

          ;; Camera world position
          camera-pos (cpp/glm.vec3
                      (cpp/+ (cpp/float px) offset-x)
                      (cpp/+ (cpp/float py) offset-y)
                      (cpp/+ (cpp/float pz) offset-z))

          ;; Look at player head
          look-target (cpp/glm.vec3 (cpp/float px)
                                    (cpp/+ (cpp/float py) look-offset)
                                    (cpp/float pz))
          camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))

          ;; Set view matrix
          view-m (cpp/glm.lookAt camera-pos look-target camera-up)
          view-m-loc (cpp/wrap_glGetUniformLocation shader "view")]
      (cpp/wrap_glUniformMatrix4fv view-m-loc (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr view-m)))))

(defn update-animations
  "Advances animation time and samples for all animated entities.
   Only animates when player is moving, scales speed with velocity."
  [{:keys [state delta-time]}]
  (let [dt-raw (math/*-> :float delta-time)
        dt (double dt-raw)]
    (doseq [[id entity] (:entities @state)]
      (when (contains? (:tags entity) :animated)
        (let [[vx _ vz] (or (:physics/velocity entity) [0 0 0])
              grounded (:physics/grounded entity true)
              ;; Calculate horizontal speed
              horiz-speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                           (cpp/* (cpp/float vz) (cpp/float vz))))
              ;; Select animation: 0=run, 1=inair
              anim-index (if grounded 0 1)
              ;; Only advance run animation if moving on ground
              is-moving (and grounded (> horiz-speed 0.5))
              current-time (double (:animation/time entity 0.0))
              run-duration (double (:animation/duration entity 1.0))
              inair-duration (double (:animation/inair-duration entity 0.05))
              ;; Calculate new time based on state
              new-time (cond
                         ;; In air: loop in-air animation
                         (not grounded)
                         (mod (+ current-time dt) inair-duration)
                         ;; On ground moving: advance run animation
                         is-moving
                         (mod (+ current-time (* dt (/ horiz-speed 8.0))) run-duration)
                         ;; On ground idle: reset to 0
                         :else 0.0)
              ;; Use appropriate duration for ratio
              duration (if grounded run-duration inair-duration)
              time-ratio (/ new-time duration)]
          ;; Sample animation at current time
          (anim/sample {:context (:animation/context entity)
                        :animation-index anim-index
                        :time-ratio time-ratio})
          ;; Update entity time
          (swap! state assoc-in [:entities id :animation/time] new-time))))))

(cpp/raw
 "inline void upload_identity_bones(GLint loc, int count) {
    // Upload identity matrices for debugging
    std::vector<float> identity_bones(count * 16);
    for (int i = 0; i < count; ++i) {
      // Identity matrix
      identity_bones[i*16 + 0] = 1.0f;
      identity_bones[i*16 + 5] = 1.0f;
      identity_bones[i*16 + 10] = 1.0f;
      identity_bones[i*16 + 15] = 1.0f;
    }
    glUniformMatrix4fv(loc, count, GL_FALSE, identity_bones.data());
  }")

(def DEBUG_NO_SKINNING false) ;; Set to true to test mesh without animation

(defn render-animated-system
  "Renders an animated entity as debug skeleton lines"
  [{:keys [line-shader]} {:keys [tags] :as entity}]
  (when (contains? tags :animated)
    (let [ctx (:animation/context entity)
          line-vao (:animation/line-vao entity)
          line-vbo (:animation/line-vbo entity)
          ;; Build skeleton lines - allocate buffer, use it, then delete it
          lines-data (anim/build-skeleton-lines {:context ctx :max-lines 128})
          line-count (:line-count lines-data)
          verts-box (:vertices lines-data)
          line-buffer (cpp/unbox (cpp/type "std::vector<float>*") verts-box)
          verts-ptr (cpp/get_vector_data_demo line-buffer)]
      ;; Set line color (black for player skeleton)
      (cpp/wrap_glUniform3f
       (cpp/wrap_glGetUniformLocation line-shader "lineColor")
       (cpp/float 0.0) (cpp/float 0.0) (cpp/float 0.0))
      ;; Update VBO and draw
      (cpp/update_line_vbo_demo line-vbo verts-ptr (cpp/int line-count))
      (cpp/wrap_glBindVertexArray line-vao)
      (cpp/glLineWidth (cpp/float 15.0))
      (cpp/wrap_glDrawArrays GL_LINES_CONST (cpp/int 0) (cpp/* (cpp/int line-count) (cpp/int 2)))
      (cpp/wrap_glBindVertexArray (cpp/GLuint 0))
      ;; Delete the buffer to prevent memory leak
      (cpp/delete line-buffer))))

(defn draw-3D
  [{:keys [state shader line-shader] :as context}]
  (let [_ (cpp/wrap_glClearColor 0.2 0.3 0.3 1.0)
        _ (cpp/wrap_glClear gl/GL_COLOR_DEPTH_BUFFER_BITS)

        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))]

    ;; Render non-animated entities with basic shader
    (cpp/wrap_glUseProgram shader)
    (let [projection-m-loc (cpp/wrap_glGetUniformLocation shader "projection")]
      (cpp/wrap_glUniformMatrix4fv projection-m-loc (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr projection-m)))
    (camera-system context)
    (doseq [e (vals (:entities @state))]
      (when-not (contains? (:tags e) :animated)
        (transform-system context e)
        (render-system context e)))

    ;; Render animated entities with line shader (debug skeleton)
    (cpp/wrap_glUseProgram line-shader)
    (let [projection-m-loc (cpp/wrap_glGetUniformLocation line-shader "projection")]
      (cpp/wrap_glUniformMatrix4fv projection-m-loc (cpp/int 1) gl/GL_FALSE (cpp/glm.value_ptr projection-m)))
    (camera-system (assoc context :shader line-shader))
    (doseq [e (vals (:entities @state))]
      (when (contains? (:tags e) :animated)
        (transform-system (assoc context :shader line-shader) e)
        (render-animated-system context e)))))

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)

        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y))

        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)

        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))

        cursor-sensitivity (math/*-> :float sensitivity)

        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)

        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]

    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/- cursor-pitch y-offset))

    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)

    ;; Pitch constraints for third-person camera
    (when (cpp/> cursor-pitch (cpp/float 60.0))
      (cpp/= cursor-pitch (cpp/float 60.0)))

    (when (cpp/< cursor-pitch (cpp/float -30.0))
      (cpp/= cursor-pitch (cpp/float -30.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

(defmulti handle-event
  (fn [state {:keys [event]}] (:event/type event)))

(defmethod handle-event :system/exit
  [state {:keys [window]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cpp/glfwSetWindowShouldClose window 1)
    state))

(defmethod handle-event :level/spawned
  [state {{:keys [id] :as event} :event}]
  (let [loaded (gltf/load {:model (gltf/parse {:path (:model event)})
                           :base-path "models/"})]
    (-> state
        (assoc :level-collision (when-let [col (first (:collision loaded))]
                              (collision/prepare-collision-mesh col)))
        (update :entities assoc id
                (-> event
                    (select-keys [:id])
                    (assoc :model loaded)
                    (update :tags (fnil conj #{}) :render))))))

(defn init-player-animation
  "Initialize player animation system with ozz assets - debug line rendering"
  []
  (let [ctx (anim/create-context)
        ;; Load JKA skeleton + original GLA-extracted animations (no mesh for debug lines)
        skeleton-info (anim/load-skeleton {:path "models/player/jka/humanoid.ozz"
                                           :context ctx})
        ;; Animation 0: run (JKA original)
        run-info (anim/load-animation {:path "models/player/jka/run1.ozz"
                                       :context ctx})
        ;; Animation 1: in-air (JKA original - used when airborne)
        inair-info (anim/load-animation {:path "models/player/jka/inair1.ozz"
                                         :context ctx})
        ;; Sample animation at time 0 to initialize bone matrices
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})
        ;; Create line VAO/VBO for debug skeleton rendering
        line-vbo-ptr (cpp/new cpp/GLuint)
        line-vao (cpp/create_line_vao_demo line-vbo-ptr)
        line-vbo (cpp/* line-vbo-ptr)]
    (println "Animation system initialized (debug line mode):")
    (println "  Skeleton joints:" (:num-joints skeleton-info))
    (println "  Run animation duration:" (:duration run-info) "seconds")
    (println "  In-air animation duration:" (:duration inair-info) "seconds")
    (println "  Line VAO:" line-vao "VBO:" line-vbo)
    {:animation/context ctx
     :animation/current-index 0
     :animation/duration (:duration run-info)
     :animation/inair-duration (:duration inair-info)
     :animation/line-vao line-vao
     :animation/line-vbo line-vbo
     :animation/time 0.0}))

(defmethod handle-event :player/spawned
  [state {{:keys [id] :as event} :event}]
  (let [;; Try to load animation, fall back to static model
        animation-data (init-player-animation)]
    (update state :entities assoc id
            (-> event
                (select-keys [:id :model :transform/position])
                (assoc :transform/pitch 0.0
                       :transform/yaw -90.0
                       :physics/velocity [0.0 0.0 0.0]
                       :physics/grounded true
                       :physics/jump-z-start nil)
                ;; Use static model for now, animation rendering to be added
                (update :model #(gltf/load {:model (gltf/parse {:path %})
                                            :base-path "models/"}))
                (merge animation-data)
                (update :tags (fnil into #{})
                        (if animation-data
                          [:render :transform :camera :animated]
                          [:render :transform :camera]))))))

(defn pm-friction
  "JKA-style friction - reduces horizontal velocity"
  [vx vz friction stopspeed dt]
  (let [vx-f (cpp/float vx)
        vz-f (cpp/float vz)
        speed (cpp/float (cpp/sqrt (cpp/+ (cpp/* vx-f vx-f) (cpp/* vz-f vz-f))))]
    (if (cpp/< speed (cpp/float 0.1))
      [(cpp/float 0.0) (cpp/float 0.0)]
      (let [stopspeed-f (cpp/float stopspeed)
            control (if (cpp/< speed stopspeed-f) stopspeed-f speed)
            drop (cpp/* control (cpp/* (cpp/float friction) (cpp/float dt)))
            newspeed-raw (cpp/- speed drop)
            newspeed (if (cpp/< newspeed-raw (cpp/float 0.0)) (cpp/float 0.0) newspeed-raw)
            scale (cpp// newspeed speed)]
        [(cpp/* vx-f scale) (cpp/* vz-f scale)]))))

(defn pm-accelerate
  "JKA-style acceleration toward wish direction"
  [vx vz dx dz wishspeed accel dt]
  (let [dx-f (cpp/float dx)
        dz-f (cpp/float dz)
        vx-f (cpp/float vx)
        vz-f (cpp/float vz)
        wish-len (cpp/float (cpp/sqrt (cpp/+ (cpp/* dx-f dx-f) (cpp/* dz-f dz-f))))]
    (if (cpp/< wish-len (cpp/float 0.001))
      [vx-f vz-f]
      (let [dx-norm (cpp// dx-f wish-len)
            dz-norm (cpp// dz-f wish-len)
            currentspeed (cpp/+ (cpp/* vx-f dx-norm) (cpp/* vz-f dz-norm))
            addspeed (cpp/- (cpp/float wishspeed) currentspeed)]
        (if (cpp/<= addspeed (cpp/float 0.0))
          [vx-f vz-f]
          (let [accelspeed (cpp/* (cpp/float accel)
                                  (cpp/* (cpp/float dt) (cpp/float wishspeed)))
                accelspeed (if (cpp/> accelspeed addspeed) addspeed accelspeed)]
            [(cpp/+ vx-f (cpp/* accelspeed dx-norm))
             (cpp/+ vz-f (cpp/* accelspeed dz-norm))]))))))

(defmethod handle-event :player/moved
  [{:keys [entities level-collision] :as state}
   {{:keys [id forward backward left right jump-held yaw pitch delta-time]} :event}]
  (let [player (get entities id)
        [px py pz] (:transform/position player)
        [vx vy vz] (:physics/velocity player [0.0 0.0 0.0])
        jump-z-start (:physics/jump-z-start player)

        ;; Ground detection via raycast
        ground-y (when level-collision
                   (collision/raycast-ground level-collision [px py pz]))
        is-grounded (and ground-y (<= py (+ ground-y 0.2)))

        ;; Build wish direction from input
        yaw-radians (cpp/glm.radians (cpp/float yaw))
        front-x (cpp/cos yaw-radians)
        front-z (cpp/sin yaw-radians)
        right-x (cpp/sin yaw-radians)
        right-z (cpp/- (cpp/float 0.0) (cpp/cos yaw-radians))

        ;; Accumulate wish direction
        wish-x (cond-> 0.0
                 forward (+ front-x)
                 backward (- front-x)
                 left (+ right-x)
                 right (- right-x))
        wish-z (cond-> 0.0
                 forward (+ front-z)
                 backward (- front-z)
                 left (+ right-z)
                 right (- right-z))

        ;; Apply friction (only when grounded)
        [vx vz] (if is-grounded
                  (pm-friction vx vz FRICTION STOP_SPEED delta-time)
                  [vx vz])

        ;; Accelerate (different rates for ground vs air)
        accel (if is-grounded GROUND_ACCEL AIR_ACCEL)
        [vx vz] (pm-accelerate vx vz wish-x wish-z MAX_SPEED accel delta-time)

        ;; Clear jump-z-start when not holding jump (resets jump state)
        ;; This allows re-jumping if player releases and presses again mid-air
        jump-z-start (if (not jump-held) nil jump-z-start)

        ;; Initial jump (grounded + button pressed + not already jumping)
        [vy is-grounded jump-z-start]
        (if (and is-grounded jump-held (nil? jump-z-start))
          [JUMP_VELOCITY false py]  ;; Start jump, record starting Y
          [vy is-grounded jump-z-start])

        ;; Force Jump thrust (JKA Metroid-style)
        ;; Thrust scales down as you approach max height
        ;; Formula: vy = (maxHeight - curHeight) / maxHeight * strength / 10 + JUMP_VELOCITY
        vy (if (and (not is-grounded)
                    jump-held
                    jump-z-start
                    (> vy 0))
             (let [cur-height (- py jump-z-start)]
               (if (< cur-height FORCE_JUMP_HEIGHT)
                 ;; Still have headroom - apply scaled thrust
                 (+ (/ (* (/ (- FORCE_JUMP_HEIGHT cur-height) FORCE_JUMP_HEIGHT)
                          FORCE_JUMP_STRENGTH)
                       10.0)
                    JUMP_VELOCITY)
                 ;; At max height - cap at normal jump velocity
                 (min vy JUMP_VELOCITY)))
             vy)

        ;; Apply gravity (always when airborne)
        vy (if (not is-grounded)
             (- vy (* GRAVITY delta-time))
             vy)

        ;; Integrate velocity to position
        new-px (+ px (* vx delta-time))
        new-py (+ py (* vy delta-time))
        new-pz (+ pz (* vz delta-time))

        ;; Clamp to ground (raycast collision)
        ground-y-at-new-pos (when level-collision
                              (collision/raycast-ground level-collision [new-px new-py new-pz]))
        [new-py vy is-grounded] (if (and ground-y-at-new-pos (< new-py ground-y-at-new-pos))
                                  [ground-y-at-new-pos 0.0 true]
                                  [new-py vy is-grounded])]

    (-> state
        (update-in [:entities id] assoc
                   :transform/position [new-px new-py new-pz]
                   :physics/velocity [vx vy vz]
                   :physics/grounded is-grounded
                   :physics/jump-z-start jump-z-start
                   :transform/pitch pitch
                   :transform/yaw yaw))))

(defmethod handle-event :debug/toggled
  [state _]
  (update state :debug/overlay-visible not))

(defmethod handle-event :debug/f3-updated
  [state {{:keys [pressed]} :event}]
  (assoc state :debug/f3-was-pressed pressed))

(defmethod handle-event :strafehelper/toggled
  [state _]
  (update state :strafehelper/visible not))

(defmethod handle-event :strafehelper/f4-updated
  [state {{:keys [pressed]} :event}]
  (assoc state :strafehelper/f4-was-pressed pressed))

(defmethod handle-event :default
  [state _]
  state)

(defmulti handle-command
  (fn [{:keys [command]}] (:command/name command)))

(defmethod handle-command :player/process-input
  [{:keys [command state]}]
  (let [{:keys [exit f3-pressed f4-pressed]} command
        f3-was-pressed (:debug/f3-was-pressed @state)
        f4-was-pressed (:strafehelper/f4-was-pressed @state)]
    (cond
      exit [{:event/type :system/exit}]
      :else (cond-> [(-> command
                         (dissoc :command/name :f3-pressed :f4-pressed)
                         (assoc :event/type :player/moved))]
              ;; Toggle debug on F3 press (not hold)
              (and f3-pressed (not f3-was-pressed))
              (conj {:event/type :debug/toggled})

              ;; Always track F3 state for debouncing
              true
              (conj {:event/type :debug/f3-updated :pressed f3-pressed})

              ;; Toggle strafehelper on F4 press (not hold)
              (and f4-pressed (not f4-was-pressed))
              (conj {:event/type :strafehelper/toggled})

              ;; Always track F4 state for debouncing
              true
              (conj {:event/type :strafehelper/f4-updated :pressed f4-pressed})))))

(defmethod handle-command :default
  [])

(defn run-loop
  [{:keys [window event-store state delta-time gfx2d]
    :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (let [_ (update-time context)
          _ (update-cursor context)
          command (process-input context)
          events (handle-command (assoc context :command command :state state))
          _ (es/append event-store {:events events})
          _ (reset! state (reduce
                           (fn [state event]
                             (handle-event state (assoc context :event event)))
                           @state
                           (es/read event-store {})))
          _ (reset! event-store {:events []})
          ;; Update animations before rendering
          _ (update-animations context)]

      (draw-3D context)

      ;; Render debug overlay (F3 to toggle)
      (when (get @state :debug/overlay-visible true)
        (let [dt (math/*-> :float delta-time)
              fps (if (> dt 0.0) (/ 1.0 dt) 0.0)
              player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])
              [px py pz] (or (:transform/position player) [0 0 0])
              [vx vy vz] (or (:physics/velocity player) [0 0 0])
              grounded (:physics/grounded player)
              speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float. vx) (cpp/float. vx))
                                     (cpp/* (cpp/float. vz) (cpp/float. vz))))]
          (text/render-text (str "FPS: " (int fps)) 10.0 30.0 [1.0 1.0 1.0] 1280 720)
          (text/render-text (str "Pos: " (int px) ", " (int py) ", " (int pz))
                            10.0 55.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Vel: " (int vx) ", " (int vy) ", " (int vz))
                            10.0 80.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Speed: " (int speed)) 10.0 105.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Grounded: " grounded) 10.0 130.0
                            (if grounded [0.5 1.0 0.5] [1.0 0.5 0.5]) 1280 720)))

      ;; Render strafehelper (F4 to toggle)
      (when (get @state :strafehelper/visible false)
        (let [player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])
              velocity (or (:physics/velocity player) [0 0 0])
              yaw (:transform/yaw player 0.0)
              grounded (:physics/grounded player false)]
          (strafehelper/render-strafehelper gfx2d velocity yaw grounded 1280 720)))

      (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
      (cpp/glfwPollEvents))))

;; Solo mode removed - use client mode instead

(defn -main
  "Entry point. Usage:
     ./run demo              - Connect to localhost:7777
     ./run demo server       - Start server on port 7777
     ./run demo client       - Connect to localhost:7777
     ./run demo client <ip>  - Connect to specific server"
  ([] (client/run-client))
  ([mode]
   (cond
     (= mode "server")
     (server/run-server)

     (= mode "client")
     (client/run-client)

     :else
     (do
       (println "Unknown mode:" mode)
       (println "Usage:")
       (println "  ./run demo              - Connect to localhost:7777")
       (println "  ./run demo server       - Start server on port 7777")
       (println "  ./run demo client       - Connect to localhost:7777")
       (println "  ./run demo client <ip>  - Connect to specific server"))))
  ([mode server-address]
   (if (= mode "client")
     (client/run-client server-address)
     (do
       (println "Unknown mode:" mode)
       (println "Extra argument only valid for 'client' mode")))))

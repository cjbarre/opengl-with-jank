(ns examples.demo.core
  (:require [engine.io.interface :as io]
            [engine.shaders.interface :as shaders]
            [engine.geometry.interface :as geometry]
            [engine.textures.interface :as textures]
            [engine.math.interface :as math]
            [engine.gltf.interface :as gltf]
            [engine.events.interface :as es]))

(cpp/raw "#include <GLFW/glfw3.h>")

(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>")

(cpp/raw "#include <math.h>")

(cpp/raw
 "void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

(def GLFW_PRESS (cpp/value "GLFW_PRESS"))
(def GLFW_KEY_ESCAPE (cpp/value "GLFW_KEY_ESCAPE"))
(def GLFW_KEY_W (cpp/value "GLFW_KEY_W"))
(def GLFW_KEY_S (cpp/value "GLFW_KEY_S"))
(def GLFW_KEY_A (cpp/value "GLFW_KEY_A"))
(def GLFW_KEY_D (cpp/value "GLFW_KEY_D"))
(def GLFW_KEY_SPACE (cpp/value "GLFW_KEY_SPACE"))

;; JKA-style physics constants (scaled for game world)
(def GRAVITY 20.0)
(def JUMP_VELOCITY 7.0)
(def GROUND_ACCEL 10.0)
(def AIR_ACCEL 1.0)       ;; Key for JKA feel: 10:1 ratio
(def FRICTION 6.0)
(def STOP_SPEED 2.5)
(def MAX_SPEED 8.0)
(def GROUND_HEIGHT 0.1)

(defn process-input
  [{:keys [window delta-time cursor/pitch cursor/yaw]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cond-> {:command/name :player/process-input
             :id #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"
             :delta-time (float (math/*-> :float delta-time))
             :pitch (float (math/*-> :float pitch))
             :yaw (float (math/*-> :float yaw))}
      (= (cpp/glfwGetKey window GLFW_KEY_ESCAPE)
         GLFW_PRESS)
      (assoc :exit true)

      (= (cpp/glfwGetKey window GLFW_KEY_W) GLFW_PRESS)
      (assoc :forward true)

      (= (cpp/glfwGetKey window GLFW_KEY_S) GLFW_PRESS)
      (assoc :backward true)

      (= (cpp/glfwGetKey window GLFW_KEY_A) GLFW_PRESS)
      (assoc :left true)

      (= (cpp/glfwGetKey window GLFW_KEY_D) GLFW_PRESS)
      (assoc :right true)

      (= (cpp/glfwGetKey window GLFW_KEY_SPACE) GLFW_PRESS)
      (assoc :jump true))))

(defn setup-window
  [{:keys [width height name]}]

  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MAJOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MINOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_PROFILE")
                      (cpp/value "GLFW_OPENGL_CORE_PROFILE"))
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_FORWARD_COMPAT")
                      (cpp/value "GL_TRUE"))

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback)
    (cpp/glEnable (cpp/value "GL_DEPTH_TEST"))
    (cpp/box window)))

(cpp/raw
 "glm::mat4* new_identity_matrix () {
    return new glm::mat4(1.0f);
  }")

(defn transform-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (if (contains? tags :transform)
    (let [[px py pz] (:transform/position entity)
          yaw (:transform/yaw entity 0.0)
          ;; Translate then rotate around Y axis (negate yaw to match camera direction)
          model-m (-> (cpp/identity_matrix)
                      (cpp/glm.translate (math/gimmie :vec3 [px py pz]))
                      (cpp/glm.rotate (cpp/glm.radians (cpp/- (cpp/float 0.0) (cpp/float yaw)))
                                      (math/gimmie :vec3 [0.0 1.0 0.0])))
          model-m-loc (cpp/glGetUniformLocation shader "model")]
      (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr model-m))
      :done)
    (let [model-m-loc (cpp/glGetUniformLocation shader "model")]
      (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr (cpp/identity_matrix)))
      :done)))

(defn render-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (when (contains? tags :render)
    ((:draw (:model entity))
     {:shader shader
      :model/local-matrix-uniform "local"})))


(defn camera-system
  [{{:keys [follow-distance follow-height look-height-offset]} :camera
    :keys [shader state]
    :cursor/keys [yaw pitch]}]
  (when-let [player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])]
    (let [[px py pz] (:transform/position player)

          ;; Get parameters
          distance (math/*-> :float follow-distance)
          height (math/*-> :float follow-height)
          look-offset (math/*-> :float look-height-offset)
          player-yaw (math/*-> :float yaw)
          camera-pitch (math/*-> :float pitch)

          ;; Camera offset behind player (spherical coords)
          yaw-rad (cpp/glm.radians player-yaw)
          pitch-rad (cpp/glm.radians camera-pitch)

          ;; Horizontal offset: negate cos/sin to be BEHIND player
          offset-x (cpp/* (cpp/- (cpp/float 0.0) (cpp/cos yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-z (cpp/* (cpp/- (cpp/float 0.0) (cpp/sin yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-y (cpp/+ height (cpp/* distance (cpp/sin pitch-rad)))

          ;; Camera world position
          camera-pos (cpp/glm.vec3
                      (cpp/+ (cpp/float px) offset-x)
                      (cpp/+ (cpp/float py) offset-y)
                      (cpp/+ (cpp/float pz) offset-z))

          ;; Look at player head
          look-target (cpp/glm.vec3 (cpp/float px)
                                    (cpp/+ (cpp/float py) look-offset)
                                    (cpp/float pz))
          camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))

          ;; Set view matrix
          view-m (cpp/glm.lookAt camera-pos look-target camera-up)
          view-m-loc (cpp/glGetUniformLocation shader "view")]
      (cpp/glUniformMatrix4fv view-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr view-m)))))

(defn draw-3D
  [{:keys [state shader] :as context}]
  (let [_ (cpp/glClearColor 0.2 0.3 0.3 1.0)
        _ (cpp/glClear (cpp/| (cpp/value "GL_COLOR_BUFFER_BIT") (cpp/value "GL_DEPTH_BUFFER_BIT")))
        _ (cpp/glUseProgram shader)

        projection-m-loc (cpp/glGetUniformLocation shader "projection")
        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))

        _ (cpp/glUniformMatrix4fv projection-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr projection-m))
        _ (camera-system context)]
    (doseq [e (vals (:entities @state))]
      (transform-system context e)
      (render-system context e))))

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)

        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y))

        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)

        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))

        cursor-sensitivity (math/*-> :float sensitivity)

        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)

        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]

    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/- cursor-pitch y-offset))

    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)

    ;; Pitch constraints for third-person camera
    (when (cpp/> cursor-pitch (cpp/float 60.0))
      (cpp/= cursor-pitch (cpp/float 60.0)))

    (when (cpp/< cursor-pitch (cpp/float -30.0))
      (cpp/= cursor-pitch (cpp/float -30.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

(defmulti handle-event
  (fn [state {:keys [event]}] (:event/type event)))

(defmethod handle-event :system/exit
  [state {:keys [window]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cpp/glfwSetWindowShouldClose window 1)
    state))

(defmethod handle-event :level/spawned
  [state {{:keys [id] :as event} :event}]
  (update state :entities assoc id
          (-> event
              (select-keys [:id :model])
              (update :model #(gltf/load {:model (gltf/parse {:path %})
                                          :base-path "models/"}))
              (update :tags (fnil conj #{}) :render))))

(defmethod handle-event :player/spawned
  [state {{:keys [id] :as event} :event}]
  (update state :entities assoc id
          (-> event
              (select-keys [:id :model :transform/position])
              (assoc :transform/pitch 0.0
                     :transform/yaw -90.0
                     :physics/velocity [0.0 0.0 0.0]
                     :physics/grounded true)
              (update :model #(gltf/load {:model (gltf/parse {:path %})
                                          :base-path "models/"}))
              (update :tags (fnil conj #{}) :render :transform :camera))))

(defn pm-friction
  "JKA-style friction - reduces horizontal velocity"
  [vx vz friction stopspeed dt]
  (let [vx-f (cpp/float vx)
        vz-f (cpp/float vz)
        speed (cpp/float (cpp/sqrt (cpp/+ (cpp/* vx-f vx-f) (cpp/* vz-f vz-f))))]
    (if (cpp/< speed (cpp/float 0.1))
      [(cpp/float 0.0) (cpp/float 0.0)]
      (let [stopspeed-f (cpp/float stopspeed)
            control (if (cpp/< speed stopspeed-f) stopspeed-f speed)
            drop (cpp/* control (cpp/* (cpp/float friction) (cpp/float dt)))
            newspeed-raw (cpp/- speed drop)
            newspeed (if (cpp/< newspeed-raw (cpp/float 0.0)) (cpp/float 0.0) newspeed-raw)
            scale (cpp// newspeed speed)]
        [(cpp/* vx-f scale) (cpp/* vz-f scale)]))))

(defn pm-accelerate
  "JKA-style acceleration toward wish direction"
  [vx vz dx dz wishspeed accel dt]
  (let [dx-f (cpp/float dx)
        dz-f (cpp/float dz)
        vx-f (cpp/float vx)
        vz-f (cpp/float vz)
        wish-len (cpp/float (cpp/sqrt (cpp/+ (cpp/* dx-f dx-f) (cpp/* dz-f dz-f))))]
    (if (cpp/< wish-len (cpp/float 0.001))
      [vx-f vz-f]
      (let [dx-norm (cpp// dx-f wish-len)
            dz-norm (cpp// dz-f wish-len)
            currentspeed (cpp/+ (cpp/* vx-f dx-norm) (cpp/* vz-f dz-norm))
            addspeed (cpp/- (cpp/float wishspeed) currentspeed)]
        (if (cpp/<= addspeed (cpp/float 0.0))
          [vx-f vz-f]
          (let [accelspeed (cpp/* (cpp/float accel)
                                  (cpp/* (cpp/float dt) (cpp/float wishspeed)))
                accelspeed (if (cpp/> accelspeed addspeed) addspeed accelspeed)]
            [(cpp/+ vx-f (cpp/* accelspeed dx-norm))
             (cpp/+ vz-f (cpp/* accelspeed dz-norm))]))))))

(defmethod handle-event :player/moved
  [{:keys [entities] :as state}
   {{:keys [id forward backward left right jump yaw pitch delta-time]} :event}]
  (let [player (get entities id)
        [px py pz] (:transform/position player)
        [vx vy vz] (:physics/velocity player [0.0 0.0 0.0])

        ;; Ground detection (simple height check)
        is-grounded (<= py GROUND_HEIGHT)

        ;; Build wish direction from input
        yaw-radians (cpp/glm.radians (cpp/float yaw))
        front-x (cpp/cos yaw-radians)
        front-z (cpp/sin yaw-radians)
        right-x (cpp/sin yaw-radians)
        right-z (cpp/- (cpp/float 0.0) (cpp/cos yaw-radians))

        ;; Accumulate wish direction
        wish-x (cond-> 0.0
                 forward (+ front-x)
                 backward (- front-x)
                 left (+ right-x)
                 right (- right-x))
        wish-z (cond-> 0.0
                 forward (+ front-z)
                 backward (- front-z)
                 left (+ right-z)
                 right (- right-z))

        ;; Apply friction (only when grounded)
        [vx vz] (if is-grounded
                  (pm-friction vx vz FRICTION STOP_SPEED delta-time)
                  [vx vz])

        ;; Accelerate (different rates for ground vs air)
        accel (if is-grounded GROUND_ACCEL AIR_ACCEL)
        [vx vz] (pm-accelerate vx vz wish-x wish-z MAX_SPEED accel delta-time)

        ;; Jump (only when grounded and pressing jump)
        [vy is-grounded] (if (and is-grounded jump)
                           [JUMP_VELOCITY false]
                           [vy is-grounded])

        ;; Apply gravity (only when airborne)
        vy (if (not is-grounded)
             (- vy (* GRAVITY delta-time))
             vy)

        ;; Integrate velocity to position
        new-px (+ px (* vx delta-time))
        new-py (+ py (* vy delta-time))
        new-pz (+ pz (* vz delta-time))

        ;; Clamp to ground (simple collision)
        [new-py vy is-grounded] (if (< new-py GROUND_HEIGHT)
                                  [GROUND_HEIGHT 0.0 true]
                                  [new-py vy is-grounded])]

    (-> state
        (update-in [:entities id] assoc
                   :transform/position [new-px new-py new-pz]
                   :physics/velocity [vx vy vz]
                   :physics/grounded is-grounded
                   :transform/pitch pitch
                   :transform/yaw yaw))))

(defmethod handle-event :default
  [state _]
  state)

(defmulti handle-command
  (fn [{:keys [command]}] (:command/name command)))

(defmethod handle-command :player/process-input
  [{:keys [command]}]
  (let [{:keys [exit]} command]
    (cond
      exit [{:event/type :system/exit}]
      ;; Always generate :player/moved to keep yaw in sync with camera
      :else [(-> command
                 (dissoc :command/name)
                 (assoc :event/type :player/moved))])))

(defmethod handle-command :default
  [])

(defn run-loop
  [{:keys [window event-store state]
    :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (let [_ (update-time context)
          _ (update-cursor context)
          command (process-input context)
          events (handle-command (assoc context :command command))
          _ (es/append event-store {:events events})
          _ (reset! state (reduce
                           (fn [state event]
                             (handle-event state (assoc context :event event)))
                           @state
                           (es/read event-store {})))
          _ (reset! event-store {:events []})]

      (draw-3D context)

      (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
      (cpp/glfwPollEvents))))

(defn setup-camera []
  {:follow-distance    (math/gimmie :boxed :float 5.0)   ; Distance behind player
   :follow-height      (math/gimmie :boxed :float 2.0)   ; Height above player
   :look-height-offset (math/gimmie :boxed :float 1.5)}) ; Look at head, not feet

(defn -main
  ([] (-main nil))
  ([x]
  (let [_ (cpp/glfwInit)
        window (setup-window {:width 1280 :height 720 :name "Learn OpenGL"})
        _ (cpp/glfwSetInputMode
           (cpp/unbox cpp/GLFWwindow* window)
           (cpp/value "GLFW_CURSOR")
           (cpp/value "GLFW_CURSOR_DISABLED"))
        shader (shaders/load-shader-program
                {:vertex-shader-path
                 "shaders/basic_vertex.glsl"
                 :fragment-shader-path
                 "shaders/basic_fragment.glsl"})
        _ (cpp/glUseProgram shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "uBaseColorTex") 0)
        camera (setup-camera)
        event-store (es/start {})
        _ (es/append event-store {:events [{:event/type :level/spawned
                                            :event/tags #{}
                                            :id #uuid "bbf1bbe7-a35d-4be1-ba62-6fe382a53345"
                                            :model "models/test-level.gltf"}
                                           {:event/type :player/spawned
                                            :id #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"
                                            :model "models/player.gltf"
                                            :transform/position [0.0 0.0 0.0]}]})]

    (run-loop {:event-store event-store
               :state (atom {})
               :window window
               :shader shader
               :models []
               :camera camera
               :delta-time          (math/gimmie :boxed :float 0.0)
               :last-frame          (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x       (math/gimmie :boxed :float 400.0)
               :cursor/last-y       (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity  (math/gimmie :boxed :float 0.05)
               :cursor/pitch        (math/gimmie :boxed :float 0.0)
               :cursor/yaw          (math/gimmie :boxed :float -90.0)}))))

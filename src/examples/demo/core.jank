(ns examples.demo.core
  (:require [engine.io.interface :as io]
            [engine.shaders.interface :as shaders]
            [engine.3d.geometry.interface :as geometry]
            [engine.3d.textures.interface :as textures]
            [engine.math.interface :as math]
            [engine.3d.gltf.interface :as gltf]
            [engine.events.interface :as es]
            [engine.3d.collision.interface :as collision]
            [engine.2d.text.interface :as text]
            [engine.2d.graphics.interface :as gfx2d]
            [engine.3d.animation.interface :as anim]
            [engine.3d.animation.state :as anim-state]
            [examples.demo.strafehelper.interface :as strafehelper]
            [examples.demo.server :as server]
            [examples.demo.client :as client]))

(cpp/raw "#include <GLFW/glfw3.h>")

(cpp/raw "#include <glm/glm.hpp>
          #include <glm/gtc/matrix_transform.hpp>
          #include <glm/gtc/type_ptr.hpp>")

(cpp/raw "#include <math.h>")

(cpp/raw
 "void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
      (void) window;
      glViewport(0, 0, width, height);
    }")

(def GLFW_PRESS (cpp/value "GLFW_PRESS"))
(def GLFW_KEY_ESCAPE (cpp/value "GLFW_KEY_ESCAPE"))
(def GLFW_KEY_W (cpp/value "GLFW_KEY_W"))
(def GLFW_KEY_S (cpp/value "GLFW_KEY_S"))
(def GLFW_KEY_A (cpp/value "GLFW_KEY_A"))
(def GLFW_KEY_D (cpp/value "GLFW_KEY_D"))
(def GLFW_KEY_F3 (cpp/value "GLFW_KEY_F3"))
(def GLFW_KEY_F4 (cpp/value "GLFW_KEY_F4"))
(def GLFW_KEY_SPACE (cpp/value "GLFW_KEY_SPACE"))

;; JKA-style physics constants (scaled for game world)
(def GRAVITY 25.6)
(def JUMP_VELOCITY 7.2)
(def FORCE_JUMP_STRENGTH 26.88)  ;; Level 3 force jump strength (840 scaled)
(def FORCE_JUMP_HEIGHT 12.3)     ;; Level 3 max height above jump start (384 scaled)
(def GROUND_ACCEL 10.0)
(def AIR_ACCEL 1.0)       ;; Key for JKA feel: 10:1 ratio
(def FRICTION 6.0)
(def STOP_SPEED 2.5)
(def MAX_SPEED 8.0)
(def GROUND_HEIGHT 0.1)

(defn process-input
  [{:keys [window delta-time cursor/pitch cursor/yaw]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cond-> {:command/name :player/process-input
             :id #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"
             :delta-time (float (math/*-> :float delta-time))
             :pitch (float (math/*-> :float pitch))
             :yaw (float (math/*-> :float yaw))}
      (= (cpp/glfwGetKey window GLFW_KEY_ESCAPE)
         GLFW_PRESS)
      (assoc :exit true)

      (= (cpp/glfwGetKey window GLFW_KEY_W) GLFW_PRESS)
      (assoc :forward true)

      (= (cpp/glfwGetKey window GLFW_KEY_S) GLFW_PRESS)
      (assoc :backward true)

      (= (cpp/glfwGetKey window GLFW_KEY_A) GLFW_PRESS)
      (assoc :left true)

      (= (cpp/glfwGetKey window GLFW_KEY_D) GLFW_PRESS)
      (assoc :right true)

      (= (cpp/glfwGetKey window GLFW_KEY_SPACE) GLFW_PRESS)
      (assoc :jump-held true)

      (= (cpp/glfwGetKey window GLFW_KEY_F3) GLFW_PRESS)
      (assoc :f3-pressed true)

      (= (cpp/glfwGetKey window GLFW_KEY_F4) GLFW_PRESS)
      (assoc :f4-pressed true))))

(defn setup-window
  [{:keys [width height name]}]

  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MAJOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_CONTEXT_VERSION_MINOR") 3)
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_PROFILE")
                      (cpp/value "GLFW_OPENGL_CORE_PROFILE"))
  (cpp/glfwWindowHint (cpp/value "GLFW_OPENGL_FORWARD_COMPAT")
                      (cpp/value "GL_TRUE"))

  (let [window (cpp/glfwCreateWindow width height name cpp/nullptr cpp/nullptr)]
    (when (cpp/! window)
      (println "Window creation failed")
      (cpp/exit 0))
    (cpp/glfwMakeContextCurrent window)
    (cpp/glfwSwapInterval 0)  ;; Disable VSync
    (cpp/glfwSetFramebufferSizeCallback window cpp/framebuffer_size_callback)
    (cpp/glEnable (cpp/value "GL_DEPTH_TEST"))
    (cpp/box window)))

(cpp/raw
 "glm::mat4* new_identity_matrix () {
    return new glm::mat4(1.0f);
  }")

(defn transform-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (if (contains? tags :transform)
    (let [[px py pz] (:transform/position entity)
          yaw (:transform/yaw entity 0.0)
          ;; Model rotation offset (some models face different directions)
          model-offset (if (contains? tags :animated) 90.0 0.0)
          ;; Mixamo models may need scaling
          model-scale (if (contains? tags :animated) 1.0 1.0)
          ;; Translate then rotate around Y axis (negate yaw to match camera direction)
          model-m (-> (cpp/identity_matrix)
                      (cpp/glm.translate (math/gimmie :vec3 [px py pz]))
                      (cpp/glm.rotate (cpp/glm.radians (cpp/- (cpp/float model-offset) (cpp/float yaw)))
                                      (math/gimmie :vec3 [0.0 1.0 0.0]))
                      (cpp/glm.scale (math/gimmie :vec3 [model-scale model-scale model-scale])))
          model-m-loc (cpp/glGetUniformLocation shader "model")]
      (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr model-m))
      :done)
    (let [model-m-loc (cpp/glGetUniformLocation shader "model")]
      (cpp/glUniformMatrix4fv model-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr (cpp/identity_matrix)))
      :done)))

(defn render-system
  [{:keys [shader]} {:keys [tags] :as entity}]
  (when (contains? tags :render)
    ((:draw (:model entity))
     {:shader shader
      :model/local-matrix-uniform "local"})))


(defn camera-system
  [{{:keys [follow-distance follow-height look-height-offset]} :camera
    :keys [shader state]
    :cursor/keys [yaw pitch]}]
  (when-let [player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])]
    (let [[px py pz] (:transform/position player)

          ;; Get parameters
          distance (math/*-> :float follow-distance)
          height (math/*-> :float follow-height)
          look-offset (math/*-> :float look-height-offset)
          player-yaw (math/*-> :float yaw)
          camera-pitch (math/*-> :float pitch)

          ;; Camera offset behind player (spherical coords)
          yaw-rad (cpp/glm.radians player-yaw)
          pitch-rad (cpp/glm.radians camera-pitch)

          ;; Horizontal offset: negate cos/sin to be BEHIND player
          offset-x (cpp/* (cpp/- (cpp/float 0.0) (cpp/cos yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-z (cpp/* (cpp/- (cpp/float 0.0) (cpp/sin yaw-rad))
                          (cpp/* distance (cpp/cos pitch-rad)))
          offset-y (cpp/+ height (cpp/* distance (cpp/sin pitch-rad)))

          ;; Camera world position
          camera-pos (cpp/glm.vec3
                      (cpp/+ (cpp/float px) offset-x)
                      (cpp/+ (cpp/float py) offset-y)
                      (cpp/+ (cpp/float pz) offset-z))

          ;; Look at player head
          look-target (cpp/glm.vec3 (cpp/float px)
                                    (cpp/+ (cpp/float py) look-offset)
                                    (cpp/float pz))
          camera-up (cpp/glm.vec3 (cpp/float 0.0) (cpp/float 1.0) (cpp/float 0.0))

          ;; Set view matrix
          view-m (cpp/glm.lookAt camera-pos look-target camera-up)
          view-m-loc (cpp/glGetUniformLocation shader "view")]
      (cpp/glUniformMatrix4fv view-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr view-m)))))

(defn update-animations
  "Advances animation time and samples for all animated entities.
   Only animates when player is moving, scales speed with velocity."
  [{:keys [state delta-time]}]
  (let [dt-raw (math/*-> :float delta-time)
        dt (double dt-raw)]
    (doseq [[id entity] (:entities @state)]
      (when (contains? (:tags entity) :animated)
        (let [[vx _ vz] (or (:physics/velocity entity) [0 0 0])
              grounded (:physics/grounded entity true)
              ;; Calculate horizontal speed
              horiz-speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float vx) (cpp/float vx))
                                           (cpp/* (cpp/float vz) (cpp/float vz))))
              ;; Select animation: 0=run, 1=jump
              anim-index (if grounded 0 1)
              ;; Only advance run animation if moving on ground
              is-moving (and grounded (> horiz-speed 0.5))
              current-time (double (:animation/time entity 0.0))
              run-duration (double (:animation/duration entity 1.0))
              jump-duration 0.85 ;; Jump animation duration
              ;; Calculate new time based on state
              new-time (cond
                         ;; In air: play jump once, hold at 30%
                         (not grounded)
                         (min (+ current-time (* dt 1.5)) (* jump-duration 0.3))
                         ;; On ground moving: advance run animation
                         is-moving
                         (mod (+ current-time (* dt (/ horiz-speed 8.0))) run-duration)
                         ;; On ground idle: reset to 0
                         :else 0.0)
              ;; Use appropriate duration for ratio
              duration (if grounded run-duration jump-duration)
              time-ratio (/ new-time duration)]
          ;; Sample animation at current time
          (anim/sample {:context (:animation/context entity)
                        :animation-index anim-index
                        :time-ratio time-ratio})
          ;; Update entity time
          (swap! state assoc-in [:entities id :animation/time] new-time))))))

(cpp/raw
 "void upload_identity_bones(GLint loc, int count) {
    // Upload identity matrices for debugging
    std::vector<float> identity_bones(count * 16);
    for (int i = 0; i < count; ++i) {
      // Identity matrix
      identity_bones[i*16 + 0] = 1.0f;
      identity_bones[i*16 + 5] = 1.0f;
      identity_bones[i*16 + 10] = 1.0f;
      identity_bones[i*16 + 15] = 1.0f;
    }
    glUniformMatrix4fv(loc, count, GL_FALSE, identity_bones.data());
  }")

(def DEBUG_NO_SKINNING false) ;; Set to true to test mesh without animation

(defn render-animated-system
  "Renders an animated entity with skinned shader"
  [{:keys [skinned-shader]} {:keys [tags] :as entity}]
  (when (contains? tags :animated)
    (let [meshes (:animation/meshes entity)
          vaos (:animation/vaos entity)
          ctx (:animation/context entity)
          ;; Set base color to skin tone (no texture for now)
          _ (cpp/glUniform4f (cpp/glGetUniformLocation skinned-shader "uBaseColorFactor")
                             (cpp/float 0.8) (cpp/float 0.6) (cpp/float 0.5) (cpp/float 1.0))
          _ (cpp/glUniform1i (cpp/glGetUniformLocation skinned-shader "uHasBaseColorTex") 0)]
      (doseq [mesh-idx (range (:animation/mesh-count entity 0))]
        (let [loc (cpp/glGetUniformLocation skinned-shader "uBoneMatrices")
              ;; Unbox inside the loop to avoid capture issues
              ctx-ptr (cpp/unbox cpp/AnimationContext* ctx)
              meshes-ptr (cpp/unbox (cpp/type "ozz::vector<ozz::sample::Mesh>*") meshes)]
          (if DEBUG_NO_SKINNING
            ;; Debug: upload identity matrices
            (let [mesh-info (anim/get-mesh-info {:meshes meshes :mesh-index mesh-idx})
                  joint-count (:joint-remap-count mesh-info)]
              (cpp/upload_identity_bones loc joint-count))
            ;; Normal: compute and upload skinning matrices directly
            (cpp/compute_and_upload_skinning_matrices ctx-ptr meshes-ptr (cpp/int mesh-idx) loc))
          ;; Draw mesh
          (let [vao-data (nth vaos mesh-idx)
                index-count (:index-count vao-data)]
            (cpp/glBindVertexArray (:vao vao-data))
            (cpp/glDrawElements (cpp/value "GL_TRIANGLES")
                                index-count
                                (cpp/value "GL_UNSIGNED_SHORT")
                                cpp/nullptr)))))))

(defn draw-3D
  [{:keys [state shader skinned-shader] :as context}]
  (let [_ (cpp/glClearColor 0.2 0.3 0.3 1.0)
        _ (cpp/glClear (cpp/| (cpp/value "GL_COLOR_BUFFER_BIT") (cpp/value "GL_DEPTH_BUFFER_BIT")))

        projection-m (cpp/glm.perspective (cpp/glm.radians (cpp/float 97.0))
                                          (cpp// (cpp/float 1280.0) (cpp/float 720.0))
                                          (cpp/float 0.1)
                                          (cpp/float 100.0))]

    ;; Render non-animated entities with basic shader
    (cpp/glUseProgram shader)
    (let [projection-m-loc (cpp/glGetUniformLocation shader "projection")]
      (cpp/glUniformMatrix4fv projection-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr projection-m)))
    (camera-system context)
    (doseq [e (vals (:entities @state))]
      (when-not (contains? (:tags e) :animated)
        (transform-system context e)
        (render-system context e)))

    ;; Render animated entities with skinned shader
    (cpp/glDisable (cpp/value "GL_CULL_FACE")) ;; Disable culling for animated meshes
    (cpp/glUseProgram skinned-shader)
    (let [projection-m-loc (cpp/glGetUniformLocation skinned-shader "projection")]
      (cpp/glUniformMatrix4fv projection-m-loc 1 (cpp/value "GL_FALSE") (cpp/glm.value_ptr projection-m)))
    (camera-system (assoc context :shader skinned-shader))
    (doseq [e (vals (:entities @state))]
      (when (contains? (:tags e) :animated)
        (transform-system (assoc context :shader skinned-shader) e)
        (render-animated-system context e)))))

(defn update-cursor
  [{:cursor/keys [last-x last-y sensitivity yaw pitch initialized?]
    :keys [window]}]
  (let [cursor-x (cpp/double)
        cursor-y (cpp/double)

        _ (cpp/glfwGetCursorPos (cpp/unbox cpp/GLFWwindow* window)
                                (cpp/& cursor-x)
                                (cpp/& cursor-y))

        cursor-last-x (math/*-> :float last-x)
        cursor-last-y (math/*-> :float last-y)

        _ (when-not @initialized?
            (cpp/= cursor-last-x cursor-x)
            (cpp/= cursor-last-y cursor-y)
            (reset! initialized? true))

        cursor-sensitivity (math/*-> :float sensitivity)

        x-offset (cpp/* (cpp/- cursor-x cursor-last-x) cursor-sensitivity)
        y-offset (cpp/* (cpp/- cursor-last-y cursor-y) cursor-sensitivity)

        cursor-yaw (math/*-> :float yaw)
        cursor-pitch (math/*-> :float pitch)]

    (cpp/= cursor-yaw (cpp/+ cursor-yaw x-offset))
    (cpp/= cursor-pitch (cpp/- cursor-pitch y-offset))

    (cpp/= cursor-last-x cursor-x)
    (cpp/= cursor-last-y cursor-y)

    ;; Pitch constraints for third-person camera
    (when (cpp/> cursor-pitch (cpp/float 60.0))
      (cpp/= cursor-pitch (cpp/float 60.0)))

    (when (cpp/< cursor-pitch (cpp/float -30.0))
      (cpp/= cursor-pitch (cpp/float -30.0)))))

(defn update-time
  [{:keys [delta-time last-frame]}]
  (let [current-frame (cpp/glfwGetTime)
        delta-time (math/*-> :float delta-time)
        last-frame (math/*-> :float last-frame)]
    (cpp/= delta-time (cpp/- current-frame last-frame))
    (cpp/= last-frame current-frame)))

(defmulti handle-event
  (fn [state {:keys [event]}] (:event/type event)))

(defmethod handle-event :system/exit
  [state {:keys [window]}]
  (let [window (cpp/unbox cpp/GLFWwindow* window)]
    (cpp/glfwSetWindowShouldClose window 1)
    state))

(defmethod handle-event :level/spawned
  [state {{:keys [id] :as event} :event}]
  (let [loaded (gltf/load {:model (gltf/parse {:path (:model event)})
                           :base-path "models/"})]
    (-> state
        (assoc :level-collision (when-let [col (first (:collision loaded))]
                              (collision/prepare-collision-mesh col)))
        (update :entities assoc id
                (-> event
                    (select-keys [:id])
                    (assoc :model loaded)
                    (update :tags (fnil conj #{}) :render))))))

(defn init-player-animation
  "Initialize player animation system with ozz assets"
  []
  (let [ctx (anim/create-context)
        ;; Load Mixamo skeleton + mesh + animations (all compatible)
        skeleton-info (anim/load-skeleton {:path "models/player/mixamo_skeleton.ozz"
                                           :context ctx})
        ;; Animation 0: run
        run-info (anim/load-animation {:path "models/player/run.ozz"
                                       :context ctx})
        ;; Animation 1: crouch (used when in air)
        jump-info (anim/load-animation {:path "models/player/crouch.ozz"
                                        :context ctx})
        mesh-data (anim/load-meshes {:path "models/player/mixamo_mesh.ozz"})
        ;; Sample animation at time 0 to initialize bone matrices
        _ (anim/sample {:context ctx :animation-index 0 :time-ratio 0.0})
        ;; Create OpenGL VAOs for each mesh
        mesh-count (:count mesh-data)
        vaos (mapv (fn [i]
                     (let [mesh-info (anim/get-mesh-info {:meshes (:meshes mesh-data) :mesh-index i})
                           vao (anim/create-skinned-vao {:meshes (:meshes mesh-data)
                                                          :mesh-index i})]
                       (println "  Mesh" i ":"
                                "verts=" (:vertex-count mesh-info)
                                "indices=" (:index-count mesh-info)
                                "joints=" (:joint-remap-count mesh-info)
                                "skinned=" (:skinned? mesh-info))
                       vao))
                   (range mesh-count))]
    (println "Animation system initialized:")
    (println "  Skeleton joints:" (:num-joints skeleton-info))
    (println "  Run animation duration:" (:duration run-info) "seconds")
    (println "  Crouch animation duration:" (:duration jump-info) "seconds")
    (println "  Mesh count:" mesh-count)
    (println "  VAOs created:" (count vaos))
    {:animation/context ctx
     :animation/current-index 0
     :animation/duration (:duration run-info)
     :animation/meshes (:meshes mesh-data)
     :animation/mesh-count mesh-count
     :animation/vaos vaos
     :animation/time 0.0}))

(defmethod handle-event :player/spawned
  [state {{:keys [id] :as event} :event}]
  (let [;; Try to load animation, fall back to static model
        animation-data (init-player-animation)]
    (update state :entities assoc id
            (-> event
                (select-keys [:id :model :transform/position])
                (assoc :transform/pitch 0.0
                       :transform/yaw -90.0
                       :physics/velocity [0.0 0.0 0.0]
                       :physics/grounded true
                       :physics/jump-z-start nil)
                ;; Use static model for now, animation rendering to be added
                (update :model #(gltf/load {:model (gltf/parse {:path %})
                                            :base-path "models/"}))
                (merge animation-data)
                (update :tags (fnil into #{})
                        (if animation-data
                          [:render :transform :camera :animated]
                          [:render :transform :camera]))))))

(defn pm-friction
  "JKA-style friction - reduces horizontal velocity"
  [vx vz friction stopspeed dt]
  (let [vx-f (cpp/float vx)
        vz-f (cpp/float vz)
        speed (cpp/float (cpp/sqrt (cpp/+ (cpp/* vx-f vx-f) (cpp/* vz-f vz-f))))]
    (if (cpp/< speed (cpp/float 0.1))
      [(cpp/float 0.0) (cpp/float 0.0)]
      (let [stopspeed-f (cpp/float stopspeed)
            control (if (cpp/< speed stopspeed-f) stopspeed-f speed)
            drop (cpp/* control (cpp/* (cpp/float friction) (cpp/float dt)))
            newspeed-raw (cpp/- speed drop)
            newspeed (if (cpp/< newspeed-raw (cpp/float 0.0)) (cpp/float 0.0) newspeed-raw)
            scale (cpp// newspeed speed)]
        [(cpp/* vx-f scale) (cpp/* vz-f scale)]))))

(defn pm-accelerate
  "JKA-style acceleration toward wish direction"
  [vx vz dx dz wishspeed accel dt]
  (let [dx-f (cpp/float dx)
        dz-f (cpp/float dz)
        vx-f (cpp/float vx)
        vz-f (cpp/float vz)
        wish-len (cpp/float (cpp/sqrt (cpp/+ (cpp/* dx-f dx-f) (cpp/* dz-f dz-f))))]
    (if (cpp/< wish-len (cpp/float 0.001))
      [vx-f vz-f]
      (let [dx-norm (cpp// dx-f wish-len)
            dz-norm (cpp// dz-f wish-len)
            currentspeed (cpp/+ (cpp/* vx-f dx-norm) (cpp/* vz-f dz-norm))
            addspeed (cpp/- (cpp/float wishspeed) currentspeed)]
        (if (cpp/<= addspeed (cpp/float 0.0))
          [vx-f vz-f]
          (let [accelspeed (cpp/* (cpp/float accel)
                                  (cpp/* (cpp/float dt) (cpp/float wishspeed)))
                accelspeed (if (cpp/> accelspeed addspeed) addspeed accelspeed)]
            [(cpp/+ vx-f (cpp/* accelspeed dx-norm))
             (cpp/+ vz-f (cpp/* accelspeed dz-norm))]))))))

(defmethod handle-event :player/moved
  [{:keys [entities level-collision] :as state}
   {{:keys [id forward backward left right jump-held yaw pitch delta-time]} :event}]
  (let [player (get entities id)
        [px py pz] (:transform/position player)
        [vx vy vz] (:physics/velocity player [0.0 0.0 0.0])
        jump-z-start (:physics/jump-z-start player)

        ;; Ground detection via raycast
        ground-y (when level-collision
                   (collision/raycast-ground level-collision [px py pz]))
        is-grounded (and ground-y (<= py (+ ground-y 0.2)))

        ;; Build wish direction from input
        yaw-radians (cpp/glm.radians (cpp/float yaw))
        front-x (cpp/cos yaw-radians)
        front-z (cpp/sin yaw-radians)
        right-x (cpp/sin yaw-radians)
        right-z (cpp/- (cpp/float 0.0) (cpp/cos yaw-radians))

        ;; Accumulate wish direction
        wish-x (cond-> 0.0
                 forward (+ front-x)
                 backward (- front-x)
                 left (+ right-x)
                 right (- right-x))
        wish-z (cond-> 0.0
                 forward (+ front-z)
                 backward (- front-z)
                 left (+ right-z)
                 right (- right-z))

        ;; Apply friction (only when grounded)
        [vx vz] (if is-grounded
                  (pm-friction vx vz FRICTION STOP_SPEED delta-time)
                  [vx vz])

        ;; Accelerate (different rates for ground vs air)
        accel (if is-grounded GROUND_ACCEL AIR_ACCEL)
        [vx vz] (pm-accelerate vx vz wish-x wish-z MAX_SPEED accel delta-time)

        ;; Clear jump-z-start when not holding jump (resets jump state)
        ;; This allows re-jumping if player releases and presses again mid-air
        jump-z-start (if (not jump-held) nil jump-z-start)

        ;; Initial jump (grounded + button pressed + not already jumping)
        [vy is-grounded jump-z-start]
        (if (and is-grounded jump-held (nil? jump-z-start))
          [JUMP_VELOCITY false py]  ;; Start jump, record starting Y
          [vy is-grounded jump-z-start])

        ;; Force Jump thrust (JKA Metroid-style)
        ;; Thrust scales down as you approach max height
        ;; Formula: vy = (maxHeight - curHeight) / maxHeight * strength / 10 + JUMP_VELOCITY
        vy (if (and (not is-grounded)
                    jump-held
                    jump-z-start
                    (> vy 0))
             (let [cur-height (- py jump-z-start)]
               (if (< cur-height FORCE_JUMP_HEIGHT)
                 ;; Still have headroom - apply scaled thrust
                 (+ (/ (* (/ (- FORCE_JUMP_HEIGHT cur-height) FORCE_JUMP_HEIGHT)
                          FORCE_JUMP_STRENGTH)
                       10.0)
                    JUMP_VELOCITY)
                 ;; At max height - cap at normal jump velocity
                 (min vy JUMP_VELOCITY)))
             vy)

        ;; Apply gravity (always when airborne)
        vy (if (not is-grounded)
             (- vy (* GRAVITY delta-time))
             vy)

        ;; Integrate velocity to position
        new-px (+ px (* vx delta-time))
        new-py (+ py (* vy delta-time))
        new-pz (+ pz (* vz delta-time))

        ;; Clamp to ground (raycast collision)
        ground-y-at-new-pos (when level-collision
                              (collision/raycast-ground level-collision [new-px new-py new-pz]))
        [new-py vy is-grounded] (if (and ground-y-at-new-pos (< new-py ground-y-at-new-pos))
                                  [ground-y-at-new-pos 0.0 true]
                                  [new-py vy is-grounded])]

    (-> state
        (update-in [:entities id] assoc
                   :transform/position [new-px new-py new-pz]
                   :physics/velocity [vx vy vz]
                   :physics/grounded is-grounded
                   :physics/jump-z-start jump-z-start
                   :transform/pitch pitch
                   :transform/yaw yaw))))

(defmethod handle-event :debug/toggled
  [state _]
  (update state :debug/overlay-visible not))

(defmethod handle-event :debug/f3-updated
  [state {{:keys [pressed]} :event}]
  (assoc state :debug/f3-was-pressed pressed))

(defmethod handle-event :strafehelper/toggled
  [state _]
  (update state :strafehelper/visible not))

(defmethod handle-event :strafehelper/f4-updated
  [state {{:keys [pressed]} :event}]
  (assoc state :strafehelper/f4-was-pressed pressed))

(defmethod handle-event :default
  [state _]
  state)

(defmulti handle-command
  (fn [{:keys [command]}] (:command/name command)))

(defmethod handle-command :player/process-input
  [{:keys [command state]}]
  (let [{:keys [exit f3-pressed f4-pressed]} command
        f3-was-pressed (:debug/f3-was-pressed @state)
        f4-was-pressed (:strafehelper/f4-was-pressed @state)]
    (cond
      exit [{:event/type :system/exit}]
      :else (cond-> [(-> command
                         (dissoc :command/name :f3-pressed :f4-pressed)
                         (assoc :event/type :player/moved))]
              ;; Toggle debug on F3 press (not hold)
              (and f3-pressed (not f3-was-pressed))
              (conj {:event/type :debug/toggled})

              ;; Always track F3 state for debouncing
              true
              (conj {:event/type :debug/f3-updated :pressed f3-pressed})

              ;; Toggle strafehelper on F4 press (not hold)
              (and f4-pressed (not f4-was-pressed))
              (conj {:event/type :strafehelper/toggled})

              ;; Always track F4 state for debouncing
              true
              (conj {:event/type :strafehelper/f4-updated :pressed f4-pressed})))))

(defmethod handle-command :default
  [])

(defn run-loop
  [{:keys [window event-store state delta-time gfx2d]
    :as context}]
  (while (cpp/! (cpp/glfwWindowShouldClose (cpp/unbox cpp/GLFWwindow* window)))
    (let [_ (update-time context)
          _ (update-cursor context)
          command (process-input context)
          events (handle-command (assoc context :command command :state state))
          _ (es/append event-store {:events events})
          _ (reset! state (reduce
                           (fn [state event]
                             (handle-event state (assoc context :event event)))
                           @state
                           (es/read event-store {})))
          _ (reset! event-store {:events []})
          ;; Update animations before rendering
          _ (update-animations context)]

      (draw-3D context)

      ;; Render debug overlay (F3 to toggle)
      (when (get @state :debug/overlay-visible true)
        (let [dt (math/*-> :float delta-time)
              fps (if (> dt 0.0) (/ 1.0 dt) 0.0)
              player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])
              [px py pz] (or (:transform/position player) [0 0 0])
              [vx vy vz] (or (:physics/velocity player) [0 0 0])
              grounded (:physics/grounded player)
              speed (cpp/sqrt (cpp/+ (cpp/* (cpp/float. vx) (cpp/float. vx))
                                     (cpp/* (cpp/float. vz) (cpp/float. vz))))]
          (text/render-text (str "FPS: " (int fps)) 10.0 30.0 [1.0 1.0 1.0] 1280 720)
          (text/render-text (str "Pos: " (int px) ", " (int py) ", " (int pz))
                            10.0 55.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Vel: " (int vx) ", " (int vy) ", " (int vz))
                            10.0 80.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Speed: " (int speed)) 10.0 105.0 [0.8 0.8 0.8] 1280 720)
          (text/render-text (str "Grounded: " grounded) 10.0 130.0
                            (if grounded [0.5 1.0 0.5] [1.0 0.5 0.5]) 1280 720)))

      ;; Render strafehelper (F4 to toggle)
      (when (get @state :strafehelper/visible false)
        (let [player (get-in @state [:entities #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"])
              velocity (or (:physics/velocity player) [0 0 0])
              yaw (:transform/yaw player 0.0)
              grounded (:physics/grounded player false)]
          (strafehelper/render-strafehelper gfx2d velocity yaw grounded 1280 720)))

      (cpp/glfwSwapBuffers (cpp/unbox cpp/GLFWwindow* window))
      (cpp/glfwPollEvents))))

(defn setup-camera []
  {:follow-distance    (math/gimmie :boxed :float 2.5)   ; Distance behind player
   :follow-height      (math/gimmie :boxed :float 1.0)   ; Height above player
   :look-height-offset (math/gimmie :boxed :float 1.2)}) ; Look at head, not feet

(defn run-solo
  "Run the game in solo (offline) mode."
  []
  (let [_ (cpp/glfwInit)
        window (setup-window {:width 1280 :height 720 :name "Demo - Solo"})
        _ (cpp/glfwSetInputMode
           (cpp/unbox cpp/GLFWwindow* window)
           (cpp/value "GLFW_CURSOR")
           (cpp/value "GLFW_CURSOR_DISABLED"))
        shader (shaders/load-shader-program
                {:vertex-shader-path
                 "shaders/basic_vertex.glsl"
                 :fragment-shader-path
                 "shaders/basic_fragment.glsl"})
        _ (cpp/glUseProgram shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation shader "uBaseColorTex") 0)
        skinned-shader (shaders/load-shader-program
                        {:vertex-shader-path "shaders/skinned_vertex.glsl"
                         :fragment-shader-path "shaders/skinned_fragment.glsl"})
        _ (cpp/glUseProgram skinned-shader)
        _ (cpp/glUniform1i (cpp/glGetUniformLocation skinned-shader "uBaseColorTex") 0)
        text-shader (shaders/load-shader-program
                     {:vertex-shader-path "shaders/text_vertex.glsl"
                      :fragment-shader-path "shaders/text_fragment.glsl"})
        _ (text/init-font "fonts/JetBrainsMono-Regular.ttf" 24.0 text-shader)
        graphics2d-shader (shaders/load-shader-program
                           {:vertex-shader-path "shaders/graphics2d_vertex.glsl"
                            :fragment-shader-path "shaders/graphics2d_fragment.glsl"})
        gfx2d (gfx2d/init-graphics2d graphics2d-shader)
        camera (setup-camera)
        event-store (es/start {})
        _ (es/append event-store {:events [{:event/type :level/spawned
                                            :event/tags #{}
                                            :id #uuid "bbf1bbe7-a35d-4be1-ba62-6fe382a53345"
                                            :model "models/hills.gltf"}
                                           {:event/type :player/spawned
                                            :id #uuid "9064c2d4-b202-4acf-a0de-eca1e8358a8d"
                                            :model "models/player.gltf"
                                            :transform/position [0.0 50.0 0.0]}]})]

    (run-loop {:event-store event-store
               :state (atom {})
               :window window
               :shader shader
               :skinned-shader skinned-shader
               :models []
               :camera camera
               :gfx2d gfx2d
               :delta-time          (math/gimmie :boxed :float 0.0)
               :last-frame          (math/gimmie :boxed :float 0.0)
               :cursor/initialized? (atom false)
               :cursor/last-x       (math/gimmie :boxed :float 400.0)
               :cursor/last-y       (math/gimmie :boxed :float 300.0)
               :cursor/sensitivity  (math/gimmie :boxed :float 0.05)
               :cursor/pitch        (math/gimmie :boxed :float 0.0)
               :cursor/yaw          (math/gimmie :boxed :float -90.0)})))

(defn -main
  "Entry point. Usage:
     ./run demo              - Solo mode (offline)
     ./run demo server       - Start server on port 7777
     ./run demo client       - Connect to localhost:7777
     ./run demo client <ip>  - Connect to specific server"
  ([] (run-solo))
  ([mode]
   (cond
     (= mode "server")
     (server/run-server)

     (= mode "client")
     (client/run-client)

     :else
     (do
       (println "Unknown mode:" mode)
       (println "Usage:")
       (println "  ./run demo              - Solo mode (offline)")
       (println "  ./run demo server       - Start server on port 7777")
       (println "  ./run demo client       - Connect to localhost:7777")
       (println "  ./run demo client <ip>  - Connect to specific server"))))
  ([mode server-address]
   (if (= mode "client")
     (client/run-client server-address)
     (do
       (println "Unknown mode:" mode)
       (println "Extra argument only valid for 'client' mode")))))

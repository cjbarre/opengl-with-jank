(ns examples.demo.animation.jka
  "JKA animation state machine with directional movement animations.

   Implements authentic JKA movement mechanics:
   - Rolls: crouch + running on ground
   - Flips: force jump + direction in air
   - Wall runs: jump toward wall + strafe
   - Wall flip back: forward into wall + jump

   All animation selection is input-driven, not velocity-driven."
  (:require [engine.3d.animation.interface :as anim]))

;; =============================================================================
;; Animation Name Mappings
;; =============================================================================

;; Movement state -> direction -> animation name
(def ANIMATION_MAP
  {:idle      {:forward "BOTH_STAND1"
               :backward "BOTH_STAND1"
               :left "BOTH_STAND1"
               :right "BOTH_STAND1"
               :none "BOTH_STAND1"}

   :walk      {:forward "BOTH_WALK1"
               :backward "BOTH_WALKBACK1"
               :left "BOTH_WALK1"
               :right "BOTH_WALK1"
               :none "BOTH_WALK1"}

   :run       {:forward "BOTH_RUN1"
               :backward "BOTH_RUNBACK1"
               :left "BOTH_RUN1"
               :right "BOTH_RUN1"
               :none "BOTH_RUN1"}

   :jump      {:forward "BOTH_JUMP1"
               :backward "BOTH_JUMPBACK1"
               :left "BOTH_JUMPLEFT1"
               :right "BOTH_JUMPRIGHT1"
               :none "BOTH_JUMP1"}

   :inair     {:forward "BOTH_INAIR1"
               :backward "BOTH_INAIRBACK1"
               :left "BOTH_INAIRLEFT1"
               :right "BOTH_INAIRRIGHT1"
               :none "BOTH_INAIR1"}

   :land      {:forward "BOTH_LAND1"
               :backward "BOTH_LANDBACK1"
               :left "BOTH_LANDLEFT1"
               :right "BOTH_LANDRIGHT1"
               :none "BOTH_LAND1"}

   :forcejump {:forward "BOTH_FORCEJUMP1"
               :backward "BOTH_FORCEJUMPBACK1"
               :left "BOTH_FORCEJUMPLEFT1"
               :right "BOTH_FORCEJUMPRIGHT1"
               :none "BOTH_FORCEJUMP1"}

   :forceinair {:forward "BOTH_FORCEINAIR1"
                :backward "BOTH_FORCEINAIRBACK1"
                :left "BOTH_FORCEINAIRLEFT1"
                :right "BOTH_FORCEINAIRRIGHT1"
                :none "BOTH_FORCEINAIR1"}

   :forceland {:forward "BOTH_FORCELAND1"
               :backward "BOTH_FORCELANDBACK1"
               :left "BOTH_FORCELANDLEFT1"
               :right "BOTH_FORCELANDRIGHT1"
               :none "BOTH_FORCELAND1"}

   ;; Rolls - single animation per direction (no :none variant, use forward)
   :roll      {:forward "BOTH_ROLL_F"
               :backward "BOTH_ROLL_B"
               :left "BOTH_ROLL_L"
               :right "BOTH_ROLL_R"
               :none "BOTH_ROLL_F"}

   ;; Flips - acrobatic jumps with direction
   :flip      {:forward "BOTH_FLIP_F"
               :backward "BOTH_FLIP_B"
               :left "BOTH_FLIP_L"
               :right "BOTH_FLIP_R"
               :none "BOTH_FLIP_F"}

   ;; Wall running - only left/right directions apply
   :wallrun   {:forward "BOTH_WALL_RUN_RIGHT"  ; default to right
               :backward "BOTH_WALL_RUN_RIGHT"
               :left "BOTH_WALL_RUN_LEFT"
               :right "BOTH_WALL_RUN_RIGHT"
               :none "BOTH_WALL_RUN_RIGHT"}

   ;; Wall run flip off - jump while wall running
   :wallrunflip {:forward "BOTH_WALL_RUN_RIGHT_FLIP"
                 :backward "BOTH_WALL_RUN_RIGHT_FLIP"
                 :left "BOTH_WALL_RUN_LEFT_FLIP"
                 :right "BOTH_WALL_RUN_RIGHT_FLIP"
                 :none "BOTH_WALL_RUN_RIGHT_FLIP"}

   ;; Wall flip back - run into wall and flip back
   :wallflipback {:forward "BOTH_WALL_FLIP_BACK1"
                  :backward "BOTH_WALL_FLIP_BACK1"
                  :left "BOTH_WALL_FLIP_LEFT"
                  :right "BOTH_WALL_FLIP_RIGHT"
                  :none "BOTH_WALL_FLIP_BACK1"}})

;; Core movement animations to load
(def MOVEMENT_ANIMATIONS
  ["BOTH_STAND1" "BOTH_STAND2"
   "BOTH_WALK1" "BOTH_WALKBACK1"
   "BOTH_RUN1" "BOTH_RUNBACK1"
   "BOTH_JUMP1" "BOTH_JUMPBACK1" "BOTH_JUMPLEFT1" "BOTH_JUMPRIGHT1"
   "BOTH_INAIR1" "BOTH_INAIRBACK1" "BOTH_INAIRLEFT1" "BOTH_INAIRRIGHT1"
   "BOTH_LAND1" "BOTH_LANDBACK1" "BOTH_LANDLEFT1" "BOTH_LANDRIGHT1"
   "BOTH_FORCEJUMP1" "BOTH_FORCEJUMPBACK1" "BOTH_FORCEJUMPLEFT1" "BOTH_FORCEJUMPRIGHT1"
   "BOTH_FORCEINAIR1" "BOTH_FORCEINAIRBACK1" "BOTH_FORCEINAIRLEFT1" "BOTH_FORCEINAIRRIGHT1"
   "BOTH_FORCELAND1" "BOTH_FORCELANDBACK1" "BOTH_FORCELANDLEFT1" "BOTH_FORCELANDRIGHT1"
   ;; Rolls
   "BOTH_ROLL_F" "BOTH_ROLL_B" "BOTH_ROLL_L" "BOTH_ROLL_R"
   ;; Flips
   "BOTH_FLIP_F" "BOTH_FLIP_B" "BOTH_FLIP_L" "BOTH_FLIP_R"
   ;; Wall running
   "BOTH_WALL_RUN_LEFT" "BOTH_WALL_RUN_RIGHT"
   "BOTH_WALL_RUN_LEFT_FLIP" "BOTH_WALL_RUN_RIGHT_FLIP"
   "BOTH_WALL_RUN_LEFT_STOP" "BOTH_WALL_RUN_RIGHT_STOP"
   ;; Wall flips
   "BOTH_WALL_FLIP_BACK1" "BOTH_WALL_FLIP_LEFT" "BOTH_WALL_FLIP_RIGHT"])

;; =============================================================================
;; Constants
;; =============================================================================

(def LAND_DURATION 0.2)           ; Seconds to play landing animation
(def FLIP_HOLD_TIME 0.3)          ; Seconds jump must be held before flip triggers
(def WALL_RUN_MIN_HEIGHT 0.5)     ; Minimum height above ground for wall run

;; =============================================================================
;; State Machine
;; =============================================================================

(defn create-jka-state
  "Creates initial JKA animation state"
  []
  {:movement-state :idle           ; :idle :walk :run :jump :inair :land :roll :flip :wallrun :wallflipback
   :direction :forward             ; :forward :backward :left :right :none
   :current-anim "BOTH_STAND1"
   :current-time 0.0
   :was-grounded true
   :land-timer 0.0                 ; Countdown for landing animation
   :roll-timer 0.0                 ; Time remaining in roll animation
   :flip-timer 0.0                 ; Time remaining in flip animation
   :wallrun-timer 0.0              ; Time remaining in wall run
   :wallflip-timer 0.0             ; Time remaining in wall flip
   :air-time 0.0                   ; Time spent in air
   :was-jump-held false            ; Track jump key state for edge detection
   :had-movement-this-jump false   ; True if movement keys were held at any point during this jump
   :flip-ready false               ; True if holding movement+jump on takeoff (for bunny hop flips)
   :jump-held-since-takeoff true   ; True if jump has been held continuously since leaving ground
   :has-flipped-this-jump false    ; True if already did a flip during this jump
   :wallrun-side :none})

(defn direction-from-input
  "Gets direction keyword from input keys.
   Priority: forward > backward > left > right"
  [{:keys [forward backward left right]}]
  (cond
    forward :forward
    backward :backward
    left :left
    right :right
    :else :none))

(defn get-animation-name
  "Gets animation name for movement state and direction"
  [movement-state direction]
  (let [state-map (get ANIMATION_MAP movement-state)]
    (if state-map
      (get state-map direction "BOTH_STAND1")
      "BOTH_STAND1")))

(defn is-locked-anim?
  "Check if we're in an animation that must play to completion"
  [movement-state timer]
  (and (or (= movement-state :roll)
           (= movement-state :flip)
           (= movement-state :wallrun)
           (= movement-state :wallrunflip)
           (= movement-state :wallflipback))
       (> timer 0.0)))

(defn update-jka-state
  "Updates JKA animation state based on input keys.
   input: {:forward bool :backward bool :left bool :right bool :grounded bool
           :crouch bool :jump-held bool :speed float :height float :vy float
           :wall-left bool :wall-right bool :wall-front bool}
   Returns updated state."
  [{:keys [movement-state direction current-anim current-time
           was-grounded land-timer roll-timer flip-timer wallrun-timer wallflip-timer
           air-time was-jump-held had-movement-this-jump flip-ready jump-held-since-takeoff has-flipped-this-jump wallrun-side] :as state}
   {:keys [forward backward left right grounded crouch jump-held speed height vy
           wall-left wall-right wall-front] :as input}
   dt
   anim-durations]  ; map of anim-name -> duration

  (let [;; Default values for optional inputs
        speed (or speed 0.0)
        height (or height 0.0)
        vy (or vy 0.0)  ; vertical velocity - positive = rising, negative = falling
        crouch (or crouch false)
        jump-held (or jump-held false)
        wall-left (or wall-left false)
        wall-right (or wall-right false)
        wall-front (or wall-front false)
        air-time (or air-time 0.0)
        had-movement-this-jump (or had-movement-this-jump false)
        flip-ready (or flip-ready false)
        jump-held-since-takeoff (if (nil? jump-held-since-takeoff) true jump-held-since-takeoff)
        has-flipped-this-jump (or has-flipped-this-jump false)

        ;; Determine if player is rising or falling
        ;; JKA uses velocity[2] <= 0 to trigger inair/glide animation
        is-falling (and (not grounded) (<= vy 0.0))

        ;; Direction from input keys
        new-direction (direction-from-input input)
        has-movement-input (or forward backward left right)

        ;; Detect state transitions
        just-landed (and grounded (not was-grounded))
        just-jumped (and (not grounded) was-grounded)
        just-pressed-jump (and jump-held (not was-jump-held))

        ;; Get current timer for locked animation check
        current-timer (cond
                        (= movement-state :roll) roll-timer
                        (= movement-state :flip) flip-timer
                        (= movement-state :wallrun) wallrun-timer
                        (or (= movement-state :wallrunflip)
                            (= movement-state :wallflipback)) wallflip-timer
                        :else 0.0)

        ;; Check if we're in a locked animation that must complete
        locked? (is-locked-anim? movement-state current-timer)

        ;; Update timers (decrement all active timers)
        new-roll-timer (if (> roll-timer 0.0) (max 0.0 (- roll-timer dt)) 0.0)
        new-flip-timer (if (> flip-timer 0.0) (max 0.0 (- flip-timer dt)) 0.0)
        new-wallrun-timer (if (> wallrun-timer 0.0) (max 0.0 (- wallrun-timer dt)) 0.0)
        new-wallflip-timer (if (> wallflip-timer 0.0) (max 0.0 (- wallflip-timer dt)) 0.0)

        ;; Track air time - reset on each new jump, increment when in air
        new-air-time (cond
                       grounded 0.0
                       just-jumped dt      ; Fresh jump starts at dt, not accumulated
                       :else (+ air-time dt))

        ;; Track if movement keys were held at any point during this jump
        ;; Reset when grounded, set to true if movement input detected while in air
        new-had-movement-this-jump (if grounded
                                     false
                                     (or had-movement-this-jump has-movement-input))

        ;; Track if jump has been held continuously since leaving ground
        ;; On takeoff frame, check if holding jump. Then track continuously.
        new-jump-held-since-takeoff (cond
                                      grounded true                           ; Ready for next jump
                                      just-jumped jump-held                   ; On takeoff, set based on current hold
                                      (not jump-held) false                   ; Released jump mid-air
                                      :else jump-held-since-takeoff)          ; Keep current state

        ;; Track if already flipped during this jump - reset when grounded
        new-has-flipped-this-jump (if grounded false has-flipped-this-jump)

        ;; Flip can trigger when: in air + holding jump continuously + direction + not already flipping
        ;; Either: waited long enough OR flip was "ready" from previous jump
        can-flip (and (not grounded)
                      jump-held
                      new-jump-held-since-takeoff              ; Must have held jump since takeoff
                      has-movement-input
                      (not new-has-flipped-this-jump)          ; Only one flip per jump
                      (or flip-ready                           ; Ready from bunny hop
                          (> new-air-time FLIP_HOLD_TIME))     ; Or held long enough this jump
                      (not= movement-state :flip)              ; Not already flipping
                      (= flip-timer 0.0))

        ;; Mark that we've flipped if can-flip is true
        new-has-flipped-this-jump (or new-has-flipped-this-jump can-flip)

        ;; Track flip-ready: becomes true when you've earned a flip (held long enough or triggered one)
        ;; Stays true as long as you keep holding movement keys (for bunny hop chains)
        ;; You may release jump briefly to trigger new jumps, but keep movement held
        new-flip-ready (cond
                         ;; Became ready: held long enough to earn a flip
                         can-flip true
                         ;; Stay ready as long as holding movement (in air or on ground)
                         has-movement-input flip-ready
                         ;; Reset when movement keys released
                         :else false)

        ;; Determine new movement state
        [new-movement-state new-roll-timer new-flip-timer new-wallrun-timer new-wallflip-timer new-wallrun-side]
        (cond
          ;; If locked in animation, continue until timer expires
          locked?
          [movement-state new-roll-timer new-flip-timer new-wallrun-timer new-wallflip-timer wallrun-side]

          ;; Just landed - check for roll (crouch + movement input)
          ;; JKA: Roll triggers on landing if crouching while moving
          (and just-landed crouch has-movement-input)
          (let [roll-duration (get anim-durations (get-animation-name :roll new-direction) 0.8)]
            [:roll roll-duration 0.0 0.0 0.0 :none])

          ;; Just landed - normal landing animation
          just-landed
          [:land 0.0 0.0 0.0 0.0 :none]

          ;; Still playing landing animation (only while grounded)
          (and grounded (= movement-state :land) (> land-timer 0.0))
          [:land 0.0 0.0 0.0 0.0 :none]

          ;; GROUNDED: Roll initiation (crouch + in run state)
          ;; JKA checks PM_RunningAnim, not speed - if in run anim and crouch, roll immediately
          (and grounded crouch (= movement-state :run))
          (let [roll-duration (get anim-durations (get-animation-name :roll new-direction) 0.8)]
            [:roll roll-duration 0.0 0.0 0.0 :none])

          ;; IN AIR: Wall flip back (forward + wall in front + just pressed jump)
          (and (not grounded) forward wall-front just-pressed-jump)
          (let [flip-duration (get anim-durations "BOTH_WALL_FLIP_BACK1" 0.8)]
            [:wallflipback 0.0 0.0 0.0 flip-duration :none])

          ;; IN AIR: Wall run initiation (strafe into wall + jump held + not too high)
          (and (not grounded) jump-held (or (and left wall-left) (and right wall-right)))
          (let [side (if (and left wall-left) :left :right)
                wallrun-duration (get anim-durations (if (= side :left)
                                                       "BOTH_WALL_RUN_LEFT"
                                                       "BOTH_WALL_RUN_RIGHT") 1.5)]
            [:wallrun 0.0 0.0 wallrun-duration 0.0 side])

          ;; IN AIR: Wall run flip (during wall run + jump pressed)
          (and (= movement-state :wallrun) just-pressed-jump)
          (let [flip-anim (if (= wallrun-side :left)
                            "BOTH_WALL_RUN_LEFT_FLIP"
                            "BOTH_WALL_RUN_RIGHT_FLIP")
                flip-duration (get anim-durations flip-anim 0.8)]
            [:wallrunflip 0.0 0.0 0.0 flip-duration wallrun-side])

          ;; IN AIR: Flip - triggers when holding jump + direction on a new jump
          can-flip
          (let [flip-duration (get anim-durations (get-animation-name :flip new-direction) 0.8)]
            [:flip 0.0 flip-duration 0.0 0.0 :none])

          ;; IN AIR: Glide/T-pose - triggers when movement keys are released while in air
          ;; Player jumps with direction held, then releases direction keys -> T-pose glide
          ;; Only triggers if movement was held at some point during this jump (not just standing jump)
          (and (not grounded) is-falling new-had-movement-this-jump (not has-movement-input))
          [:inair 0.0 0.0 0.0 0.0 :none]

          ;; IN AIR: Jump pose - default air state
          (not grounded)
          [:jump 0.0 0.0 0.0 0.0 :none]

          ;; GROUNDED: Running
          has-movement-input
          [:run 0.0 0.0 0.0 0.0 :none]

          ;; GROUNDED: Idle
          :else
          [:idle 0.0 0.0 0.0 0.0 :none])

        ;; Get new animation name
        ;; For wall run, use the wallrun-side to determine direction
        effective-direction (if (= new-movement-state :wallrun)
                              new-wallrun-side
                              (if (= new-movement-state :wallrunflip)
                                new-wallrun-side
                                new-direction))
        new-anim (get-animation-name new-movement-state effective-direction)

        ;; Animation changed?
        anim-changed (not= new-anim current-anim)

        ;; Update time (loop within duration, but not for one-shot anims)
        ;; Jump and inair animations should hold at end, not loop
        one-shot? (or (= new-movement-state :roll)
                      (= new-movement-state :flip)
                      (= new-movement-state :wallrun)
                      (= new-movement-state :wallrunflip)
                      (= new-movement-state :wallflipback)
                      (= new-movement-state :land)
                      (= new-movement-state :jump)
                      (= new-movement-state :inair))
        new-time (if anim-changed
                   0.0
                   (let [duration (get anim-durations new-anim 1.0)
                         next-time (+ current-time dt)]
                     (if one-shot?
                       ;; One-shot: clamp at end
                       (min next-time duration)
                       ;; Looping: wrap around
                       (if (and (> duration 0.0) (>= next-time duration))
                         (let [remainder (- next-time duration)]
                           (if (>= remainder duration)
                             (- next-time (* duration (cpp/floor (cpp// (cpp/double next-time) (cpp/double duration)))))
                             remainder))
                         next-time))))

        ;; Update land timer
        new-land-timer (cond
                         just-landed LAND_DURATION
                         (= new-movement-state :land) (max 0.0 (- land-timer dt))
                         :else 0.0)]

    {:movement-state new-movement-state
     :direction new-direction
     :current-anim new-anim
     :current-time new-time
     :was-grounded grounded
     :land-timer new-land-timer
     :roll-timer new-roll-timer
     :flip-timer new-flip-timer
     :wallrun-timer new-wallrun-timer
     :wallflip-timer new-wallflip-timer
     :air-time new-air-time
     :was-jump-held jump-held
     :had-movement-this-jump new-had-movement-this-jump
     :flip-ready new-flip-ready
     :jump-held-since-takeoff new-jump-held-since-takeoff
     :has-flipped-this-jump new-has-flipped-this-jump
     :wallrun-side new-wallrun-side}))

(defn get-time-ratio
  "Gets current animation time as 0.0-1.0 ratio"
  [{:keys [current-anim current-time]} anim-durations]
  (let [duration (get anim-durations current-anim 1.0)]
    (if (> duration 0.0)
      (min 1.0 (max 0.0 (/ current-time duration)))
      0.0)))

;; =============================================================================
;; Animation Loading Helper
;; =============================================================================

(defn load-jka-animations
  "Loads all JKA movement animations and returns index map"
  [ctx base-path]
  (loop [names MOVEMENT_ANIMATIONS
         idx 0
         indices {}
         durations {}]
    (if (empty? names)
      {:indices indices :durations durations}
      (let [name (first names)
            path (str base-path name ".ozz")
            info (anim/load-animation {:path path :context ctx})]
        (recur (rest names)
               (inc idx)
               (assoc indices name idx)
               (assoc durations name (double (:duration info))))))))

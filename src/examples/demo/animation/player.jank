(ns examples.demo.animation.player
  "Player animation state machine implemented as a behavior tree.

   Implements movement mechanics:
   - Rolls: crouch + running on ground
   - Flips: force jump + direction in air
   - Wall runs: jump toward wall + strafe
   - Wall flip back: forward into wall + jump

   All animation selection is input-driven, not velocity-driven."
  (:require [engine.3d.animation.interface :as anim]
            [engine.behavior-tree.interface :as bt]))

;; =============================================================================
;; Animation Name Mappings
;; =============================================================================

;; Movement state -> direction -> animation name
(def ANIMATION_MAP
  {:idle      {:forward "BOTH_STAND1"
               :backward "BOTH_STAND1"
               :left "BOTH_STAND1"
               :right "BOTH_STAND1"
               :none "BOTH_STAND1"}

   :walk      {:forward "BOTH_WALK1"
               :backward "BOTH_WALKBACK1"
               :left "BOTH_WALK1"
               :right "BOTH_WALK1"
               :none "BOTH_WALK1"}

   :run       {:forward "BOTH_RUN1"
               :backward "BOTH_RUNBACK1"
               :left "BOTH_RUN1"
               :right "BOTH_RUN1"
               :none "BOTH_RUN1"}

   :jump      {:forward "BOTH_JUMP1"
               :backward "BOTH_JUMPBACK1"
               :left "BOTH_JUMPLEFT1"
               :right "BOTH_JUMPRIGHT1"
               :none "BOTH_JUMP1"}

   :inair     {:forward "BOTH_INAIR1"
               :backward "BOTH_INAIRBACK1"
               :left "BOTH_INAIRLEFT1"
               :right "BOTH_INAIRRIGHT1"
               :none "BOTH_INAIR1"}

   :land      {:forward "BOTH_LAND1"
               :backward "BOTH_LANDBACK1"
               :left "BOTH_LANDLEFT1"
               :right "BOTH_LANDRIGHT1"
               :none "BOTH_LAND1"}

   :forcejump {:forward "BOTH_FORCEJUMP1"
               :backward "BOTH_FORCEJUMPBACK1"
               :left "BOTH_FORCEJUMPLEFT1"
               :right "BOTH_FORCEJUMPRIGHT1"
               :none "BOTH_FORCEJUMP1"}

   :forceinair {:forward "BOTH_FORCEINAIR1"
                :backward "BOTH_FORCEINAIRBACK1"
                :left "BOTH_FORCEINAIRLEFT1"
                :right "BOTH_FORCEINAIRRIGHT1"
                :none "BOTH_FORCEINAIR1"}

   :forceland {:forward "BOTH_FORCELAND1"
               :backward "BOTH_FORCELANDBACK1"
               :left "BOTH_FORCELANDLEFT1"
               :right "BOTH_FORCELANDRIGHT1"
               :none "BOTH_FORCELAND1"}

   :roll      {:forward "BOTH_ROLL_F"
               :backward "BOTH_ROLL_B"
               :left "BOTH_ROLL_L"
               :right "BOTH_ROLL_R"
               :none "BOTH_ROLL_F"}

   :flip      {:forward "BOTH_FLIP_F"
               :backward "BOTH_FLIP_B"
               :left "BOTH_FLIP_L"
               :right "BOTH_FLIP_R"
               :none "BOTH_FLIP_F"}

   :wallrun   {:forward "BOTH_WALL_RUN_RIGHT"
               :backward "BOTH_WALL_RUN_RIGHT"
               :left "BOTH_WALL_RUN_LEFT"
               :right "BOTH_WALL_RUN_RIGHT"
               :none "BOTH_WALL_RUN_RIGHT"}

   :wallrunflip {:forward "BOTH_WALL_RUN_RIGHT_FLIP"
                 :backward "BOTH_WALL_RUN_RIGHT_FLIP"
                 :left "BOTH_WALL_RUN_LEFT_FLIP"
                 :right "BOTH_WALL_RUN_RIGHT_FLIP"
                 :none "BOTH_WALL_RUN_RIGHT_FLIP"}

   :wallflipback {:forward "BOTH_WALL_FLIP_BACK1"
                  :backward "BOTH_WALL_FLIP_BACK1"
                  :left "BOTH_WALL_FLIP_LEFT"
                  :right "BOTH_WALL_FLIP_RIGHT"
                  :none "BOTH_WALL_FLIP_BACK1"}})

;; Core movement animations to load
(def MOVEMENT_ANIMATIONS
  ["BOTH_STAND1" "BOTH_STAND2"
   "BOTH_WALK1" "BOTH_WALKBACK1"
   "BOTH_RUN1" "BOTH_RUNBACK1"
   "BOTH_JUMP1" "BOTH_JUMPBACK1" "BOTH_JUMPLEFT1" "BOTH_JUMPRIGHT1"
   "BOTH_INAIR1" "BOTH_INAIRBACK1" "BOTH_INAIRLEFT1" "BOTH_INAIRRIGHT1"
   "BOTH_LAND1" "BOTH_LANDBACK1" "BOTH_LANDLEFT1" "BOTH_LANDRIGHT1"
   "BOTH_FORCEJUMP1" "BOTH_FORCEJUMPBACK1" "BOTH_FORCEJUMPLEFT1" "BOTH_FORCEJUMPRIGHT1"
   "BOTH_FORCEINAIR1" "BOTH_FORCEINAIRBACK1" "BOTH_FORCEINAIRLEFT1" "BOTH_FORCEINAIRRIGHT1"
   "BOTH_FORCELAND1" "BOTH_FORCELANDBACK1" "BOTH_FORCELANDLEFT1" "BOTH_FORCELANDRIGHT1"
   "BOTH_ROLL_F" "BOTH_ROLL_B" "BOTH_ROLL_L" "BOTH_ROLL_R"
   "BOTH_FLIP_F" "BOTH_FLIP_B" "BOTH_FLIP_L" "BOTH_FLIP_R" "BOTH_FLIP_BACK1"
   "BOTH_WALL_RUN_LEFT" "BOTH_WALL_RUN_RIGHT"
   "BOTH_WALL_RUN_LEFT_FLIP" "BOTH_WALL_RUN_RIGHT_FLIP"
   "BOTH_WALL_RUN_LEFT_STOP" "BOTH_WALL_RUN_RIGHT_STOP"
   "BOTH_WALL_FLIP_BACK1" "BOTH_WALL_FLIP_LEFT" "BOTH_WALL_FLIP_RIGHT"])

;; =============================================================================
;; Constants
;; =============================================================================

(def LAND_DURATION 0.2)
(def WALL_RUN_MIN_HEIGHT 0.5)

;; Height thresholds for force jump
;; Player must exceed normal jump height before flip triggers
(def NORMAL_JUMP_HEIGHT 1.0)  ; Height of a normal jump
(def GLIDE_VELOCITY_THRESHOLD 64.0)  ; Below this speed, transition to glide

;; =============================================================================
;; Helper Functions
;; =============================================================================

(defn direction-from-input
  "Gets direction keyword from input keys.
   Priority: forward > backward > left > right"
  [{:keys [forward backward left right]}]
  (cond
    forward :forward
    backward :backward
    left :left
    right :right
    :else :none))

(defn get-animation-name
  "Gets animation name for movement state and direction"
  [movement-state direction]
  (let [state-map (get ANIMATION_MAP movement-state)]
    (if state-map
      (get state-map direction "BOTH_STAND1")
      "BOTH_STAND1")))

(defn has-movement-input?
  "Check if any movement keys are pressed"
  [{:keys [input]}]
  (let [{:keys [forward backward left right]} input]
    (or forward backward left right)))

;; =============================================================================
;; State Management
;; =============================================================================

(defn create-player-state
  "Creates initial player animation state"
  []
  {:movement-state :idle
   :direction :forward
   :current-anim "BOTH_STAND1"
   :current-time 0.0
   :was-grounded true
   :land-timer 0.0
   :roll-timer 0.0
   :flip-timer 0.0
   :wallrun-timer 0.0
   :wallflip-timer 0.0
   :was-jump-held false
   :has-flipped-this-jump false
   :wallrun-side :none
   ;; Height tracking for force jump
   :force-jump-z-start 0.0  ; Height when jump started
   ;; Derived state (computed pre-tick)
   :just-landed false
   :just-jumped false
   :just-pressed-jump false
   :can-flip false
   :velocity-small false})

;; =============================================================================
;; Condition Functions
;; =============================================================================

(defn locked?
  "Check if we're in an animation that must play to completion"
  [{:keys [st-memory]}]
  (let [{:keys [movement-state roll-timer flip-timer wallrun-timer wallflip-timer]} @st-memory
        timer (case movement-state
                :roll roll-timer
                :flip flip-timer
                :wallrun wallrun-timer
                (:wallrunflip :wallflipback) wallflip-timer
                0.0)]
    (and (#{:roll :flip :wallrun :wallrunflip :wallflipback} movement-state)
         (> timer 0.0))))

(defn just-landed?
  [{:keys [st-memory]}]
  (:just-landed @st-memory))

(defn just-jumped?
  [{:keys [st-memory]}]
  (:just-jumped @st-memory))

(defn just-pressed-jump?
  [{:keys [st-memory]}]
  (:just-pressed-jump @st-memory))

(defn grounded?
  [{:keys [input]}]
  (:grounded input))

(defn in-air?
  [{:keys [input]}]
  (not (:grounded input)))

(defn crouching?
  [{:keys [input]}]
  (:crouch input))

(defn forward?
  [{:keys [input]}]
  (:forward input))

(defn wall-front?
  [{:keys [input]}]
  (:wall-front input))

(defn jump-held?
  [{:keys [input]}]
  (:jump-held input))

(defn strafe-into-wall?
  [{:keys [input]}]
  (let [{:keys [left right wall-left wall-right]} input]
    (or (and left wall-left) (and right wall-right))))

(defn in-land-state?
  [{:keys [st-memory]}]
  (= (:movement-state @st-memory) :land))

(defn land-timer-active?
  [{:keys [st-memory]}]
  (> (:land-timer @st-memory) 0.0))

(defn in-run-state?
  [{:keys [st-memory]}]
  (= (:movement-state @st-memory) :run))

(defn in-wallrun-state?
  [{:keys [st-memory]}]
  (= (:movement-state @st-memory) :wallrun))

(defn can-flip?
  [{:keys [st-memory]}]
  (:can-flip @st-memory))

(defn velocity-small?
  "Check if velocity is below glide threshold.
   Only true if already in an air animation."
  [{:keys [st-memory]}]
  (let [{:keys [velocity-small movement-state]} @st-memory]
    ;; Only transition to glide if already in jump/inair/forcejump state
    (and velocity-small
         (#{:jump :inair :forcejump :forceinair} movement-state))))

(defn no-movement?
  "Check if no directional keys are pressed"
  [{:keys [input]}]
  (let [{:keys [forward backward left right]} input]
    (not (or forward backward left right))))

(defn no-forward-backward?
  "Check if no forward/backward keys are pressed (strafe OK).
   Force jump when not moving forward/back but strafe is allowed."
  [{:keys [input]}]
  (let [{:keys [forward backward]} input]
    (not (or forward backward))))

(defn in-forcejump-state?
  "Check if in force jump state (for transitioning to forceinair)"
  [{:keys [st-memory]}]
  (= (:movement-state @st-memory) :forcejump))

(defn in-forceinair-state?
  "Check if in force inair state"
  [{:keys [st-memory]}]
  (= (:movement-state @st-memory) :forceinair))

(defn backward?
  "Check if backward key is pressed"
  [{:keys [input]}]
  (:backward input))

;; =============================================================================
;; Action Functions
;; =============================================================================

(defn set-state!
  "Helper to update movement state and animation.
   opts can include: :roll-timer :flip-timer :wallrun-timer :wallflip-timer :wallrun-side"
  ([st-memory movement-state direction]
   (set-state! st-memory movement-state direction {}))
  ([st-memory movement-state direction opts]
   (let [roll-timer (get opts :roll-timer 0.0)
         flip-timer (get opts :flip-timer 0.0)
         wallrun-timer (get opts :wallrun-timer 0.0)
         wallflip-timer (get opts :wallflip-timer 0.0)
         wallrun-side (get opts :wallrun-side :none)
         effective-direction (if (#{:wallrun :wallrunflip} movement-state)
                               wallrun-side
                               direction)
         anim-name (get-animation-name movement-state effective-direction)]
     (swap! st-memory merge
            {:movement-state movement-state
             :direction direction
             :current-anim anim-name
             :current-time 0.0
             :roll-timer roll-timer
             :flip-timer flip-timer
             :wallrun-timer wallrun-timer
             :wallflip-timer wallflip-timer
             :wallrun-side wallrun-side}))))

(defn continue-locked
  "Continue playing locked animation"
  [{:keys [st-memory]}]
  ;; Just return success, timers are updated in pre-tick
  bt/success)

(defn start-roll
  [{:keys [st-memory input anim-durations]}]
  (let [direction (direction-from-input input)
        anim-name (get-animation-name :roll direction)
        duration (get anim-durations anim-name 0.8)]
    (set-state! st-memory :roll direction {:roll-timer duration})
    bt/success))

(defn start-land
  [{:keys [st-memory input]}]
  (let [direction (direction-from-input input)]
    (set-state! st-memory :land direction)
    (swap! st-memory assoc :land-timer LAND_DURATION)
    bt/success))

(defn continue-land
  [{:keys [st-memory]}]
  ;; Just return success, timer is updated in pre-tick
  bt/success)

(defn start-wallflipback
  [{:keys [st-memory input anim-durations]}]
  (let [direction (direction-from-input input)
        duration (get anim-durations "BOTH_WALL_FLIP_BACK1" 0.8)]
    (set-state! st-memory :wallflipback direction {:wallflip-timer duration})
    bt/success))

(defn start-wallrun
  [{:keys [st-memory input anim-durations]}]
  (let [{:keys [left wall-left]} input
        side (if (and left wall-left) :left :right)
        anim-name (if (= side :left) "BOTH_WALL_RUN_LEFT" "BOTH_WALL_RUN_RIGHT")
        duration (get anim-durations anim-name 1.5)
        direction (direction-from-input input)]
    (set-state! st-memory :wallrun direction {:wallrun-timer duration :wallrun-side side})
    bt/success))

(defn start-wallrunflip
  [{:keys [st-memory anim-durations]}]
  (let [{:keys [wallrun-side direction]} @st-memory
        anim-name (if (= wallrun-side :left) "BOTH_WALL_RUN_LEFT_FLIP" "BOTH_WALL_RUN_RIGHT_FLIP")
        duration (get anim-durations anim-name 0.8)]
    (set-state! st-memory :wallrunflip direction {:wallflip-timer duration :wallrun-side wallrun-side})
    bt/success))

(defn start-flip
  [{:keys [st-memory input anim-durations]}]
  (let [direction (direction-from-input input)
        anim-name (get-animation-name :flip direction)
        duration (get anim-durations anim-name 0.8)]
    (set-state! st-memory :flip direction {:flip-timer duration})
    (swap! st-memory assoc :has-flipped-this-jump true :flip-ready true)
    bt/success))

(defn start-backflip
  "Ground-initiated backflip (press back + jump from ground).
   Uses BOTH_FLIP_BACK1 which is different from the mid-air BOTH_FLIP_B"
  [{:keys [st-memory anim-durations]}]
  (let [anim-name "BOTH_FLIP_BACK1"
        duration (get anim-durations anim-name 0.8)]
    ;; Use :backflip state to distinguish from mid-air flip
    (swap! st-memory merge
           {:movement-state :flip
            :direction :backward
            :current-anim anim-name
            :current-time 0.0
            :flip-timer duration
            :has-flipped-this-jump true})
    bt/success))

(defn start-inair
  [{:keys [st-memory input]}]
  (let [direction (direction-from-input input)
        current (:movement-state @st-memory)]
    ;; Only reset if changing state
    (when (not= current :inair)
      (set-state! st-memory :inair direction))
    bt/success))

(defn start-jump
  [{:keys [st-memory input]}]
  (let [direction (direction-from-input input)
        current (:movement-state @st-memory)]
    ;; Only reset if changing state
    (when (not= current :jump)
      (set-state! st-memory :jump direction))
    bt/success))

(defn start-forcejump
  "Force jump - T-pose arms out, used when jump held but no directional input"
  [{:keys [st-memory input]}]
  (let [direction (direction-from-input input)
        current (:movement-state @st-memory)]
    (when (not= current :forcejump)
      (set-state! st-memory :forcejump direction))
    bt/success))

(defn start-forceinair
  "Force jump in-air pose"
  [{:keys [st-memory input]}]
  (let [direction (direction-from-input input)
        current (:movement-state @st-memory)]
    (when (not= current :forceinair)
      (set-state! st-memory :forceinair direction))
    bt/success))

(defn continue-forcejump
  "Continue force jump animation while in air"
  [{:keys [st-memory]}]
  bt/success)

(defn continue-forceinair
  "Continue force inair animation"
  [{:keys [st-memory]}]
  bt/success)

(defn start-run
  [{:keys [st-memory input]}]
  (let [direction (direction-from-input input)
        current (:movement-state @st-memory)]
    ;; Only reset if changing state
    (when (not= current :run)
      (set-state! st-memory :run direction))
    bt/success))

(defn start-idle
  [{:keys [st-memory]}]
  (let [current (:movement-state @st-memory)]
    ;; Only reset if changing state
    (when (not= current :idle)
      (set-state! st-memory :idle :none)))
  bt/success)

;; =============================================================================
;; Behavior Tree Definition
;; =============================================================================

(def player-tree-config
  "Player animation behavior tree structure.
   Priority-based: first matching sequence wins (fallback semantics)."
  [:fallback
   ;; Priority 1: Locked animations continue
   [:sequence [:condition locked?] [:action continue-locked]]

   ;; Priority 2: Roll on landing
   [:sequence [:condition just-landed?] [:condition crouching?]
              [:condition has-movement-input?] [:action start-roll]]

   ;; Priority 3: Normal landing
   [:sequence [:condition just-landed?] [:action start-land]]

   ;; Priority 4: Continue landing animation
   [:sequence [:condition grounded?] [:condition in-land-state?]
              [:condition land-timer-active?] [:action continue-land]]

   ;; Priority 5: Ground roll (crouch while running)
   [:sequence [:condition grounded?] [:condition crouching?]
              [:condition in-run-state?] [:action start-roll]]

   ;; Priority 6: Ground backflip (backward + jump from ground)
   ;; Use just-jumped? since grounded becomes false on the same frame
   [:sequence [:condition just-jumped?] [:condition backward?]
              [:condition jump-held?] [:action start-backflip]]

   ;; Priority 7: Wall flip back
   [:sequence [:condition in-air?] [:condition forward?]
              [:condition wall-front?] [:condition just-pressed-jump?]
              [:action start-wallflipback]]

   ;; Priority 7: Wall run
   [:sequence [:condition in-air?] [:condition jump-held?]
              [:condition strafe-into-wall?] [:action start-wallrun]]

   ;; Priority 8: Wall run flip
   [:sequence [:condition in-wallrun-state?] [:condition just-pressed-jump?]
              [:action start-wallrunflip]]

   ;; Priority 9: Flip (height threshold + ascending + direction + jump held)
   [:sequence [:condition can-flip?] [:action start-flip]]

   ;; Priority 10: Force jump (just jumped + jump held + no forward/back)
   ;; This is the T-pose arms-out jump when you release forward/back but hold jump
   ;; Strafe (left/right) is allowed and will use directional force jump animations
   [:sequence [:condition just-jumped?] [:condition jump-held?]
              [:condition no-forward-backward?] [:action start-forcejump]]

   ;; Priority 11: Continue force jump while in air (don't fall through to regular jump)
   [:sequence [:condition in-air?] [:condition in-forcejump-state?]
              [:action continue-forcejump]]

   ;; Priority 12: Force in-air (glide after force jump when velocity small)
   [:sequence [:condition in-air?] [:condition in-forceinair-state?]
              [:action continue-forceinair]]

   ;; Priority 13: Glide (velocity magnitude < 64, transition to inair)
   [:sequence [:condition in-air?] [:condition velocity-small?]
              [:action start-inair]]

   ;; Priority 14: Jump pose (default air state with directional input)
   [:sequence [:condition in-air?] [:action start-jump]]

   ;; Priority 12: Run (grounded with movement)
   [:sequence [:condition grounded?] [:condition has-movement-input?]
              [:action start-run]]

   ;; Priority 13: Idle (default)
   [:action start-idle]])

;; =============================================================================
;; Pre-tick and Post-tick State Updates
;; =============================================================================

(defn pre-tick!
  "Update derived state before running the behavior tree.
   Computes edge detection, timers, and complex conditions.

   Flip logic:
   - Flip requires: in air, jump held, ascending, past height threshold, has direction input

   Glide logic:
   - Glide when horizontal velocity < 64 units/sec"
  [st-memory input dt]
  (let [state @st-memory
        {:keys [was-grounded was-jump-held has-flipped-this-jump
                roll-timer flip-timer wallrun-timer wallflip-timer land-timer
                movement-state force-jump-z-start]} state
        {:keys [grounded jump-held forward backward left right height vy speed]} input
        has-movement (or forward backward left right)

        ;; Edge detection
        just-landed (and grounded (not was-grounded))
        just-jumped (and (not grounded) was-grounded)
        just-pressed-jump (and jump-held (not was-jump-held))

        ;; Update timers
        new-roll-timer (if (> roll-timer 0.0) (max 0.0 (- roll-timer dt)) 0.0)
        new-flip-timer (if (> flip-timer 0.0) (max 0.0 (- flip-timer dt)) 0.0)
        new-wallrun-timer (if (> wallrun-timer 0.0) (max 0.0 (- wallrun-timer dt)) 0.0)
        new-wallflip-timer (if (> wallflip-timer 0.0) (max 0.0 (- wallflip-timer dt)) 0.0)
        new-land-timer (cond
                         just-landed LAND_DURATION
                         (= movement-state :land) (max 0.0 (- land-timer dt))
                         :else 0.0)

        ;; Track jump start height
        new-force-jump-z-start (cond
                                 just-jumped (or height 0.0)  ; Record height at takeoff
                                 grounded 0.0                  ; Reset on ground
                                 :else force-jump-z-start)     ; Keep tracking

        ;; Calculate height traveled since jump start
        cur-height (if (and (not grounded) (> new-force-jump-z-start 0.0))
                     (- (or height 0.0) new-force-jump-z-start)
                     0.0)

        ;; Reset flip flag on landing
        new-has-flipped-this-jump (if grounded false has-flipped-this-jump)

        ;; Can-flip check:
        ;; 1. In air
        ;; 2. Jump held
        ;; 3. Still ascending (velocity[2] > 0)
        ;; 4. Past normal jump height threshold
        ;; 5. Has directional input NOW (not stored)
        ;; 6. Haven't already flipped this jump
        ;; 7. Not already in flip animation
        ascending (> (or vy 0.0) 0.0)
        past-height-threshold (> cur-height NORMAL_JUMP_HEIGHT)
        can-flip (and (not grounded)
                      jump-held
                      ascending
                      past-height-threshold
                      has-movement
                      (not new-has-flipped-this-jump)
                      (not= movement-state :flip)
                      (<= flip-timer 0.0))

        ;; Velocity check for glide transition
        ;; Transition to INAIR when horizontal speed < 64
        velocity-small (< (or speed 0.0) GLIDE_VELOCITY_THRESHOLD)]

    (swap! st-memory merge
           {:roll-timer new-roll-timer
            :flip-timer new-flip-timer
            :wallrun-timer new-wallrun-timer
            :wallflip-timer new-wallflip-timer
            :land-timer new-land-timer
            :force-jump-z-start new-force-jump-z-start
            :has-flipped-this-jump new-has-flipped-this-jump
            :can-flip can-flip
            :velocity-small velocity-small
            ;; Edge detection results
            :just-landed just-landed
            :just-jumped just-jumped
            :just-pressed-jump just-pressed-jump})))

(defn post-tick!
  "Update state after running the behavior tree.
   Saves was-* state for next frame edge detection."
  [st-memory input dt anim-durations]
  (let [{:keys [grounded jump-held]} input
        state @st-memory
        {:keys [movement-state current-anim current-time]} state

        ;; Determine if animation is one-shot (holds at end) or looping
        one-shot? (#{:roll :flip :wallrun :wallrunflip :wallflipback :land :jump :inair :forcejump :forceinair} movement-state)
        duration (get anim-durations current-anim 1.0)
        next-time (+ current-time dt)
        new-time (if one-shot?
                   (min next-time duration)
                   (if (and (> duration 0.0) (>= next-time duration))
                     (let [remainder (- next-time duration)]
                       (if (>= remainder duration)
                         (- next-time (* duration (cpp/floor (cpp// (cpp/double next-time) (cpp/double duration)))))
                         remainder))
                     next-time))]

    (swap! st-memory assoc
           :was-grounded grounded
           :was-jump-held jump-held
           :current-time new-time)))

;; =============================================================================
;; Debug Logging
;; =============================================================================

(def DEBUG_LOG true)

(defn log-debug [& args]
  (when DEBUG_LOG
    (println (apply str args))))

;; =============================================================================
;; Main Update Function
;; =============================================================================

(defn create-player-behavior-tree
  "Creates the player animation behavior tree."
  [anim-durations]
  (bt/build player-tree-config {:st-memory (atom (create-player-state))
                                 :anim-durations anim-durations}))

(defn update-player-state
  "Updates player animation state using behavior tree.
   Returns the current state map for rendering.

   Backwards-compatible API:
   - player-state: Either a behavior tree or a plain state map (with embedded :__bt)
   - input: Current frame input
   - dt: Delta time
   - anim-durations: Animation duration map (used to create bt if needed)"
  [player-state input dt anim-durations]
  (let [;; Get or create behavior tree
        bt (cond
             ;; Already a behavior tree object
             (:tree player-state) player-state
             ;; State map with embedded behavior tree
             (:__bt player-state) (:__bt player-state)
             ;; Plain state map - create new behavior tree
             :else (create-player-behavior-tree anim-durations))
        ctx (:context bt)
        st-memory (:st-memory ctx)
        {:keys [forward backward left right jump-held grounded]} input
        has-mov (or forward backward left right)]

    ;; Pre-tick: compute derived state
    (pre-tick! st-memory input dt)

    (let [pre-state @st-memory
          {:keys [just-jumped just-landed movement-state]} pre-state]
      ;; Log when there's interesting input or state changes
      (when (or has-mov jump-held just-jumped just-landed)
        (log-debug "INPUT: fwd=" forward " bck=" backward " L=" left " R=" right
                   " jump=" jump-held " gnd=" grounded
                   " | PRE: just-jumped=" just-jumped " just-landed=" just-landed
                   " state=" movement-state)))

    ;; Run behavior tree with current input
    (bt/run (assoc bt :context (assoc ctx :input input)))

    (let [post-state @st-memory
          {:keys [movement-state current-anim]} post-state]
      ;; Log the result
      (when (or has-mov jump-held (:just-jumped @st-memory) (:just-landed @st-memory))
        (log-debug "  -> RESULT: state=" movement-state " anim=" current-anim)))

    ;; Post-tick: update animation time and was-* state
    (post-tick! st-memory input dt anim-durations)

    ;; Return current state with embedded behavior tree for next call
    (assoc @st-memory :__bt bt)))

(defn get-time-ratio
  "Gets current animation time as 0.0-1.0 ratio"
  [{:keys [current-anim current-time]} anim-durations]
  (let [duration (get anim-durations current-anim 1.0)]
    (if (> duration 0.0)
      (min 1.0 (max 0.0 (/ current-time duration)))
      0.0)))

;; =============================================================================
;; Animation Loading Helper
;; =============================================================================

(defn load-player-animations
  "Loads all player movement animations and returns index map"
  [ctx base-path]
  (loop [names MOVEMENT_ANIMATIONS
         idx 0
         indices {}
         durations {}]
    (if (empty? names)
      {:indices indices :durations durations}
      (let [name (first names)
            path (str base-path name ".ozz")
            info (anim/load-animation {:path path :context ctx})]
        (recur (rest names)
               (inc idx)
               (assoc indices name idx)
               (assoc durations name (double (:duration info))))))))

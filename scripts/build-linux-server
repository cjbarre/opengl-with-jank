#!/usr/bin/env bash
set -euo pipefail

# Build Linux headless server distribution from macOS via SSH to VM
# Supports both ARM64 and x86_64 architectures (auto-detected on remote)
# Requires SSH key authentication (add key to ssh-agent or use default key)
#
# Usage: ./scripts/build-linux-server [options] [game]
#   game          Game to compile (default: demo)
#   --ip IP       VM IP address (default: auto-detect or 192.168.64.4)
#   --user USER   SSH user (default: cjbarre)
#   --sync-only   Only sync files, don't compile
#   --no-sync     Skip file sync, just compile
#   --help        Show this help

# Resolve script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Defaults
VM_IP=""
VM_USER="cjbarre"
GAME="demo"
SYNC_ONLY=false
NO_SYNC=false
REMOTE_DIR="~/opengl-with-jank"
JANK_HOME="/home/cjbarre/jank"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --ip) VM_IP="$2"; shift 2 ;;
        --user) VM_USER="$2"; shift 2 ;;
        --sync-only) SYNC_ONLY=true; shift ;;
        --no-sync) NO_SYNC=true; shift ;;
        --help)
            sed -n '3,13p' "$0" | sed 's/^# //'
            exit 0
            ;;
        -*) echo "Unknown option: $1"; exit 1 ;;
        *) GAME="$1"; shift ;;
    esac
done

NAMESPACE="examples.${GAME}.server"
OUTPUT="${GAME}-server"

# Auto-detect VM IP if not provided
if [[ -z "$VM_IP" ]]; then
    echo "Auto-detecting VM IP..."
    # Try common UTM IPs
    for ip in 192.168.64.6 192.168.64.4 192.168.64.3 192.168.64.2; do
        if timeout 2 bash -c "echo >/dev/tcp/$ip/22" 2>/dev/null; then
            VM_IP="$ip"
            echo "Found VM at $VM_IP"
            break
        fi
    done
    if [[ -z "$VM_IP" ]]; then
        echo "ERROR: Could not auto-detect VM IP. Use --ip to specify."
        exit 1
    fi
fi

# SSH helper (assumes SSH key is loaded in ssh-agent or default key exists)
ssh_cmd() {
    ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 "$VM_USER@$VM_IP" "$@"
}

scp_cmd() {
    scp -o StrictHostKeyChecking=no -r "$@"
}

# Test connection
echo "Testing connection to $VM_USER@$VM_IP..."
if ! ssh_cmd "echo 'Connected'" &>/dev/null; then
    echo "ERROR: Cannot connect to VM. Ensure SSH key is loaded (ssh-add) and VM IP is correct."
    exit 1
fi
echo "Connected successfully."

# Sync files
if [[ "$NO_SYNC" != true ]]; then
    echo ""
    echo "=== Syncing files to VM ==="

    echo "Creating remote directory structure..."
    ssh_cmd "mkdir -p $REMOTE_DIR/src $REMOTE_DIR/include $REMOTE_DIR/scripts $REMOTE_DIR/libs"

    echo "Syncing src/..."
    scp_cmd "$PROJECT_DIR/src/"* "$VM_USER@$VM_IP:$REMOTE_DIR/src/"

    echo "Syncing include/..."
    scp_cmd "$PROJECT_DIR/include/"* "$VM_USER@$VM_IP:$REMOTE_DIR/include/"

    echo "Syncing scripts/..."
    scp_cmd "$PROJECT_DIR/scripts/"* "$VM_USER@$VM_IP:$REMOTE_DIR/scripts/"

    echo "Syncing models (for collision meshes)..."
    scp_cmd "$PROJECT_DIR/models" "$VM_USER@$VM_IP:$REMOTE_DIR/"

    echo "Syncing libs/glm (header-only math library)..."
    scp_cmd "$PROJECT_DIR/libs/glm" "$VM_USER@$VM_IP:$REMOTE_DIR/libs/"

    echo "Files synced."
fi

if [[ "$SYNC_ONLY" == true ]]; then
    echo "Sync complete (--sync-only specified)."
    exit 0
fi

# Detect remote architecture
REMOTE_ARCH=$(ssh_cmd "uname -m")
case "$REMOTE_ARCH" in
    aarch64|arm64) LINUX_ARCH="arm64"; LIBS_ARCH="linux-arm64" ;;
    x86_64|amd64) LINUX_ARCH="x86_64"; LIBS_ARCH="linux-x86_64" ;;
    *) LINUX_ARCH="$REMOTE_ARCH"; LIBS_ARCH="linux-$REMOTE_ARCH" ;;
esac
echo "Detected remote architecture: $REMOTE_ARCH -> $LIBS_ARCH"

# Build required libraries if missing
echo ""
echo "=== Checking/building required libraries ==="

ssh_cmd bash << EOF
set -e
cd $REMOTE_DIR

LIBS_ARCH="$LIBS_ARCH"

# Build enet if missing
if [ ! -f "libs/\$LIBS_ARCH/enet/lib/libenet.so" ]; then
    echo "Building enet..."
    mkdir -p libs/\$LIBS_ARCH/enet/lib
    cat > /tmp/enet_impl.c << 'IMPL'
#define ENET_IMPLEMENTATION
#include "enet.h"
IMPL
    gcc -shared -fPIC -o libs/\$LIBS_ARCH/enet/lib/libenet.so /tmp/enet_impl.c -Iinclude
    echo "enet built successfully"
else
    echo "enet already exists"
fi

# Build cgltf if missing
if [ ! -f "libs/\$LIBS_ARCH/cgltf/lib/libcgltf.so" ]; then
    echo "Building cgltf..."
    mkdir -p libs/\$LIBS_ARCH/cgltf/lib
    cat > /tmp/cgltf_impl.c << 'IMPL'
#define CGLTF_IMPLEMENTATION
#include "cgltf.h"
IMPL
    gcc -shared -fPIC -o libs/\$LIBS_ARCH/cgltf/lib/libcgltf.so /tmp/cgltf_impl.c -Iinclude
    echo "cgltf built successfully"
else
    echo "cgltf already exists"
fi
EOF

# Compile on VM
echo ""
echo "=== Compiling $OUTPUT on Linux $LINUX_ARCH ==="

ssh_cmd "cd $REMOTE_DIR && \
export LD_LIBRARY_PATH=\"\$PWD/libs/$LIBS_ARCH/enet/lib:\$PWD/libs/$LIBS_ARCH/cgltf/lib\" && \
export PATH=\"$JANK_HOME/compiler+runtime/build:\$PATH\" && \
echo 'Running jank compile (headless server)...' && \
jank \
  -I libs/glm -I include \
  -L libs/$LIBS_ARCH/enet/lib -lenet \
  -L libs/$LIBS_ARCH/cgltf/lib -lcgltf \
  --module-path $JANK_HOME/compiler+runtime/src/jank:src compile $NAMESPACE -o $OUTPUT && \
echo 'Compilation successful!' && \
ls -lh $OUTPUT"

# Package distribution
echo ""
echo "=== Packaging server distribution ==="

ssh_cmd bash << EOF
set -e
cd $REMOTE_DIR

# Detect architecture for library paths
ARCH=\$(uname -m)
case "\$ARCH" in
    aarch64|arm64) LIBS_ARCH="linux-arm64" ;;
    x86_64|amd64) LIBS_ARCH="linux-x86_64" ;;
    *) LIBS_ARCH="linux-\$ARCH" ;;
esac

# Clean and create dist structure
rm -rf dist-server
mkdir -p dist-server/bin dist-server/lib dist-server/lib/jank/0.1/bin dist-server/lib/jank/0.1/include dist-server/lib/jank/0.1/lib/clang dist-server/lib/jank/0.1/src

# Move executable
cp $OUTPUT dist-server/bin/

# Copy server libraries (minimal - no graphics)
cp libs/\$LIBS_ARCH/enet/lib/libenet.so dist-server/lib/ 2>/dev/null || echo "Warning: libenet.so not found"
cp libs/\$LIBS_ARCH/cgltf/lib/libcgltf.so dist-server/lib/ 2>/dev/null || echo "Warning: libcgltf.so not found"

# Copy clang for JIT
JANK_LLVM=$JANK_HOME/compiler+runtime/build/llvm-install/usr/local
cp \$JANK_LLVM/bin/clang-22 dist-server/lib/jank/0.1/bin/
ln -sf clang-22 dist-server/lib/jank/0.1/bin/clang++
ln -sf clang-22 dist-server/lib/jank/0.1/bin/clang

# Copy LLVM shared libraries needed by clang
cp \$JANK_LLVM/lib/libclang-cpp.so.22.0git dist-server/lib/
cp \$JANK_LLVM/lib/libLLVM.so.22.0git dist-server/lib/
ln -sf libclang-cpp.so.22.0git dist-server/lib/libclang-cpp.so
ln -sf libLLVM.so.22.0git dist-server/lib/libLLVM.so

# Copy clang resources
cp -R \$JANK_LLVM/lib/clang/22 dist-server/lib/jank/0.1/lib/clang/

# Copy libc++ headers (both generic and platform-specific)
cp -R \$JANK_LLVM/include/c++ dist-server/lib/jank/0.1/include/ 2>/dev/null || true
# Copy platform-specific headers (contains __config_site)
if [ -d "\$JANK_LLVM/include/aarch64-unknown-linux-gnu" ]; then
    cp -R \$JANK_LLVM/include/aarch64-unknown-linux-gnu dist-server/lib/jank/0.1/include/
fi
if [ -d "\$JANK_LLVM/include/x86_64-unknown-linux-gnu" ]; then
    cp -R \$JANK_LLVM/include/x86_64-unknown-linux-gnu dist-server/lib/jank/0.1/include/
fi

# Copy jank headers and stdlib
JANK_DIR=$JANK_HOME/compiler+runtime
cp -R \$JANK_DIR/include/cpp/jank dist-server/lib/jank/0.1/include/
cp -R \$JANK_DIR/src/jank/* dist-server/lib/jank/0.1/src/

# Bundle GCC libstdc++ headers for fully standalone distribution
# These are needed by clang for JIT compilation at runtime
mkdir -p dist-server/lib/jank/0.1/include/c++
cp -R /usr/include/c++/14 dist-server/lib/jank/0.1/include/c++/ 2>/dev/null || cp -R /usr/include/c++/13 dist-server/lib/jank/0.1/include/c++/ 2>/dev/null || true

# Detect architecture and copy appropriate platform-specific headers
if [ "\$ARCH" = "aarch64" ] || [ "\$ARCH" = "arm64" ]; then
    mkdir -p dist-server/lib/jank/0.1/include/aarch64-linux-gnu/c++
    cp -R /usr/include/aarch64-linux-gnu/c++/14 dist-server/lib/jank/0.1/include/aarch64-linux-gnu/c++/ 2>/dev/null || \
    cp -R /usr/include/aarch64-linux-gnu/c++/13 dist-server/lib/jank/0.1/include/aarch64-linux-gnu/c++/ 2>/dev/null || true
elif [ "\$ARCH" = "x86_64" ]; then
    mkdir -p dist-server/lib/jank/0.1/include/x86_64-linux-gnu/c++
    cp -R /usr/include/x86_64-linux-gnu/c++/14 dist-server/lib/jank/0.1/include/x86_64-linux-gnu/c++/ 2>/dev/null || \
    cp -R /usr/include/x86_64-linux-gnu/c++/13 dist-server/lib/jank/0.1/include/x86_64-linux-gnu/c++/ 2>/dev/null || true
fi

# Copy models (needed for collision mesh)
cp -r models dist-server/

echo "Base distribution created, now bundling for standalone..."
EOF

# Bundle for standalone distribution (includes glibc)
echo ""
echo "=== Bundling standalone distribution (with glibc) ==="

ssh_cmd bash << EOF
set -e
cd $REMOTE_DIR

# Source platform functions
source scripts/platform/common.sh

# Bundle all dependencies including glibc
bundle_all_dependencies dist-server

# Fix clang rpath to find libs in the flat lib/ directory
patchelf --add-rpath '\$ORIGIN/../../../lib' dist-server/lib/jank/0.1/bin/clang-22 2>/dev/null || true

# Create symlink for jank resource discovery when run via bundled glibc loader
# (The loader becomes /proc/self/exe, so jank looks for resources relative to lib/glibc/)
mkdir -p dist-server/lib/lib
ln -sf ../../jank dist-server/lib/lib/jank

# Generate standalone launcher that uses bundled ld-linux
generate_standalone_launcher_script dist-server/${OUTPUT}_run "bin/$OUTPUT" "lib"

echo ""
echo "Standalone server distribution ready:"
du -sh dist-server/
ls -la dist-server/
EOF

# Detect remote architecture
REMOTE_ARCH=$(ssh_cmd "uname -m")
case "$REMOTE_ARCH" in
    aarch64|arm64) LINUX_ARCH="arm64" ;;
    x86_64|amd64) LINUX_ARCH="x86_64" ;;
    *) LINUX_ARCH="$REMOTE_ARCH" ;;
esac

# Copy back to macOS (use tar to preserve symlinks)
echo ""
echo "=== Copying distribution to macOS ==="

LINUX_DIST_DIR="$PROJECT_DIR/dist-linux-${LINUX_ARCH}-server"
rm -rf "$LINUX_DIST_DIR"
mkdir -p "$LINUX_DIST_DIR"

# Use tar over ssh to preserve symlinks
ssh_cmd "cd $REMOTE_DIR && tar -cf - dist-server" | tar -xf - -C "$PROJECT_DIR"
mv "$PROJECT_DIR/dist-server"/* "$LINUX_DIST_DIR/"
rm -rf "$PROJECT_DIR/dist-server"

# Create archive
echo ""
echo "=== Creating archive ==="

DIST_DIR="$PROJECT_DIR/dist"
mkdir -p "$DIST_DIR"
ARCHIVE_NAME="${OUTPUT}-linux-${LINUX_ARCH}-standalone.tar.gz"

# Create archive with clean directory name
cd "$(dirname "$LINUX_DIST_DIR")"
tar -czhf "$DIST_DIR/$ARCHIVE_NAME" "$(basename "$LINUX_DIST_DIR")"

# Clean up unpacked distribution
rm -rf "$LINUX_DIST_DIR"

echo ""
echo "=== Build complete! ==="
echo ""
echo "Standalone archive: $DIST_DIR/$ARCHIVE_NAME"
ls -lh "$DIST_DIR/$ARCHIVE_NAME"
echo ""
echo "This is a FULLY STANDALONE distribution - no system dependencies required."
echo "Includes: glibc, LLVM/clang, libstdc++ headers"
echo ""
echo "To deploy to ANY Linux ${LINUX_ARCH} server:"
echo "  1. Upload: scp $DIST_DIR/$ARCHIVE_NAME user@server:"
echo "  2. Extract: tar -xzf $ARCHIVE_NAME"
echo "  3. Run: cd dist-linux-${LINUX_ARCH}-server && ./${OUTPUT}_run"

#!/usr/bin/env bash
set -euo pipefail

# Build Linux distribution from macOS via SSH to VM
# Supports both ARM64 and x86_64 architectures (auto-detected on remote)
# Requires SSH key authentication (add key to ssh-agent or use default key)
#
# Usage: ./scripts/build-linux [options] [game]
#   game          Game to compile (default: demo)
#   --ip IP       VM IP address (default: auto-detect or 192.168.64.4)
#   --user USER   SSH user (default: cjbarre)
#   --sync-only   Only sync files, don't compile
#   --no-sync     Skip file sync, just compile
#   --help        Show this help

# Resolve script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Defaults
VM_IP=""
VM_USER="cjbarre"
GAME="demo"
SYNC_ONLY=false
NO_SYNC=false
REMOTE_DIR="~/opengl-with-jank"
JANK_HOME="/home/cjbarre/jank"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --ip) VM_IP="$2"; shift 2 ;;
        --user) VM_USER="$2"; shift 2 ;;
        --sync-only) SYNC_ONLY=true; shift ;;
        --no-sync) NO_SYNC=true; shift ;;
        --help)
            sed -n '3,13p' "$0" | sed 's/^# //'
            exit 0
            ;;
        -*) echo "Unknown option: $1"; exit 1 ;;
        *) GAME="$1"; shift ;;
    esac
done

NAMESPACE="examples.${GAME}.core"

# Auto-detect VM IP if not provided
if [[ -z "$VM_IP" ]]; then
    echo "Auto-detecting VM IP..."
    # Try common UTM IPs
    for ip in 192.168.64.6 192.168.64.4 192.168.64.3 192.168.64.2; do
        if timeout 2 bash -c "echo >/dev/tcp/$ip/22" 2>/dev/null; then
            VM_IP="$ip"
            echo "Found VM at $VM_IP"
            break
        fi
    done
    if [[ -z "$VM_IP" ]]; then
        echo "ERROR: Could not auto-detect VM IP. Use --ip to specify."
        exit 1
    fi
fi

# SSH helper (assumes SSH key is loaded in ssh-agent or default key exists)
ssh_cmd() {
    ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 "$VM_USER@$VM_IP" "$@"
}

scp_cmd() {
    scp -o StrictHostKeyChecking=no -r "$@"
}

# Test connection
echo "Testing connection to $VM_USER@$VM_IP..."
if ! ssh_cmd "echo 'Connected'" &>/dev/null; then
    echo "ERROR: Cannot connect to VM. Ensure SSH key is loaded (ssh-add) and VM IP is correct."
    exit 1
fi
echo "Connected successfully."

# Sync files
if [[ "$NO_SYNC" != true ]]; then
    echo ""
    echo "=== Syncing files to VM ==="

    echo "Creating remote directory structure..."
    ssh_cmd "mkdir -p $REMOTE_DIR/src $REMOTE_DIR/include $REMOTE_DIR/scripts $REMOTE_DIR/libs"

    echo "Syncing src/..."
    scp_cmd "$PROJECT_DIR/src/"* "$VM_USER@$VM_IP:$REMOTE_DIR/src/"

    echo "Syncing include/..."
    scp_cmd "$PROJECT_DIR/include/"* "$VM_USER@$VM_IP:$REMOTE_DIR/include/"

    echo "Syncing scripts/..."
    scp_cmd "$PROJECT_DIR/scripts/"* "$VM_USER@$VM_IP:$REMOTE_DIR/scripts/"

    echo "Syncing assets..."
    scp_cmd "$PROJECT_DIR/shaders" "$VM_USER@$VM_IP:$REMOTE_DIR/"
    scp_cmd "$PROJECT_DIR/textures" "$VM_USER@$VM_IP:$REMOTE_DIR/"
    scp_cmd "$PROJECT_DIR/models" "$VM_USER@$VM_IP:$REMOTE_DIR/"
    scp_cmd "$PROJECT_DIR/fonts" "$VM_USER@$VM_IP:$REMOTE_DIR/"

    echo "Syncing libs/glm (header-only math library)..."
    scp_cmd "$PROJECT_DIR/libs/glm" "$VM_USER@$VM_IP:$REMOTE_DIR/libs/"

    echo "Files synced."
fi

if [[ "$SYNC_ONLY" == true ]]; then
    echo "Sync complete (--sync-only specified)."
    exit 0
fi

# Detect remote architecture
REMOTE_ARCH=$(ssh_cmd "uname -m")
case "$REMOTE_ARCH" in
    aarch64|arm64) LINUX_ARCH="arm64"; LIBS_ARCH="linux-arm64"; SYS_LIB="/usr/lib/aarch64-linux-gnu" ;;
    x86_64|amd64) LINUX_ARCH="x86_64"; LIBS_ARCH="linux-x86_64"; SYS_LIB="/usr/lib/x86_64-linux-gnu" ;;
    *) LINUX_ARCH="$REMOTE_ARCH"; LIBS_ARCH="linux-$REMOTE_ARCH"; SYS_LIB="/usr/lib" ;;
esac
echo "Detected remote architecture: $REMOTE_ARCH -> $LIBS_ARCH"

# Build required libraries if missing
echo ""
echo "=== Checking/building required libraries ==="

ssh_cmd bash << EOF
set -e
cd $REMOTE_DIR

LIBS_ARCH="$LIBS_ARCH"

# Build enet if missing
if [ ! -f "libs/\$LIBS_ARCH/enet/lib/libenet.so" ]; then
    echo "Building enet..."
    mkdir -p libs/\$LIBS_ARCH/enet/lib
    cat > /tmp/enet_impl.c << 'IMPL'
#define ENET_IMPLEMENTATION
#include "enet.h"
IMPL
    gcc -shared -fPIC -o libs/\$LIBS_ARCH/enet/lib/libenet.so /tmp/enet_impl.c -Iinclude
    echo "enet built successfully"
else
    echo "enet already exists"
fi

# Build cgltf if missing
if [ ! -f "libs/\$LIBS_ARCH/cgltf/lib/libcgltf.so" ]; then
    echo "Building cgltf..."
    mkdir -p libs/\$LIBS_ARCH/cgltf/lib
    cat > /tmp/cgltf_impl.c << 'IMPL'
#define CGLTF_IMPLEMENTATION
#include "cgltf.h"
IMPL
    gcc -shared -fPIC -o libs/\$LIBS_ARCH/cgltf/lib/libcgltf.so /tmp/cgltf_impl.c -Iinclude
    echo "cgltf built successfully"
else
    echo "cgltf already exists"
fi

# Build stb if missing (force rebuild to include stb_truetype)
if [ ! -f "libs/\$LIBS_ARCH/stb/lib/libstb_all.so" ] || ! nm libs/\$LIBS_ARCH/stb/lib/libstb_all.so 2>/dev/null | grep -q stbtt_BakeFontBitmap; then
    echo "Building stb (image + truetype)..."
    mkdir -p libs/\$LIBS_ARCH/stb/lib
    cat > /tmp/stb_impl.c << 'IMPL'
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"
IMPL
    gcc -shared -fPIC -o libs/\$LIBS_ARCH/stb/lib/libstb_all.so /tmp/stb_impl.c -Iinclude -lm
    echo "stb built successfully"
else
    echo "stb already exists"
fi

# Build ozz-animation if missing
if [ ! -f "libs/\$LIBS_ARCH/ozz-animation/lib/libozz_animation_r.so" ]; then
    echo "Building ozz-animation (this may take a while)..."
    mkdir -p libs/\$LIBS_ARCH/ozz-animation/lib
    mkdir -p libs/\$LIBS_ARCH/ozz-animation/include

    # Clone if not present
    if [ ! -d "third_party/ozz-animation" ]; then
        git clone --depth 1 https://github.com/guillaumeblanc/ozz-animation.git third_party/ozz-animation
    fi

    # Build ozz-animation
    cd third_party/ozz-animation
    mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -Dozz_build_samples=OFF -Dozz_build_howtos=OFF -Dozz_build_tests=OFF
    make -j\$(nproc) ozz_animation ozz_base ozz_geometry
    cd ../../..

    # Copy built libraries
    cp third_party/ozz-animation/build/src/animation/runtime/libozz_animation_r.so libs/\$LIBS_ARCH/ozz-animation/lib/
    cp third_party/ozz-animation/build/src/base/libozz_base_r.so libs/\$LIBS_ARCH/ozz-animation/lib/
    cp third_party/ozz-animation/build/src/geometry/runtime/libozz_geometry_r.so libs/\$LIBS_ARCH/ozz-animation/lib/

    # Copy headers
    cp -r third_party/ozz-animation/include/ozz libs/\$LIBS_ARCH/ozz-animation/include/

    echo "ozz-animation built successfully"
else
    echo "ozz-animation already exists"
fi
EOF

# Compile on VM
echo ""
echo "=== Compiling $GAME on Linux $LINUX_ARCH ==="

ssh_cmd bash << EOF
set -e
cd $REMOTE_DIR

LIBS_ARCH="$LIBS_ARCH"
SYS_LIB="$SYS_LIB"

# Set library path (use system glfw, project ozz/stb/enet/cgltf)
export LD_LIBRARY_PATH="\$PWD/libs/\$LIBS_ARCH/ozz-animation/lib:\$PWD/libs/\$LIBS_ARCH/stb/lib:\$PWD/libs/\$LIBS_ARCH/enet/lib:\$PWD/libs/\$LIBS_ARCH/cgltf/lib:\$SYS_LIB"

# Add jank to PATH
export PATH="$JANK_HOME/compiler+runtime/build:\$PATH"

echo "Running jank compile..."
jank \\
  -I libs/\$LIBS_ARCH/ozz-animation/include -I libs/glm -I include \\
  -L libs/\$LIBS_ARCH/ozz-animation/lib -lozz_animation_r -lozz_base_r -lozz_geometry_r \\
  -L libs/\$LIBS_ARCH/stb/lib -lstb_all \\
  -L libs/\$LIBS_ARCH/enet/lib -lenet \\
  -L libs/\$LIBS_ARCH/cgltf/lib -lcgltf \\
  -I/usr/include -L\$SYS_LIB -lglfw -lGL -lGLEW \\
  --module-path $JANK_HOME/compiler+runtime/src/jank:src compile $NAMESPACE -o $GAME

echo "Compilation successful!"
ls -lh $GAME
EOF

# Package distribution
echo ""
echo "=== Packaging distribution ==="

ssh_cmd bash << EOF
set -e
cd $REMOTE_DIR

LIBS_ARCH="$LIBS_ARCH"

# Clean and create dist structure
rm -rf dist
mkdir -p dist/bin dist/lib

# Copy binary
cp $GAME dist/bin/

# Copy game libraries (use -a to preserve symlinks)
# System libraries (glfw, GL, GLEW)
cp -a /usr/lib/x86_64-linux-gnu/libglfw.so* dist/lib/ 2>/dev/null || cp -a /usr/lib/aarch64-linux-gnu/libglfw.so* dist/lib/ 2>/dev/null || true
cp -a /usr/lib/x86_64-linux-gnu/libGLEW.so* dist/lib/ 2>/dev/null || cp -a /usr/lib/aarch64-linux-gnu/libGLEW.so* dist/lib/ 2>/dev/null || true
# Project libraries
cp -a libs/\$LIBS_ARCH/ozz-animation/lib/*.so* dist/lib/ 2>/dev/null || true
cp -a libs/\$LIBS_ARCH/stb/lib/*.so* dist/lib/ 2>/dev/null || true
cp -a libs/\$LIBS_ARCH/enet/lib/*.so* dist/lib/ 2>/dev/null || true
cp -a libs/\$LIBS_ARCH/cgltf/lib/*.so* dist/lib/ 2>/dev/null || true

# Copy assets
cp -r shaders dist/
cp -r textures dist/
cp -r models dist/
cp -r fonts dist/

echo "Base distribution created, now bundling for standalone..."
EOF

# Bundle for standalone distribution (includes glibc)
echo ""
echo "=== Bundling standalone distribution (with glibc) ==="

ssh_cmd bash << EOF
set -e
cd $REMOTE_DIR

# Source platform functions
source scripts/platform/common.sh

# Bundle all dependencies including glibc
bundle_all_dependencies dist

# Bundle jank runtime resources for JIT compilation
JANK_LLVM=$JANK_HOME/compiler+runtime/build/llvm-install/usr/local
JANK_DIR=$JANK_HOME/compiler+runtime

mkdir -p dist/lib/jank/0.1/bin dist/lib/jank/0.1/include dist/lib/jank/0.1/lib/clang dist/lib/jank/0.1/src

# Copy clang for JIT
cp \$JANK_LLVM/bin/clang-22 dist/lib/jank/0.1/bin/
ln -sf clang-22 dist/lib/jank/0.1/bin/clang++
ln -sf clang-22 dist/lib/jank/0.1/bin/clang

# Copy LLVM shared libraries needed by clang
cp \$JANK_LLVM/lib/libclang-cpp.so.22.0git dist/lib/
cp \$JANK_LLVM/lib/libLLVM.so.22.0git dist/lib/
ln -sf libclang-cpp.so.22.0git dist/lib/libclang-cpp.so
ln -sf libLLVM.so.22.0git dist/lib/libLLVM.so

# Copy clang resources
cp -R \$JANK_LLVM/lib/clang/22 dist/lib/jank/0.1/lib/clang/

# Copy libc++ headers
cp -R \$JANK_LLVM/include/c++ dist/lib/jank/0.1/include/ 2>/dev/null || true
if [ -d "\$JANK_LLVM/include/aarch64-unknown-linux-gnu" ]; then
    cp -R \$JANK_LLVM/include/aarch64-unknown-linux-gnu dist/lib/jank/0.1/include/
fi
if [ -d "\$JANK_LLVM/include/x86_64-unknown-linux-gnu" ]; then
    cp -R \$JANK_LLVM/include/x86_64-unknown-linux-gnu dist/lib/jank/0.1/include/
fi

# Copy jank headers and stdlib
cp -R \$JANK_DIR/include/cpp/jank dist/lib/jank/0.1/include/
cp -R \$JANK_DIR/src/jank/* dist/lib/jank/0.1/src/

# Bundle GCC libstdc++ headers for fully standalone distribution
mkdir -p dist/lib/jank/0.1/include/c++
cp -R /usr/include/c++/14 dist/lib/jank/0.1/include/c++/ 2>/dev/null || cp -R /usr/include/c++/13 dist/lib/jank/0.1/include/c++/ 2>/dev/null || true

# Detect architecture and copy appropriate platform-specific headers
ARCH=\$(uname -m)
if [ "\$ARCH" = "aarch64" ] || [ "\$ARCH" = "arm64" ]; then
    mkdir -p dist/lib/jank/0.1/include/aarch64-linux-gnu/c++
    cp -R /usr/include/aarch64-linux-gnu/c++/14 dist/lib/jank/0.1/include/aarch64-linux-gnu/c++/ 2>/dev/null || \
    cp -R /usr/include/aarch64-linux-gnu/c++/13 dist/lib/jank/0.1/include/aarch64-linux-gnu/c++/ 2>/dev/null || true
elif [ "\$ARCH" = "x86_64" ]; then
    mkdir -p dist/lib/jank/0.1/include/x86_64-linux-gnu/c++
    cp -R /usr/include/x86_64-linux-gnu/c++/14 dist/lib/jank/0.1/include/x86_64-linux-gnu/c++/ 2>/dev/null || \
    cp -R /usr/include/x86_64-linux-gnu/c++/13 dist/lib/jank/0.1/include/x86_64-linux-gnu/c++/ 2>/dev/null || true
fi

# Fix clang rpath
patchelf --add-rpath '\$ORIGIN/../../../lib' dist/lib/jank/0.1/bin/clang-22 2>/dev/null || true

# Create symlink for jank resource discovery when run via bundled glibc loader
# (The loader becomes /proc/self/exe, so jank looks for resources relative to lib/glibc/)
mkdir -p dist/lib/lib
ln -sf ../../jank dist/lib/lib/jank

# Generate standalone launcher that uses bundled ld-linux
generate_standalone_launcher_script dist/${GAME}_standalone_run "bin/$GAME" "lib"

# Also generate a regular launcher for graphical apps (uses system glibc, avoids X11 conflicts)
generate_launcher_script dist/${GAME}_run "bin/$GAME" "lib"

echo ""
echo "Standalone distribution ready:"
du -sh dist/
ls -la dist/
EOF

# Detect remote architecture
REMOTE_ARCH=$(ssh_cmd "uname -m")
case "$REMOTE_ARCH" in
    aarch64|arm64) LINUX_ARCH="arm64" ;;
    x86_64|amd64) LINUX_ARCH="x86_64" ;;
    *) LINUX_ARCH="$REMOTE_ARCH" ;;
esac

# Copy back to macOS
echo ""
echo "=== Copying distribution to macOS ==="

LINUX_DIST_DIR="$PROJECT_DIR/dist-linux-${LINUX_ARCH}"
rm -rf "$LINUX_DIST_DIR"
mkdir -p "$LINUX_DIST_DIR"

# Use tar over ssh to preserve symlinks
ssh_cmd "cd $REMOTE_DIR && tar -cf - dist" | tar -xf - -C "$PROJECT_DIR"
mv "$PROJECT_DIR/dist"/* "$LINUX_DIST_DIR/"
rm -rf "$PROJECT_DIR/dist"

# Create archive
echo ""
echo "=== Creating archive ==="

DIST_DIR="$PROJECT_DIR/dist"
mkdir -p "$DIST_DIR"
ARCHIVE_NAME="${GAME}-linux-${LINUX_ARCH}-standalone.tar.gz"

cd "$(dirname "$LINUX_DIST_DIR")"
tar -czhf "$DIST_DIR/$ARCHIVE_NAME" "$(basename "$LINUX_DIST_DIR")"

# Clean up unpacked distribution
rm -rf "$LINUX_DIST_DIR"

echo ""
echo "=== Build complete! ==="
echo ""
echo "Standalone archive: $DIST_DIR/$ARCHIVE_NAME"
ls -lh "$DIST_DIR/$ARCHIVE_NAME"
echo ""
echo "This is a FULLY STANDALONE distribution - no system dependencies required."
echo "Includes: glibc, LLVM/clang, libstdc++ headers"
echo ""
echo "To deploy to ANY Linux ${LINUX_ARCH} system:"
echo "  1. Copy: scp $DIST_DIR/$ARCHIVE_NAME user@host:"
echo "  2. Extract: tar -xzf $ARCHIVE_NAME"
echo "  3. Run: cd dist-linux-${LINUX_ARCH} && ./${GAME}_run"
